{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plan-Lint Documentation","text":"<ul> <li> <p> Validate LLM Agent Plans</p> <p>Static analysis toolkit for checking and validating agent plans before they execute.</p> <p> Getting started</p> </li> <li> <p> Policy Authoring</p> <p>Learn to write Rego policies that define security boundaries for your agents.</p> <p> Policy guide</p> </li> <li> <p> MCP Integration</p> <p>Integrate plan-lint with MCP servers for enhanced security.</p> <p> MCP Integration</p> </li> <li> <p> API Reference</p> <p>Comprehensive API documentation for plan-lint.</p> <p> API Reference</p> </li> </ul>"},{"location":"#what-is-plan-lint","title":"What is Plan-Lint?","text":"<p>Plan-Lint is a static analysis toolkit for validating LLM agent plans before execution. It provides a robust security layer that can prevent harmful actions, detect suspicious patterns, and enforce authorization policies - all before any code executes.</p> <pre><code>from plan_lint import validate_plan\n\n# Your agent generates a plan\nplan = agent.generate_plan(user_query)\n\n# Validate the plan against your policies\nvalidation_result = validate_plan(plan, policies=[\"policies/security.rego\"])\n\nif validation_result.valid:\n    # Execute the plan only if it passed validation\n    agent.execute_plan(plan)\nelse:\n    # Handle validation failure\n    print(f\"Plan validation failed: {validation_result.violations}\")\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plan-lint\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from plan_lint import validate_plan\n\n# Validate a plan against security policies\nresult = validate_plan(\n    plan_data,\n    policies=[\"path/to/policies/security.rego\"]\n)\n\nif result.valid:\n    print(\"Plan is valid\")\nelse:\n    print(f\"Plan validation failed with {len(result.violations)} violations:\")\n    for violation in result.violations:\n        print(f\" - {violation.message}\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Static Analysis: Validate plans before execution to prevent security issues</li> <li>Rego Policies: Use OPA's Rego language to define flexible, powerful policies</li> <li>Integration: Works with OpenAI, Anthropic, and custom agent frameworks</li> <li>MCP Support: Integrates with MCP servers for OAuth-aware policy enforcement</li> <li>Custom Rules: Define your own security policies based on your specific needs</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Check out our examples to see Plan-Lint in action. </p>"},{"location":"contributing/","title":"Contributing","text":"<p>This page provides guidelines for contributing to Plan-Lint.</p>"},{"location":"getting-started/","title":"Getting Started with Plan-Linter","text":"<p>This guide will help you get up and running with Plan-Linter.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#using-pip","title":"Using pip","text":"<pre><code>pip install plan-lint\n</code></pre>"},{"location":"getting-started/#from-source","title":"From source","text":"<pre><code>git clone https://github.com/cirbuk/plan-lint.git\ncd plan-lint\npip install -e .\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use Plan-Linter is to run it on a JSON plan file:</p> <pre><code>plan-lint path/to/plan.json\n</code></pre> <p>This will validate the plan against the default schema and report any issues.</p>"},{"location":"getting-started/#using-a-policy-file","title":"Using a Policy File","text":"<p>For more control, create a policy YAML file:</p> <pre><code># policy.yaml\nallow_tools:\n  - sql.query_ro\n  - priceAPI.calculate\nbounds:\n  priceAPI.calculate.discount_pct: [-40, 0]\ndeny_tokens_regex:\n  - \"AWS_SECRET\"\n  - \"API_KEY\"\nmax_steps: 50\nrisk_weights:\n  tool_write: 0.4\n  raw_secret: 0.5\nfail_risk_threshold: 0.8\n</code></pre> <p>Then run Plan-Linter with the policy:</p> <pre><code>plan-lint path/to/plan.json --policy policy.yaml\n</code></pre>"},{"location":"getting-started/#output-formats","title":"Output Formats","text":"<p>Plan-Linter can output in different formats:</p>"},{"location":"getting-started/#cli-default","title":"CLI (default)","text":"<pre><code>plan-lint path/to/plan.json\n</code></pre> <p>This shows a rich formatted report in the terminal.</p>"},{"location":"getting-started/#json","title":"JSON","text":"<pre><code>plan-lint path/to/plan.json --format json\n</code></pre> <p>This outputs a machine-readable JSON report.</p>"},{"location":"getting-started/#saving-output","title":"Saving Output","text":"<p>To save the output to a file:</p> <pre><code>plan-lint path/to/plan.json --output results.txt\n</code></pre> <p>Or for JSON:</p> <pre><code>plan-lint path/to/plan.json --format json --output results.json\n</code></pre>"},{"location":"getting-started/#ci-integration","title":"CI Integration","text":"<p>Plan-Linter can be integrated into CI pipelines. Add this to your GitHub workflow:</p> <pre><code>- name: Lint agent plan\n  run: |\n    plan-lint path/to/plan.json --policy policy.yaml\n</code></pre> <p>The command will return a non-zero exit code if the plan fails validation, which will fail the CI step.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See the README for more examples </li> <li>Read the Implementation Details</li> <li>Check out the Contributing Guide </li> </ul>"},{"location":"policy-authoring/","title":"Policy Authoring Guide","text":"<p>This guide will help you create custom policies for Plan-Lint using the Rego policy language.</p>"},{"location":"policy-authoring/#introduction-to-rego","title":"Introduction to Rego","text":"<p>Plan-Lint uses Rego, the policy language of Open Policy Agent (OPA), for defining validation rules. Rego is a declarative language specifically designed for expressing policies over complex data structures.</p>"},{"location":"policy-authoring/#basic-rego-concepts","title":"Basic Rego Concepts","text":"<ul> <li>Rules: Define conditions that should be met</li> <li>Packages: Group related rules together</li> <li>Imports: Include reusable functions or definitions</li> <li>Variables: Store intermediate values</li> <li>Comprehensions: Create collections by filtering and mapping</li> </ul>"},{"location":"policy-authoring/#plan-lint-policy-structure","title":"Plan-Lint Policy Structure","text":""},{"location":"policy-authoring/#package-naming","title":"Package Naming","text":"<p>All Plan-Lint policies should be defined in the <code>planlint.custom</code> package:</p> <pre><code>package planlint.custom\n</code></pre>"},{"location":"policy-authoring/#basic-policy-format","title":"Basic Policy Format","text":"<p>A typical policy rule follows this pattern:</p> <pre><code>deny[result] {\n    # Rule conditions\n    # ...\n\n    result := {\n        \"rule\": \"rule_name\",\n        \"message\": \"Human-readable message explaining the violation\",\n        \"severity\": \"high\",  # \"low\", \"medium\", \"high\", or \"critical\"\n        \"category\": \"category_name\",  # e.g., \"security\", \"performance\", etc.\n        \"step_id\": \"affected_step_id\",\n        \"metadata\": {\n            # Additional information about the violation\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#available-input-data","title":"Available Input Data","text":"<p>In your policies, you have access to:</p> <ul> <li><code>input.plan</code>: The full plan being validated</li> <li><code>input.context</code>: Additional context data provided during validation</li> </ul>"},{"location":"policy-authoring/#writing-your-first-policy","title":"Writing Your First Policy","text":"<p>Let's create a simple policy that detects file operations on sensitive paths:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Define sensitive paths\nsensitive_paths := [\"/etc/passwd\", \"/etc/shadow\", \"/var/log/auth.log\"]\n\n# Check if a file operation targets a sensitive path\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"file_operation\"\n\n    some path in sensitive_paths\n    startswith(step.parameters.path, path)\n\n    result := {\n        \"rule\": \"sensitive_path_access\",\n        \"message\": \"Operation attempts to access a sensitive system path\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"path\": step.parameters.path,\n            \"operation\": step.parameters.operation\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#advanced-policy-techniques","title":"Advanced Policy Techniques","text":""},{"location":"policy-authoring/#using-context-data","title":"Using Context Data","text":"<p>You can leverage context data to create more dynamic policies:</p> <pre><code>package planlint.custom\n\n# Check if a requested permission exceeds user's role\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"request_permission\"\n\n    # Get user role from context\n    user_role := input.context.user_role\n\n    # Define allowed permissions per role\n    allowed_permissions := {\n        \"user\": [\"read\"],\n        \"editor\": [\"read\", \"write\"],\n        \"admin\": [\"read\", \"write\", \"delete\", \"configure\"]\n    }\n\n    # Check if requested permission is allowed for this role\n    not step.parameters.permission in allowed_permissions[user_role]\n\n    result := {\n        \"rule\": \"permission_exceeds_role\",\n        \"message\": sprintf(\"User with role '%s' cannot request '%s' permission\", [user_role, step.parameters.permission]),\n        \"severity\": \"medium\",\n        \"category\": \"access_control\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"requested_permission\": step.parameters.permission,\n            \"user_role\": user_role,\n            \"allowed_permissions\": allowed_permissions[user_role]\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#step-dependencies-analysis","title":"Step Dependencies Analysis","text":"<p>You can analyze dependencies between steps:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect when sensitive data is passed to network operations\ndeny[result] {\n    # Find an authentication step\n    some auth_step in input.plan.steps\n    auth_step.tool == \"authenticate\"\n\n    # Find a network request step\n    some request_step in input.plan.steps\n    request_step.tool == \"http_request\"\n\n    # Check if auth data is referenced in request\n    contains(request_step.parameters.url, sprintf(\"{{%s.result}}\", [auth_step.id]))\n\n    result := {\n        \"rule\": \"auth_data_in_url\",\n        \"message\": \"Authentication data should not be included in URLs\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": request_step.id,\n        \"metadata\": {\n            \"auth_step\": auth_step.id,\n            \"url_parameter\": request_step.parameters.url\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#using-rego-built-in-functions","title":"Using Rego Built-in Functions","text":"<p>Rego provides many built-in functions for processing data:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Check for excessively large array operations\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"process_array\"\n\n    # Convert to number if string\n    array_size := to_number(step.parameters.size)\n\n    # Check if exceeds threshold\n    max_size := 10000\n    array_size &gt; max_size\n\n    result := {\n        \"rule\": \"large_array_operation\",\n        \"message\": \"Processing very large arrays can cause performance issues\",\n        \"severity\": \"medium\",\n        \"category\": \"performance\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"array_size\": array_size,\n            \"max_recommended_size\": max_size\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#pattern-matching-and-string-operations","title":"Pattern Matching and String Operations","text":"<p>Use pattern matching for detecting issues in string parameters:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect potential XSS vulnerabilities\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"render_html\"\n\n    # Look for common XSS patterns\n    dangerous_patterns := [\n        \"&lt;script&gt;\", \n        \"javascript:\", \n        \"onerror=\", \n        \"onload=\"\n    ]\n\n    some pattern in dangerous_patterns\n    contains(lower(step.parameters.content), pattern)\n\n    result := {\n        \"rule\": \"potential_xss\",\n        \"message\": \"HTML content contains potentially dangerous scripts\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"detected_pattern\": pattern\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#testing-your-policies","title":"Testing Your Policies","text":"<p>It's important to test policies with both valid and invalid plans:</p> <pre><code>package planlint.test\n\nimport data.planlint.custom\n\n# Test case for sensitive path access policy\ntest_sensitive_path_access {\n    # Define test plan with violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/etc/passwd\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that a violation was detected\n    count(violations) == 1\n    violations[_].rule == \"sensitive_path_access\"\n}\n\n# Test case for safe path\ntest_safe_path {\n    # Define test plan without violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/tmp/safe_file.txt\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that no violations were detected\n    count(violations) == 0\n}\n</code></pre> <p>To run these tests:</p> <pre><code>plan-lint test --policies your_policy.rego\n</code></pre>"},{"location":"policy-authoring/#organizing-multiple-policies","title":"Organizing Multiple Policies","text":"<p>For larger projects, organize policies into themes:</p> <pre><code>policies/\n  \u251c\u2500\u2500 security/\n  \u2502   \u251c\u2500\u2500 injection.rego\n  \u2502   \u251c\u2500\u2500 access_control.rego\n  \u2502   \u2514\u2500\u2500 data_exposure.rego\n  \u251c\u2500\u2500 performance/\n  \u2502   \u251c\u2500\u2500 resource_limits.rego\n  \u2502   \u2514\u2500\u2500 efficiency.rego\n  \u2514\u2500\u2500 reliability/\n      \u251c\u2500\u2500 error_handling.rego\n      \u2514\u2500\u2500 retries.rego\n</code></pre>"},{"location":"policy-authoring/#common-patterns-for-plan-lint-policies","title":"Common Patterns for Plan-Lint Policies","text":""},{"location":"policy-authoring/#detecting-dangerous-operations","title":"Detecting Dangerous Operations","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# List of dangerous system commands\ndangerous_commands := [\n    \"rm -rf\", \n    \"dd if=\", \n    \"mkfs\", \n    \"&gt; /dev/\",\n    \":(){ :|:&amp; };:\"  # Fork bomb\n]\n\n# Detect dangerous system commands\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"execute_command\"\n\n    some cmd in dangerous_commands\n    contains(step.parameters.command, cmd)\n\n    result := {\n        \"rule\": \"dangerous_system_command\",\n        \"message\": \"Plan contains a potentially destructive system command\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"command\": step.parameters.command,\n            \"detected_pattern\": cmd\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#enforcing-tool-constraints","title":"Enforcing Tool Constraints","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Limit the number of API calls in a plan\ndeny[result] {\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n    count(api_steps) &gt; 5\n\n    result := {\n        \"rule\": \"too_many_api_calls\",\n        \"message\": \"Plan contains too many API calls which may lead to rate limiting\",\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": api_steps[0].id,  # Reference the first API call\n        \"metadata\": {\n            \"api_call_count\": count(api_steps),\n            \"max_recommended\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#contextual-validation","title":"Contextual Validation","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Validate operations based on business hours\ndeny[result] {\n    # Only apply this rule if business_hours context is provided\n    input.context.business_hours\n\n    some step in input.plan.steps\n    step.tool == \"schedule_maintenance\"\n\n    # Convert maintenance time to number for comparison\n    maintenance_hour := to_number(step.parameters.hour)\n\n    # Check if maintenance is scheduled during business hours\n    maintenance_hour &gt;= input.context.business_hours.start\n    maintenance_hour &lt; input.context.business_hours.end\n\n    result := {\n        \"rule\": \"maintenance_during_business_hours\",\n        \"message\": \"Maintenance should be scheduled outside of business hours\",\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"scheduled_hour\": maintenance_hour,\n            \"business_hours\": sprintf(\"%d-%d\", [input.context.business_hours.start, input.context.business_hours.end])\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#best-practices","title":"Best Practices","text":"<ol> <li>Be Specific: Target policies to specific tools or operations</li> <li>Use Severity Levels Consistently: Follow these guidelines:</li> <li><code>critical</code>: Issues that must be fixed immediately</li> <li><code>high</code>: Significant security or reliability concerns</li> <li><code>medium</code>: Important but not critical issues</li> <li><code>low</code>: Minor concerns or best practice suggestions</li> <li>Include Helpful Messages: Make policy violation messages actionable and clear</li> <li>Add Metadata: Include relevant data to help developers understand and fix issues</li> <li>Test Thoroughly: Create test cases for both compliant and non-compliant plans</li> <li>Consider Performance: Complex policies might slow down validation; optimize when necessary</li> </ol>"},{"location":"policy-authoring/#debugging-policies","title":"Debugging Policies","text":"<p>When your policy isn't working as expected:</p> <ol> <li> <p>Use the <code>--debug</code> flag when running <code>plan-lint</code>:    <pre><code>plan-lint validate --plan my_plan.json --policies my_policy.rego --debug\n</code></pre></p> </li> <li> <p>Add print statements for debugging:    <pre><code>deny[result] {\n    # ...\n    print(\"Checking step:\", step.id)\n    print(\"Parameter value:\", step.parameters.value)\n    # ...\n}\n</code></pre></p> </li> <li> <p>Break down complex policies into smaller ones to isolate issues</p> </li> </ol>"},{"location":"policy-authoring/#policy-version-control","title":"Policy Version Control","text":"<p>For maintainable policies:</p> <ol> <li> <p>Add headers with version and author information:    <pre><code># Policy: prevent_sensitive_data_exposure\n# Version: 1.2\n# Author: Security Team\n# Last Updated: 2023-10-15\n# Description: Prevents exposure of sensitive data in logs and external services\npackage planlint.custom\n</code></pre></p> </li> <li> <p>Add comments explaining the rationale behind policy decisions</p> </li> <li> <p>Consider using meaningful file names that describe the policy's purpose</p> </li> </ol>"},{"location":"policy-authoring/#example-rate-limiting-policy","title":"Example: Rate Limiting Policy","text":"<p>Complete policy example for enforcing API rate limits:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Rate limiting policy for API calls\n# Checks that the same API endpoint isn't called too frequently within a plan\n\n# Configuration\ndefault max_calls_per_endpoint = 3\n\n# Get customized limit from context if available\nmax_calls_per_endpoint = limit {\n    limit := input.context.api_rate_limits.max_calls_per_endpoint\n}\n\n# Group API calls by endpoint\napi_calls_by_endpoint[endpoint] = calls {\n    # Collect all API call steps\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n\n    # Group by endpoint\n    endpoints := {endpoint | some step in api_steps; endpoint := step.parameters.endpoint}\n\n    # For each endpoint, collect all steps that call it\n    some endpoint in endpoints\n    calls := [step | some step in api_steps; step.parameters.endpoint == endpoint]\n}\n\n# Detect rate limit violations\ndeny[result] {\n    some endpoint, calls in api_calls_by_endpoint\n    count(calls) &gt; max_calls_per_endpoint\n\n    result := {\n        \"rule\": \"api_rate_limit_exceeded\",\n        \"message\": sprintf(\"Too many calls to API endpoint '%s'\", [endpoint]),\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": calls[0].id,  # Reference the first call to this endpoint\n        \"metadata\": {\n            \"endpoint\": endpoint,\n            \"call_count\": count(calls),\n            \"max_allowed\": max_calls_per_endpoint,\n            \"all_calls\": [step.id | some step in calls]\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#conclusion","title":"Conclusion","text":"<p>Creating effective policies is an iterative process. Start with simple rules and gradually build more complex validation logic as your understanding of potential issues grows. Remember that policies should balance security with usability - overly strict policies might frustrate users and lead to workarounds.</p> <p>For more examples and inspiration, check out the default policies included with Plan-Lint and the examples in the Plan-Lint documentation. </p>"},{"location":"advanced/automating-validation/","title":"Automating Validation","text":"<p>This page explains how to automate the validation of plans with Plan-Lint.</p>"},{"location":"advanced/ci-cd-integration/","title":"CI/CD Integration","text":"<p>This page explains how to integrate Plan-Lint into CI/CD pipelines.</p>"},{"location":"advanced/opa-integration/","title":"OPA Integration","text":"<p>This page explains how to integrate Plan-Lint with the Open Policy Agent.</p>"},{"location":"api/","title":"API Reference Overview","text":"<p>This section provides detailed information about the Plan-Lint API.</p>"},{"location":"api/core/","title":"Core API","text":"<p>This page documents the core API functions of Plan-Lint.</p>"},{"location":"api/loader/","title":"Loader API","text":"<p>This page documents the policy loader API of Plan-Lint.</p>"},{"location":"api/reference/","title":"API Reference","text":"<p>This document provides detailed information about the Plan-Lint API, including the main functions, classes, and their parameters.</p>"},{"location":"api/reference/#core-functions","title":"Core Functions","text":""},{"location":"api/reference/#validate_plan","title":"<code>validate_plan</code>","text":"<p>The primary function for validating plans against policies.</p> <pre><code>def validate_plan(\n    plan: Dict[str, Any],\n    policies: Optional[List[str]] = None,\n    context: Optional[Dict[str, Any]] = None,\n    config: Optional[Dict[str, Any]] = None\n) -&gt; ValidationResult:\n    \"\"\"\n    Validate a plan against policies.\n\n    Args:\n        plan: The plan to validate, containing steps and their tools/parameters\n        policies: Optional list of paths to policy files. If None, uses default policies\n        context: Optional context information to provide to the policies\n        config: Optional configuration for the validation process\n\n    Returns:\n        A ValidationResult object containing validation results\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#load_policy","title":"<code>load_policy</code>","text":"<p>Load a Rego policy from a file.</p> <pre><code>def load_policy(\n    policy_path: str\n) -&gt; str:\n    \"\"\"\n    Load a Rego policy file.\n\n    Args:\n        policy_path: Path to the Rego policy file\n\n    Returns:\n        The policy content as a string\n\n    Raises:\n        FileNotFoundError: If the policy file doesn't exist\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#format_plan","title":"<code>format_plan</code>","text":"<p>Format a plan to ensure it meets the expected structure for validation.</p> <pre><code>def format_plan(\n    plan: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Format a plan to ensure it has the expected structure.\n\n    Args:\n        plan: The plan to format\n\n    Returns:\n        The formatted plan\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#classes","title":"Classes","text":""},{"location":"api/reference/#validationresult","title":"<code>ValidationResult</code>","text":"<p>Contains the results of plan validation.</p> <pre><code>class ValidationResult:\n    \"\"\"\n    Result of a plan validation.\n\n    Attributes:\n        valid (bool): Whether the plan is valid according to all policies\n        violations (List[PolicyViolation]): List of policy violations found\n        details (Dict[str, Any]): Additional details about the validation\n\n    Methods:\n        to_dict(): Convert the result to a dictionary\n        to_json(): Convert the result to a JSON string\n    \"\"\"\n\n    @property\n    def valid(self) -&gt; bool:\n        \"\"\"Whether the plan is valid (no violations).\"\"\"\n\n    @property\n    def violations(self) -&gt; List[\"PolicyViolation\"]:\n        \"\"\"List of policy violations.\"\"\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the result to a dictionary.\"\"\"\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"Convert the result to a JSON string.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyviolation","title":"<code>PolicyViolation</code>","text":"<p>Represents a violation of a policy rule.</p> <pre><code>class PolicyViolation:\n    \"\"\"\n    Represents a violation of a policy rule.\n\n    Attributes:\n        rule (str): The policy rule that was violated\n        message (str): Description of the violation\n        severity (str): Severity level ('low', 'medium', 'high', 'critical')\n        category (str): Category of the violation (e.g., 'security', 'privacy')\n        step_id (Optional[str]): ID of the step that caused the violation\n        metadata (Dict[str, Any]): Additional metadata about the violation\n    \"\"\"\n\n    @property\n    def rule(self) -&gt; str:\n        \"\"\"The policy rule that was violated.\"\"\"\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Description of the violation.\"\"\"\n\n    @property\n    def severity(self) -&gt; str:\n        \"\"\"Severity level of the violation.\"\"\"\n\n    @property\n    def category(self) -&gt; str:\n        \"\"\"Category of the violation.\"\"\"\n\n    @property\n    def step_id(self) -&gt; Optional[str]:\n        \"\"\"ID of the step that caused the violation, if applicable.\"\"\"\n\n    @property\n    def metadata(self) -&gt; Dict[str, Any]:\n        \"\"\"Additional metadata about the violation.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyengine","title":"<code>PolicyEngine</code>","text":"<p>Manages policy evaluation using the Open Policy Agent.</p> <pre><code>class PolicyEngine:\n    \"\"\"\n    Engine for evaluating Rego policies against plans.\n\n    Methods:\n        evaluate(plan, policies, context): Evaluate policies against a plan\n    \"\"\"\n\n    def evaluate(\n        self,\n        plan: Dict[str, Any],\n        policies: List[str],\n        context: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Evaluate policies against a plan.\n\n        Args:\n            plan: The plan to evaluate\n            policies: List of policy file paths\n            context: Optional context information\n\n        Returns:\n            Evaluation results as a dictionary\n        \"\"\"\n</code></pre>"},{"location":"api/reference/#cli-commands","title":"CLI Commands","text":""},{"location":"api/reference/#plan-lint-validate","title":"<code>plan-lint validate</code>","text":"<p>Command-line interface for validating plans.</p> <pre><code>Usage: plan-lint validate [OPTIONS] PLAN_FILE\n\n  Validate a plan against policies.\n\nOptions:\n  --policies PATH...  Custom policy files to use\n  --context FILE      JSON file containing context information\n  --output FORMAT     Output format (text, json, yaml) [default: text]\n  --config FILE       Configuration file\n  --help              Show this message and exit\n</code></pre>"},{"location":"api/reference/#plan-lint-test","title":"<code>plan-lint test</code>","text":"<p>Command-line interface for testing policies.</p> <pre><code>Usage: plan-lint test [OPTIONS] [TEST_DIR]\n\n  Run policy tests.\n\nOptions:\n  --policies PATH...  Custom policy files to test\n  --verbose           Show detailed test output\n  --help              Show this message and exit\n</code></pre>"},{"location":"api/reference/#constants","title":"Constants","text":""},{"location":"api/reference/#severity-levels","title":"Severity Levels","text":"<pre><code>class Severity:\n    \"\"\"Severity levels for policy violations.\"\"\"\n\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n</code></pre>"},{"location":"api/reference/#violation-categories","title":"Violation Categories","text":"<pre><code>class Category:\n    \"\"\"Categories for policy violations.\"\"\"\n\n    SECURITY = \"security\"\n    PRIVACY = \"privacy\"\n    AUTHORIZATION = \"authorization\"\n    COMPLIANCE = \"compliance\"\n    RESOURCE = \"resource\"\n    GENERAL = \"general\"\n</code></pre>"},{"location":"api/reference/#error-classes","title":"Error Classes","text":""},{"location":"api/reference/#policyerror","title":"<code>PolicyError</code>","text":"<p>Base class for policy-related errors.</p> <pre><code>class PolicyError(Exception):\n    \"\"\"Base class for policy-related errors.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyloaderror","title":"<code>PolicyLoadError</code>","text":"<p>Error raised when a policy cannot be loaded.</p> <pre><code>class PolicyLoadError(PolicyError):\n    \"\"\"Raised when a policy cannot be loaded.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyevaluationerror","title":"<code>PolicyEvaluationError</code>","text":"<p>Error raised when policy evaluation fails.</p> <pre><code>class PolicyEvaluationError(PolicyError):\n    \"\"\"Raised when policy evaluation fails.\"\"\"\n</code></pre>"},{"location":"api/reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api/reference/#get_default_policies","title":"<code>get_default_policies</code>","text":"<p>Get the paths to the default policy files.</p> <pre><code>def get_default_policies() -&gt; List[str]:\n    \"\"\"\n    Get the paths to the default policy files.\n\n    Returns:\n        List of paths to default policy files\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#load_context","title":"<code>load_context</code>","text":"<p>Load context information from a file.</p> <pre><code>def load_context(context_path: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load context information from a JSON file.\n\n    Args:\n        context_path: Path to the context file\n\n    Returns:\n        Context information as a dictionary\n\n    Raises:\n        FileNotFoundError: If the context file doesn't exist\n        json.JSONDecodeError: If the context file is not valid JSON\n    \"\"\"\n</code></pre>"},{"location":"api/rules/","title":"Rules API","text":"<p>This page documents the rules API of Plan-Lint.</p>"},{"location":"api/types/","title":"Types API","text":"<p>This page documents the type definitions used in Plan-Lint.</p>"},{"location":"api/validator/","title":"Validator API","text":"<p>This page documents the validator API of Plan-Lint.</p>"},{"location":"documentation/","title":"Documentation Overview","text":"<p>Learn how to use and configure Plan-Lint.</p>"},{"location":"documentation/api-reference/","title":"API Reference","text":"<p>This document provides detailed information about the Plan-Lint API, including the main functions, classes, and their parameters.</p>"},{"location":"documentation/api-reference/#core-functions","title":"Core Functions","text":""},{"location":"documentation/api-reference/#validate_plan","title":"<code>validate_plan</code>","text":"<p>The primary function for validating plans against policies.</p> <pre><code>def validate_plan(\n    plan: Dict[str, Any],\n    policies: Optional[List[str]] = None,\n    context: Optional[Dict[str, Any]] = None,\n    config: Optional[Dict[str, Any]] = None\n) -&gt; ValidationResult:\n    \"\"\"\n    Validate a plan against policies.\n\n    Args:\n        plan: The plan to validate, containing steps and their tools/parameters\n        policies: Optional list of paths to policy files. If None, uses default policies\n        context: Optional context information to provide to the policies\n        config: Optional configuration for the validation process\n\n    Returns:\n        A ValidationResult object containing validation results\n    \"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#load_policy","title":"<code>load_policy</code>","text":"<p>Load a Rego policy from a file.</p> <pre><code>def load_policy(\n    policy_path: str\n) -&gt; str:\n    \"\"\"\n    Load a Rego policy file.\n\n    Args:\n        policy_path: Path to the Rego policy file\n\n    Returns:\n        The policy content as a string\n\n    Raises:\n        FileNotFoundError: If the policy file doesn't exist\n    \"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#format_plan","title":"<code>format_plan</code>","text":"<p>Format a plan to ensure it meets the expected structure for validation.</p> <pre><code>def format_plan(\n    plan: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Format a plan to ensure it has the expected structure.\n\n    Args:\n        plan: The plan to format\n\n    Returns:\n        The formatted plan\n    \"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#classes","title":"Classes","text":""},{"location":"documentation/api-reference/#validationresult","title":"<code>ValidationResult</code>","text":"<p>Contains the results of plan validation.</p> <pre><code>class ValidationResult:\n    \"\"\"\n    Result of a plan validation.\n\n    Attributes:\n        valid (bool): Whether the plan is valid according to all policies\n        violations (List[PolicyViolation]): List of policy violations found\n        details (Dict[str, Any]): Additional details about the validation\n\n    Methods:\n        to_dict(): Convert the result to a dictionary\n        to_json(): Convert the result to a JSON string\n    \"\"\"\n\n    @property\n    def valid(self) -&gt; bool:\n        \"\"\"Whether the plan is valid (no violations).\"\"\"\n\n    @property\n    def violations(self) -&gt; List[\"PolicyViolation\"]:\n        \"\"\"List of policy violations.\"\"\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the result to a dictionary.\"\"\"\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"Convert the result to a JSON string.\"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#policyviolation","title":"<code>PolicyViolation</code>","text":"<p>Represents a violation of a policy rule.</p> <pre><code>class PolicyViolation:\n    \"\"\"\n    Represents a violation of a policy rule.\n\n    Attributes:\n        rule (str): The policy rule that was violated\n        message (str): Description of the violation\n        severity (str): Severity level ('low', 'medium', 'high', 'critical')\n        category (str): Category of the violation (e.g., 'security', 'privacy')\n        step_id (Optional[str]): ID of the step that caused the violation\n        metadata (Dict[str, Any]): Additional metadata about the violation\n    \"\"\"\n\n    @property\n    def rule(self) -&gt; str:\n        \"\"\"The policy rule that was violated.\"\"\"\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Description of the violation.\"\"\"\n\n    @property\n    def severity(self) -&gt; str:\n        \"\"\"Severity level of the violation.\"\"\"\n\n    @property\n    def category(self) -&gt; str:\n        \"\"\"Category of the violation.\"\"\"\n\n    @property\n    def step_id(self) -&gt; Optional[str]:\n        \"\"\"ID of the step that caused the violation, if applicable.\"\"\"\n\n    @property\n    def metadata(self) -&gt; Dict[str, Any]:\n        \"\"\"Additional metadata about the violation.\"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#policyengine","title":"<code>PolicyEngine</code>","text":"<p>Manages policy evaluation using the Open Policy Agent.</p> <pre><code>class PolicyEngine:\n    \"\"\"\n    Engine for evaluating Rego policies against plans.\n\n    Methods:\n        evaluate(plan, policies, context): Evaluate policies against a plan\n    \"\"\"\n\n    def evaluate(\n        self,\n        plan: Dict[str, Any],\n        policies: List[str],\n        context: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Evaluate policies against a plan.\n\n        Args:\n            plan: The plan to evaluate\n            policies: List of policy file paths\n            context: Optional context information\n\n        Returns:\n            Evaluation results as a dictionary\n        \"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#cli-commands","title":"CLI Commands","text":""},{"location":"documentation/api-reference/#plan-lint-validate","title":"<code>plan-lint validate</code>","text":"<p>Command-line interface for validating plans.</p> <pre><code>Usage: plan-lint validate [OPTIONS] PLAN_FILE\n\n  Validate a plan against policies.\n\nOptions:\n  --policies PATH...  Custom policy files to use\n  --context FILE      JSON file containing context information\n  --output FORMAT     Output format (text, json, yaml) [default: text]\n  --config FILE       Configuration file\n  --help              Show this message and exit\n</code></pre>"},{"location":"documentation/api-reference/#plan-lint-test","title":"<code>plan-lint test</code>","text":"<p>Command-line interface for testing policies.</p> <pre><code>Usage: plan-lint test [OPTIONS] [TEST_DIR]\n\n  Run policy tests.\n\nOptions:\n  --policies PATH...  Custom policy files to test\n  --verbose           Show detailed test output\n  --help              Show this message and exit\n</code></pre>"},{"location":"documentation/api-reference/#constants","title":"Constants","text":""},{"location":"documentation/api-reference/#severity-levels","title":"Severity Levels","text":"<pre><code>class Severity:\n    \"\"\"Severity levels for policy violations.\"\"\"\n\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n</code></pre>"},{"location":"documentation/api-reference/#violation-categories","title":"Violation Categories","text":"<pre><code>class Category:\n    \"\"\"Categories for policy violations.\"\"\"\n\n    SECURITY = \"security\"\n    PRIVACY = \"privacy\"\n    AUTHORIZATION = \"authorization\"\n    COMPLIANCE = \"compliance\"\n    RESOURCE = \"resource\"\n    GENERAL = \"general\"\n</code></pre>"},{"location":"documentation/api-reference/#error-classes","title":"Error Classes","text":""},{"location":"documentation/api-reference/#policyerror","title":"<code>PolicyError</code>","text":"<p>Base class for policy-related errors.</p> <pre><code>class PolicyError(Exception):\n    \"\"\"Base class for policy-related errors.\"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#policyloaderror","title":"<code>PolicyLoadError</code>","text":"<p>Error raised when a policy cannot be loaded.</p> <pre><code>class PolicyLoadError(PolicyError):\n    \"\"\"Raised when a policy cannot be loaded.\"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#policyevaluationerror","title":"<code>PolicyEvaluationError</code>","text":"<p>Error raised when policy evaluation fails.</p> <pre><code>class PolicyEvaluationError(PolicyError):\n    \"\"\"Raised when policy evaluation fails.\"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"documentation/api-reference/#get_default_policies","title":"<code>get_default_policies</code>","text":"<p>Get the paths to the default policy files.</p> <pre><code>def get_default_policies() -&gt; List[str]:\n    \"\"\"\n    Get the paths to the default policy files.\n\n    Returns:\n        List of paths to default policy files\n    \"\"\"\n</code></pre>"},{"location":"documentation/api-reference/#load_context","title":"<code>load_context</code>","text":"<p>Load context information from a file.</p> <pre><code>def load_context(context_path: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load context information from a JSON file.\n\n    Args:\n        context_path: Path to the context file\n\n    Returns:\n        Context information as a dictionary\n\n    Raises:\n        FileNotFoundError: If the context file doesn't exist\n        json.JSONDecodeError: If the context file is not valid JSON\n    \"\"\"\n</code></pre>"},{"location":"documentation/custom-rule-development/","title":"Custom Rule Development","text":"<p>This page guides you through developing custom rules for Plan-Lint.</p>"},{"location":"documentation/examples/","title":"Plan-Lint Examples","text":"<p>This page provides practical examples of using Plan-Lint to validate AI agent plans.</p>"},{"location":"documentation/examples/#basic-example","title":"Basic Example","text":""},{"location":"documentation/examples/#sample-plan","title":"Sample Plan","text":"<p>Let's start with a simple plan that performs a database query and sends an email:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM customers WHERE id = 123\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"send_email\",\n      \"parameters\": {\n        \"to\": \"user@example.com\",\n        \"subject\": \"Your Account Information\",\n        \"body\": \"Here is your requested information: {{step1.result}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#validation-with-default-policies","title":"Validation with Default Policies","text":"<p>To validate this plan with default policies:</p> <pre><code>plan-lint validate --plan example_plan.json\n</code></pre> <p>This will check for potential issues such as SQL injection vulnerabilities and sensitive data exposure.</p>"},{"location":"documentation/examples/#sql-injection-detection","title":"SQL Injection Detection","text":""},{"location":"documentation/examples/#vulnerable-plan","title":"Vulnerable Plan","text":"<p>Consider a plan with a potential SQL injection vulnerability:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#validation-output","title":"Validation Output","text":"<p>Running Plan-Lint on this vulnerable plan:</p> <pre><code>plan-lint validate --plan vulnerable_plan.json\n</code></pre> <p>Would produce output similar to:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] sql_injection_detection: Potential SQL injection detected in query (step: step1)\n  SQL query contains string concatenation which is a common indicator of SQL injection vulnerability\n</code></pre>"},{"location":"documentation/examples/#fixed-plan","title":"Fixed Plan","text":"<p>A safer version of the plan would use parameterized queries:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = ?\",\n        \"params\": [username]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#sensitive-data-exposure","title":"Sensitive Data Exposure","text":""},{"location":"documentation/examples/#vulnerable-plan_1","title":"Vulnerable Plan","text":"<p>This plan exposes sensitive data in the logs:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"authenticate\",\n      \"parameters\": {\n        \"username\": \"admin\",\n        \"password\": \"SecretP@ssw0rd\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"log_event\",\n      \"parameters\": {\n        \"message\": \"Authentication attempt with credentials: {{step1.parameters}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#validation-output_1","title":"Validation Output","text":"<pre><code>plan-lint validate --plan sensitive_data_plan.json\n</code></pre> <p>Would produce:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [CRITICAL] sensitive_data_exposure: Step references sensitive data that could be exposed (step: step2)\n  Parameter 'message' contains references to authentication credentials from step 'step1'\n</code></pre>"},{"location":"documentation/examples/#fixed-plan_1","title":"Fixed Plan","text":"<p>A safer version avoids logging sensitive information:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"authenticate\",\n      \"parameters\": {\n        \"username\": \"admin\",\n        \"password\": \"SecretP@ssw0rd\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"log_event\",\n      \"parameters\": {\n        \"message\": \"Authentication attempt for user: {{step1.parameters.username}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#excessive-transaction-amount","title":"Excessive Transaction Amount","text":""},{"location":"documentation/examples/#vulnerable-plan_2","title":"Vulnerable Plan","text":"<p>A plan with an unusually large transaction:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"transfer_funds\",\n      \"parameters\": {\n        \"from_account\": \"12345\",\n        \"to_account\": \"67890\",\n        \"amount\": 1000000\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#validation-with-context","title":"Validation with Context","text":"<pre><code>plan-lint validate --plan transaction_plan.json --context context.json\n</code></pre> <p>Where <code>context.json</code> contains:</p> <pre><code>{\n  \"max_transaction_amount\": 5000,\n  \"user_role\": \"standard\"\n}\n</code></pre> <p>Would produce:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] excessive_transaction_amount: Transaction amount exceeds allowed limit (step: step1)\n  Transaction amount 1000000 exceeds maximum allowed amount of 5000\n</code></pre>"},{"location":"documentation/examples/#fixed-plan_2","title":"Fixed Plan","text":"<p>A compliant version with a reasonable amount:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"transfer_funds\",\n      \"parameters\": {\n        \"from_account\": \"12345\",\n        \"to_account\": \"67890\",\n        \"amount\": 3000\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#custom-policy-example","title":"Custom Policy Example","text":""},{"location":"documentation/examples/#custom-policy","title":"Custom Policy","text":"<p>Create a file named <code>enforce_retry_limit.rego</code>:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect excessive retry attempts\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"retry_operation\"\n    to_number(step.parameters.max_attempts) &gt; 5\n\n    result := {\n        \"rule\": \"excessive_retry_attempts\",\n        \"message\": \"Max retry attempts exceeds the recommended limit\",\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"max_attempts\": step.parameters.max_attempts,\n            \"recommended_limit\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/examples/#plan-to-validate","title":"Plan to Validate","text":"<pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"retry_operation\",\n      \"parameters\": {\n        \"operation\": \"transfer_funds\",\n        \"max_attempts\": 10\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/examples/#validation-command","title":"Validation Command","text":"<pre><code>plan-lint validate --plan retry_plan.json --policies enforce_retry_limit.rego\n</code></pre>"},{"location":"documentation/examples/#validation-output_2","title":"Validation Output","text":"<pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [MEDIUM] excessive_retry_attempts: Max retry attempts exceeds the recommended limit (step: step1)\n  Max attempts: 10, Recommended limit: 5\n</code></pre>"},{"location":"documentation/examples/#programmatic-usage-example","title":"Programmatic Usage Example","text":"<p>Here's a more complex example of using Plan-Lint programmatically to validate plans in an AI agent system:</p> <pre><code>import json\nfrom planlint import validate_plan, load_policies_from_directory\n\n# Load custom policies\ncustom_policies = load_policies_from_directory(\"policies/\")\n\n# Load context from file\nwith open(\"agent_context.json\", \"r\") as f:\n    context = json.load(f)\n\ndef validate_agent_plan(plan, agent_id, user_id):\n    # Add dynamic context information\n    plan_context = context.copy()\n    plan_context[\"agent_id\"] = agent_id\n    plan_context[\"user_id\"] = user_id\n    plan_context[\"timestamp\"] = datetime.now().isoformat()\n\n    # Validate the plan\n    result = validate_plan(\n        plan=plan,\n        policies=custom_policies,\n        context=plan_context\n    )\n\n    # Log the validation results\n    log_validation_result(agent_id, result)\n\n    if not result.is_valid:\n        # Send alert for critical violations\n        critical_violations = [v for v in result.violations if v.severity == \"critical\"]\n        if critical_violations:\n            send_alert(agent_id, critical_violations)\n\n    return result\n\n# In your agent's execution pipeline\nasync def execute_agent_task(task, agent_id, user_id):\n    # Generate plan using LLM\n    plan = await generate_plan(task)\n\n    # Validate plan before execution\n    validation_result = validate_agent_plan(plan, agent_id, user_id)\n\n    if validation_result.is_valid:\n        # Execute the plan\n        result = await execute_plan(plan)\n        return result\n    else:\n        # Handle validation failure\n        return {\n            \"status\": \"error\",\n            \"message\": \"Plan failed validation\",\n            \"violations\": [v.to_dict() for v in validation_result.violations]\n        }\n</code></pre>"},{"location":"documentation/examples/#integration-with-cicd-pipeline","title":"Integration with CI/CD Pipeline","text":"<p>You can add Plan-Lint validation to your CI/CD pipeline to ensure all deployed agent plans meet your security requirements:</p> <pre><code># GitHub Actions workflow example\nname: Validate Agent Plans\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  validate-plans:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n\n      - name: Validate example plans\n        run: |\n          for plan in examples/plans/*.json; do\n            echo \"Validating $plan\"\n            plan-lint validate --plan $plan --policies policies/*.rego\n          done\n\n      - name: Run plan-lint tests\n        run: |\n          plan-lint test --policies policies/*.rego\n</code></pre>"},{"location":"documentation/getting-started/","title":"Getting Started with Plan-Lint","text":"<p>Plan-Lint is a static analysis toolkit that helps validate LLM agent plans before execution. This guide will help you set up and start using Plan-Lint in your projects.</p>"},{"location":"documentation/getting-started/#installation","title":"Installation","text":"<p>Install Plan-Lint using pip:</p> <pre><code>pip install plan-lint\n</code></pre> <p>For the latest development version, you can install directly from GitHub:</p> <pre><code>pip install git+https://github.com/mason-lang/plan-lint.git\n</code></pre>"},{"location":"documentation/getting-started/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of how to validate a plan:</p> <pre><code>from plan_lint import validate_plan\n\n# Define a plan to validate\nplan = {\n    \"steps\": [\n        {\n            \"id\": \"step1\",\n            \"tool\": \"web_request\",\n            \"parameters\": {\n                \"url\": \"http://example.com\",  # Insecure HTTP URL\n                \"method\": \"GET\"\n            }\n        }\n    ]\n}\n\n# Validate the plan using the default security policies\nresult = validate_plan(plan)\n\n# Check the result\nif result.valid:\n    print(\"Plan is valid and safe to execute!\")\nelse:\n    print(\"Plan validation failed:\")\n    for violation in result.violations:\n        print(f\"- {violation.message}\")\n</code></pre>"},{"location":"documentation/getting-started/#integrating-with-llm-agents","title":"Integrating with LLM Agents","text":"<p>You can integrate Plan-Lint directly into your agent system's workflow:</p> <pre><code>from plan_lint import validate_plan\n\ndef agent_workflow(user_input):\n    # Step 1: Generate a plan using your LLM agent\n    plan = generate_plan(user_input)\n\n    # Step 2: Validate the plan before execution\n    validation = validate_plan(plan)\n\n    if validation.valid:\n        # Step 3a: If valid, execute the plan\n        return execute_plan(plan)\n    else:\n        # Step 3b: If invalid, handle the violations\n        return handle_violations(validation.violations)\n</code></pre>"},{"location":"documentation/getting-started/#using-custom-policies","title":"Using Custom Policies","text":"<p>You can specify custom policies to use during validation:</p> <pre><code>from plan_lint import validate_plan\n\n# Path to your custom policy files\ncustom_policies = [\n    \"path/to/custom_security.rego\",\n    \"path/to/custom_data_privacy.rego\"\n]\n\n# Validate with custom policies\nresult = validate_plan(\n    plan,\n    policies=custom_policies\n)\n</code></pre>"},{"location":"documentation/getting-started/#adding-context-information","title":"Adding Context Information","text":"<p>Provide additional context to the validation process:</p> <pre><code>from plan_lint import validate_plan\n\n# Context information that policies can access\ncontext = {\n    \"user_role\": \"regular\",\n    \"environment\": \"production\",\n    \"allowed_domains\": [\"example.com\", \"api.example.org\"]\n}\n\n# Validate with context\nresult = validate_plan(\n    plan,\n    context=context\n)\n</code></pre>"},{"location":"documentation/getting-started/#handling-validation-results","title":"Handling Validation Results","text":"<p>Process validation results programmatically:</p> <pre><code>from plan_lint import validate_plan\n\nresult = validate_plan(plan)\n\nif result.valid:\n    print(\"Plan is valid and safe to execute!\")\nelse:\n    # Group violations by category\n    security_violations = [v for v in result.violations if v.category == \"security\"]\n    privacy_violations = [v for v in result.violations if v.category == \"privacy\"]\n\n    if security_violations:\n        print(\"Security issues found:\")\n        for violation in security_violations:\n            print(f\"- {violation.message}\")\n\n    if privacy_violations:\n        print(\"Privacy issues found:\")\n        for violation in privacy_violations:\n            print(f\"- {violation.message}\")\n</code></pre>"},{"location":"documentation/getting-started/#cli-usage","title":"CLI Usage","text":"<p>Plan-Lint also provides a command-line interface:</p> <pre><code># Validate a plan file against default policies\nplan-lint validate path/to/plan.json\n\n# Validate with custom policies\nplan-lint validate path/to/plan.json --policies path/to/policy1.rego path/to/policy2.rego\n\n# Provide context information\nplan-lint validate path/to/plan.json --context path/to/context.json\n\n# Output format options\nplan-lint validate path/to/plan.json --output json\n</code></pre>"},{"location":"documentation/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Policy Authoring Guide to learn how to write custom policies</li> <li>Explore the API Reference for detailed information about Plan-Lint's functionality</li> <li>Check out the MCP Integration Guide to see how to use Plan-Lint with Multi-agent Collaboration Protocol</li> </ul>"},{"location":"documentation/getting-started/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues with Plan-Lint, check the following:</p> <ol> <li>Ensure your plan structure follows the expected format</li> <li>Verify that any custom policy files are valid Rego code</li> <li>Check that the Open Policy Agent (OPA) dependency is correctly installed</li> </ol> <p>For more help, visit the GitHub repository or submit an issue. </p>"},{"location":"documentation/mcp-integration/","title":"Integrating Plan-Lint with MCP Servers","text":"<p>This guide explains how to integrate plan-lint with Model Context Protocol (MCP) servers to create a comprehensive security architecture that leverages both authentication and behavioral validation.</p>"},{"location":"documentation/mcp-integration/#understanding-the-relationship","title":"Understanding the Relationship","text":"<p>MCP servers and plan-lint serve complementary security functions:</p> Feature MCP OAuth 2.1 Plan-Lint Primary Function Authentication &amp; Authorization Behavior Validation Validates Who can access resources What actions are allowed Security Layer External boundary Internal safety When Applied Before access is granted Before plans execute"},{"location":"documentation/mcp-integration/#security-architecture","title":"Security Architecture","text":"<p>When combined, MCP's OAuth and plan-lint create a defense-in-depth approach:</p> <pre><code>graph LR\n    A[Client Request] --&gt; B[MCP OAuth Authentication]\n    B --&gt;|Authenticated| C[Plan Generation]\n    C --&gt; D[Plan-Lint Validation]\n    D --&gt;|Valid Plan| E[Plan Execution]\n    D --&gt;|Invalid Plan| F[Rejection]\n    B --&gt;|Unauthenticated| G[Auth Error]\n</code></pre>"},{"location":"documentation/mcp-integration/#integration-patterns","title":"Integration Patterns","text":""},{"location":"documentation/mcp-integration/#1-mcp-tool-wrapper-pattern","title":"1. MCP Tool Wrapper Pattern","text":"<p>The most straightforward integration is to wrap each MCP tool with plan-lint validation:</p> <pre><code>from plan_lint.loader import load_policy\nfrom plan_lint.core import validate_plan\nfrom plan_lint.types import Plan\n\nclass PaymentTool:\n    def __init__(self):\n        # Load policy once during initialization\n        self.policy, self.rego_policy = load_policy(\"payment_policy.rego\")\n\n    @mcp_server.tool(\"payments.transfer\")\n    def transfer(self, request):\n        # Extract OAuth context from MCP request\n        oauth_context = request.get_oauth_context()\n\n        # Convert the request to a plan\n        plan = Plan(\n            goal=\"Transfer funds\",\n            context={\n                \"user_id\": oauth_context[\"sub\"], \n                \"role\": oauth_context[\"scope\"].split(\" \")\n            },\n            steps=[\n                {\n                    \"id\": \"transfer-step\",\n                    \"tool\": \"payments.transfer\",\n                    \"args\": request.get_args()\n                }\n            ]\n        )\n\n        # Validate plan\n        result = validate_plan(plan, self.policy, rego_policy=self.rego_policy)\n\n        if not result.valid:\n            return {\n                \"status\": \"error\",\n                \"code\": \"POLICY_VIOLATION\",\n                \"message\": f\"Plan validation failed: {result.errors}\"\n            }\n\n        # Perform the actual transfer if validation passed\n        # ...\n</code></pre>"},{"location":"documentation/mcp-integration/#2-middleware-pattern","title":"2. Middleware Pattern","text":"<p>For MCP servers with middleware support, you can implement plan-lint as a validation layer:</p> <pre><code>class PlanLintMiddleware:\n    def __init__(self, policy_path):\n        self.policy, self.rego_policy = load_policy(policy_path)\n\n    async def __call__(self, request, next):\n        # Skip validation for non-plan requests\n        if not request.is_plan_request():\n            return await next(request)\n\n        # Extract plan from request\n        plan = request.get_plan()\n\n        # Validate plan\n        result = validate_plan(plan, self.policy, rego_policy=self.rego_policy)\n\n        if not result.valid:\n            return MCPResponse(\n                status=403,\n                body={\n                    \"error\": \"Policy Violation\",\n                    \"details\": [str(error) for error in result.errors]\n                }\n            )\n\n        # Continue to the next middleware or handler\n        return await next(request)\n\n# Register middleware with MCP server\nmcp_server.add_middleware(PlanLintMiddleware(\"security_policy.rego\"))\n</code></pre>"},{"location":"documentation/mcp-integration/#3-oauth-aware-rego-policies","title":"3. OAuth-Aware Rego Policies","text":"<p>Create dynamic Rego policies that incorporate OAuth context:</p> <pre><code>package planlint\n\n# Import OAuth scopes into policy evaluation\noauth_scopes := split(input.context.oauth_scopes, \" \")\n\n# Check if user has required scope\nhas_scope(required_scope) {\n    some scope\n    oauth_scopes[scope] == required_scope\n}\n\n# Different rules based on OAuth scopes\nallow_write_operations if {\n    has_scope(\"write:data\")\n}\n\n# Validate SQL based on scopes\ncheck_sql_operation(i) = violation if {\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Extract operation type\n    query := lower(step.args.query)\n    contains(query, \"insert\") \n    contains(query, \"update\")\n    contains(query, \"delete\")\n\n    # Check if write operations are allowed\n    not allow_write_operations\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_SCOPE\",\n        \"msg\": \"Write operations require the write:data scope\"\n    }\n}\n</code></pre>"},{"location":"documentation/mcp-integration/#using-mcp-oauth-tokens-with-plan-lint","title":"Using MCP OAuth Tokens with Plan-Lint","text":"<p>When validating plans in an MCP context, the OAuth token can provide valuable context:</p> <pre><code>def validate_mcp_plan(plan_json, auth_token):\n    # Decode and validate the OAuth token\n    oauth_claims = decode_verify_token(auth_token)\n\n    # Parse the plan\n    plan_data = json.loads(plan_json)\n\n    # Enhance plan context with OAuth information\n    if \"context\" not in plan_data:\n        plan_data[\"context\"] = {}\n\n    # Add OAuth context to plan\n    plan_data[\"context\"].update({\n        \"user_id\": oauth_claims[\"sub\"],\n        \"oauth_scopes\": oauth_claims[\"scope\"],\n        \"oauth_client_id\": oauth_claims[\"client_id\"],\n        \"oauth_issued_at\": oauth_claims[\"iat\"],\n        \"oauth_expires_at\": oauth_claims[\"exp\"]\n    })\n\n    # Create Plan object\n    plan = Plan(**plan_data)\n\n    # Load policy\n    policy, rego_policy = load_policy(\"security_policy.rego\")\n\n    # Validate with context-aware policy\n    result = validate_plan(plan, policy, rego_policy=rego_policy)\n\n    return result\n</code></pre>"},{"location":"documentation/mcp-integration/#example-role-based-security-policy","title":"Example: Role-Based Security Policy","text":"<p>Here's a complete example of a Rego policy that leverages OAuth roles:</p> <pre><code>package planlint\n\ndefault allow = false\ndefault violations = []\ndefault risk_score = 0.0\n\n# Define role-based permissions\nrole_permissions = {\n    \"admin\": {\n        \"max_transaction_amount\": 50000,\n        \"can_query_all_records\": true,\n        \"can_modify_data\": true\n    },\n    \"manager\": {\n        \"max_transaction_amount\": 10000,\n        \"can_query_all_records\": true,\n        \"can_modify_data\": false\n    },\n    \"user\": {\n        \"max_transaction_amount\": 1000,\n        \"can_query_all_records\": false,\n        \"can_modify_data\": false\n    }\n}\n\n# Get role from OAuth context, default to lowest privilege\nuser_role = role {\n    role := input.context.oauth_role\n    role_permissions[role]\n}\n\nuser_role = \"user\" {\n    not input.context.oauth_role\n}\n\nnot_input.context.oauth_role {\n    not input.context.oauth_role\n}\n\n# Allow rule based on violations and risk score\nallow if {\n    count(violations) == 0\n    risk_score &lt; 0.8\n}\n\n# Calculate risk score\nrisk_score = total {\n    total := sum([violation.risk_score | violation = violations[_]])\n}\n\n# Validate transaction amounts based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"payments.transfer\"\n\n    amount := to_number(step.args.amount)\n    max_amount := role_permissions[user_role].max_transaction_amount\n\n    amount &gt; max_amount\n\n    violation := {\n        \"step\": i,\n        \"code\": \"EXCESSIVE_AMOUNT\",\n        \"msg\": sprintf(\"Amount %f exceeds maximum limit %f for role %s\", \n              [amount, max_amount, user_role]),\n        \"risk_score\": 0.7\n    }\n}\n\n# Validate data access based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Check for unrestricted queries\n    query := lower(step.args.query)\n    contains(query, \"select * from users\")\n\n    # Verify permission to query all records\n    not role_permissions[user_role].can_query_all_records\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_PERMISSION\",\n        \"msg\": sprintf(\"Role %s cannot query all user records\", [user_role]),\n        \"risk_score\": 0.6\n    }\n}\n\n# Validate data modification based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Check for data modification operations\n    query := lower(step.args.query)\n    contains(query, \"update \") \n\n    # Verify permission to modify data\n    not role_permissions[user_role].can_modify_data\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_PERMISSION\",\n        \"msg\": sprintf(\"Role %s cannot modify data\", [user_role]),\n        \"risk_score\": 0.8\n    }\n}\n</code></pre>"},{"location":"documentation/mcp-integration/#benefits-of-the-integrated-approach","title":"Benefits of the Integrated Approach","text":"<ol> <li>Defense in Depth: Multiple security layers prevent a single point of failure</li> <li>Contextual Security: Access decisions informed by both identity and behavior</li> <li>Fine-grained Control: Different validation rules for different user roles</li> <li>Audit Trail: Complete record of who did what and whether it was allowed</li> <li>Enhanced Privacy: Sensitive operations can be blocked even for authenticated users</li> </ol>"},{"location":"documentation/mcp-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Always run plan-lint validation after MCP OAuth authentication</li> <li>Pass relevant OAuth context to the plan to inform validation decisions</li> <li>Create role-specific policies that align with your OAuth scope design</li> <li>Use consistent error handling between both systems</li> <li>Log both authentication and validation decisions for complete audit trails</li> <li>Implement comprehensive testing for both authentication and validation layers</li> </ol>"},{"location":"documentation/mcp-integration/#advanced-integration-topics","title":"Advanced Integration Topics","text":"<ul> <li>Setting up OPA Server for Validation</li> <li>CI/CD Pipeline Integration</li> <li>Custom Rule Development </li> </ul>"},{"location":"documentation/plan-structure/","title":"Plan Structure","text":"<p>This page explains the structure of plans that can be validated by Plan-Lint.</p>"},{"location":"documentation/policy-authoring-guide/","title":"Policy Authoring Guide","text":"<p>This guide explains how to write effective policies for Plan-Lint using Rego, the policy language used by the Open Policy Agent (OPA).</p>"},{"location":"documentation/policy-authoring-guide/#introduction-to-rego","title":"Introduction to Rego","text":"<p>Rego is a declarative query language designed for expressing policies. In Plan-Lint, we use Rego to define rules that agent plans must follow before execution is allowed.</p>"},{"location":"documentation/policy-authoring-guide/#basic-rego-concepts","title":"Basic Rego Concepts","text":"<p>A Rego policy consists of:</p> <ul> <li>Package declaration: Defines the namespace for your policy</li> <li>Rules: Logical expressions that evaluate to true or false</li> <li>Functions: Reusable blocks of logic</li> <li>Data references: Ways to access the input document</li> </ul>"},{"location":"documentation/policy-authoring-guide/#creating-your-first-policy","title":"Creating Your First Policy","text":"<p>Let's start with a basic policy that checks if a plan contains sensitive operations:</p> <pre><code>package plan_lint\n\n# Define a rule that flags file deletion operations\nviolation[{\"message\": msg}] {\n    step := input.steps[_]\n    step.tool == \"delete_file\"\n\n    msg := sprintf(\"Plan attempts to delete a file: %v\", [step.parameters.target_file])\n}\n\n# Flag large transactions\nviolation[{\"message\": msg}] {\n    step := input.steps[_]\n    step.tool == \"execute_transaction\"\n    to_number(step.parameters.amount) &gt; 1000\n\n    msg := sprintf(\"Transaction amount exceeds limit: %v\", [step.parameters.amount])\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#input-structure","title":"Input Structure","text":"<p>Plan-Lint passes the plan structure to your policies as the <code>input</code> document. A typical plan structure looks like:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"tool_name\",\n      \"parameters\": {\n        \"param1\": \"value1\",\n        \"param2\": \"value2\"\n      },\n      \"depends_on\": [\"step0\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#common-policy-patterns","title":"Common Policy Patterns","text":""},{"location":"documentation/policy-authoring-guide/#checking-tool-usage","title":"Checking Tool Usage","text":"<p>Restrict which tools can be used:</p> <pre><code>violation[{\"message\": msg}] {\n    step := input.steps[_]\n    forbidden_tools := {\"execute_sql\", \"delete_file\", \"system_command\"}\n    step.tool == forbidden_tools[_]\n\n    msg := sprintf(\"Forbidden tool usage: %v\", [step.tool])\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#parameter-validation","title":"Parameter Validation","text":"<p>Check parameter values for potential issues:</p> <pre><code>violation[{\"message\": msg}] {\n    step := input.steps[_]\n    step.tool == \"execute_sql\"\n    contains(step.parameters.query, \"DROP TABLE\")\n\n    msg := \"SQL query contains potentially dangerous DROP TABLE statement\"\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#dependency-validation","title":"Dependency Validation","text":"<p>Ensure proper step dependencies:</p> <pre><code>violation[{\"message\": msg}] {\n    step := input.steps[_]\n    step.tool == \"commit_transaction\"\n\n    # Check that there's a step that begins the transaction\n    not has_begin_transaction\n\n    msg := \"Transaction committed without being started\"\n}\n\nhas_begin_transaction {\n    some i\n    step := input.steps[i]\n    step.tool == \"begin_transaction\"\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#testing-your-policies","title":"Testing Your Policies","text":"<p>You can test your policies in isolation using the OPA CLI:</p> <pre><code># Save your policy to a file named policy.rego\n# Create a test plan file plan.json\n# Run OPA evaluation\nopa eval -i plan.json -d policy.rego \"data.plan_lint.violation\"\n</code></pre> <p>Alternatively, use Plan-Lint's built-in policy testing:</p> <pre><code>from plan_lint import validate_plan\n\nresult = validate_plan(\n    plan_data,\n    policies=[\"path/to/your/policy.rego\"]\n)\n\nprint(f\"Valid: {result.valid}\")\nfor violation in result.violations:\n    print(f\"Violation: {violation.message}\")\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"documentation/policy-authoring-guide/#using-context-information","title":"Using Context Information","text":"<p>Policies can use external context provided to the validator:</p> <pre><code>violation[{\"message\": msg}] {\n    # Access context variables\n    role := input.context.user_role\n    role != \"admin\"\n\n    # Check for privileged operations\n    step := input.steps[_]\n    privileged_tools := {\"system_command\", \"execute_sql\"}\n    step.tool == privileged_tools[_]\n\n    msg := sprintf(\"User with role '%v' cannot use tool '%v'\", [role, step.tool])\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#pattern-matching-with-regex","title":"Pattern Matching with Regex","text":"<p>Use regex for more flexible matching:</p> <pre><code>violation[{\"message\": msg}] {\n    step := input.steps[_]\n    step.tool == \"web_request\"\n    url := step.parameters.url\n\n    # Check if URL is not HTTPS\n    not regex.match(\"^https://\", url)\n\n    msg := sprintf(\"Insecure URL detected: %v\", [url])\n}\n</code></pre>"},{"location":"documentation/policy-authoring-guide/#best-practices","title":"Best Practices","text":"<ol> <li>Keep policies simple and focused: Each policy should address a specific concern</li> <li>Use meaningful violation messages: Explain why something was flagged</li> <li>Group related rules together: Organize rules by the type of protection they provide</li> <li>Comment your policy code: Explain the rationale behind complex rules</li> <li>Test with both valid and invalid plans: Ensure policies are catching what they should</li> </ol>"},{"location":"documentation/policy-authoring-guide/#example-policy-library","title":"Example Policy Library","text":"<p>Plan-Lint comes with several example policies you can adapt:</p> <ul> <li><code>security.rego</code>: Basic security checks for dangerous operations</li> <li><code>data_privacy.rego</code>: Checks for exposure of PII and sensitive data</li> <li><code>authorization.rego</code>: Role-based access controls</li> </ul> <p>You can find these in the <code>examples/policies</code> directory of the Plan-Lint repository. </p>"},{"location":"documentation/policy-authoring/","title":"Policy Authoring Guide","text":"<p>This guide will help you create custom policies for Plan-Lint using the Rego policy language.</p>"},{"location":"documentation/policy-authoring/#introduction-to-rego","title":"Introduction to Rego","text":"<p>Plan-Lint uses Rego, the policy language of Open Policy Agent (OPA), for defining validation rules. Rego is a declarative language specifically designed for expressing policies over complex data structures.</p>"},{"location":"documentation/policy-authoring/#basic-rego-concepts","title":"Basic Rego Concepts","text":"<ul> <li>Rules: Define conditions that should be met</li> <li>Packages: Group related rules together</li> <li>Imports: Include reusable functions or definitions</li> <li>Variables: Store intermediate values</li> <li>Comprehensions: Create collections by filtering and mapping</li> </ul>"},{"location":"documentation/policy-authoring/#plan-lint-policy-structure","title":"Plan-Lint Policy Structure","text":""},{"location":"documentation/policy-authoring/#package-naming","title":"Package Naming","text":"<p>All Plan-Lint policies should be defined in the <code>planlint.custom</code> package:</p> <pre><code>package planlint.custom\n</code></pre>"},{"location":"documentation/policy-authoring/#basic-policy-format","title":"Basic Policy Format","text":"<p>A typical policy rule follows this pattern:</p> <pre><code>deny[result] {\n    # Rule conditions\n    # ...\n\n    result := {\n        \"rule\": \"rule_name\",\n        \"message\": \"Human-readable message explaining the violation\",\n        \"severity\": \"high\",  # \"low\", \"medium\", \"high\", or \"critical\"\n        \"category\": \"category_name\",  # e.g., \"security\", \"performance\", etc.\n        \"step_id\": \"affected_step_id\",\n        \"metadata\": {\n            # Additional information about the violation\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#available-input-data","title":"Available Input Data","text":"<p>In your policies, you have access to:</p> <ul> <li><code>input.plan</code>: The full plan being validated</li> <li><code>input.context</code>: Additional context data provided during validation</li> </ul>"},{"location":"documentation/policy-authoring/#writing-your-first-policy","title":"Writing Your First Policy","text":"<p>Let's create a simple policy that detects file operations on sensitive paths:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Define sensitive paths\nsensitive_paths := [\"/etc/passwd\", \"/etc/shadow\", \"/var/log/auth.log\"]\n\n# Check if a file operation targets a sensitive path\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"file_operation\"\n\n    some path in sensitive_paths\n    startswith(step.parameters.path, path)\n\n    result := {\n        \"rule\": \"sensitive_path_access\",\n        \"message\": \"Operation attempts to access a sensitive system path\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"path\": step.parameters.path,\n            \"operation\": step.parameters.operation\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#advanced-policy-techniques","title":"Advanced Policy Techniques","text":""},{"location":"documentation/policy-authoring/#using-context-data","title":"Using Context Data","text":"<p>You can leverage context data to create more dynamic policies:</p> <pre><code>package planlint.custom\n\n# Check if a requested permission exceeds user's role\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"request_permission\"\n\n    # Get user role from context\n    user_role := input.context.user_role\n\n    # Define allowed permissions per role\n    allowed_permissions := {\n        \"user\": [\"read\"],\n        \"editor\": [\"read\", \"write\"],\n        \"admin\": [\"read\", \"write\", \"delete\", \"configure\"]\n    }\n\n    # Check if requested permission is allowed for this role\n    not step.parameters.permission in allowed_permissions[user_role]\n\n    result := {\n        \"rule\": \"permission_exceeds_role\",\n        \"message\": sprintf(\"User with role '%s' cannot request '%s' permission\", [user_role, step.parameters.permission]),\n        \"severity\": \"medium\",\n        \"category\": \"access_control\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"requested_permission\": step.parameters.permission,\n            \"user_role\": user_role,\n            \"allowed_permissions\": allowed_permissions[user_role]\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#step-dependencies-analysis","title":"Step Dependencies Analysis","text":"<p>You can analyze dependencies between steps:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect when sensitive data is passed to network operations\ndeny[result] {\n    # Find an authentication step\n    some auth_step in input.plan.steps\n    auth_step.tool == \"authenticate\"\n\n    # Find a network request step\n    some request_step in input.plan.steps\n    request_step.tool == \"http_request\"\n\n    # Check if auth data is referenced in request\n    contains(request_step.parameters.url, sprintf(\"{{%s.result}}\", [auth_step.id]))\n\n    result := {\n        \"rule\": \"auth_data_in_url\",\n        \"message\": \"Authentication data should not be included in URLs\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": request_step.id,\n        \"metadata\": {\n            \"auth_step\": auth_step.id,\n            \"url_parameter\": request_step.parameters.url\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#using-rego-built-in-functions","title":"Using Rego Built-in Functions","text":"<p>Rego provides many built-in functions for processing data:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Check for excessively large array operations\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"process_array\"\n\n    # Convert to number if string\n    array_size := to_number(step.parameters.size)\n\n    # Check if exceeds threshold\n    max_size := 10000\n    array_size &gt; max_size\n\n    result := {\n        \"rule\": \"large_array_operation\",\n        \"message\": \"Processing very large arrays can cause performance issues\",\n        \"severity\": \"medium\",\n        \"category\": \"performance\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"array_size\": array_size,\n            \"max_recommended_size\": max_size\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#pattern-matching-and-string-operations","title":"Pattern Matching and String Operations","text":"<p>Use pattern matching for detecting issues in string parameters:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect potential XSS vulnerabilities\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"render_html\"\n\n    # Look for common XSS patterns\n    dangerous_patterns := [\n        \"&lt;script&gt;\", \n        \"javascript:\", \n        \"onerror=\", \n        \"onload=\"\n    ]\n\n    some pattern in dangerous_patterns\n    contains(lower(step.parameters.content), pattern)\n\n    result := {\n        \"rule\": \"potential_xss\",\n        \"message\": \"HTML content contains potentially dangerous scripts\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"detected_pattern\": pattern\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#testing-your-policies","title":"Testing Your Policies","text":"<p>It's important to test policies with both valid and invalid plans:</p> <pre><code>package planlint.test\n\nimport data.planlint.custom\n\n# Test case for sensitive path access policy\ntest_sensitive_path_access {\n    # Define test plan with violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/etc/passwd\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that a violation was detected\n    count(violations) == 1\n    violations[_].rule == \"sensitive_path_access\"\n}\n\n# Test case for safe path\ntest_safe_path {\n    # Define test plan without violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/tmp/safe_file.txt\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that no violations were detected\n    count(violations) == 0\n}\n</code></pre> <p>To run these tests:</p> <pre><code>plan-lint test --policies your_policy.rego\n</code></pre>"},{"location":"documentation/policy-authoring/#organizing-multiple-policies","title":"Organizing Multiple Policies","text":"<p>For larger projects, organize policies into themes:</p> <pre><code>policies/\n  \u251c\u2500\u2500 security/\n  \u2502   \u251c\u2500\u2500 injection.rego\n  \u2502   \u251c\u2500\u2500 access_control.rego\n  \u2502   \u2514\u2500\u2500 data_exposure.rego\n  \u251c\u2500\u2500 performance/\n  \u2502   \u251c\u2500\u2500 resource_limits.rego\n  \u2502   \u2514\u2500\u2500 efficiency.rego\n  \u2514\u2500\u2500 reliability/\n      \u251c\u2500\u2500 error_handling.rego\n      \u2514\u2500\u2500 retries.rego\n</code></pre>"},{"location":"documentation/policy-authoring/#common-patterns-for-plan-lint-policies","title":"Common Patterns for Plan-Lint Policies","text":""},{"location":"documentation/policy-authoring/#detecting-dangerous-operations","title":"Detecting Dangerous Operations","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# List of dangerous system commands\ndangerous_commands := [\n    \"rm -rf\", \n    \"dd if=\", \n    \"mkfs\", \n    \"&gt; /dev/\",\n    \":(){ :|:&amp; };:\"  # Fork bomb\n]\n\n# Detect dangerous system commands\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"execute_command\"\n\n    some cmd in dangerous_commands\n    contains(step.parameters.command, cmd)\n\n    result := {\n        \"rule\": \"dangerous_system_command\",\n        \"message\": \"Plan contains a potentially destructive system command\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"command\": step.parameters.command,\n            \"detected_pattern\": cmd\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#enforcing-tool-constraints","title":"Enforcing Tool Constraints","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Limit the number of API calls in a plan\ndeny[result] {\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n    count(api_steps) &gt; 5\n\n    result := {\n        \"rule\": \"too_many_api_calls\",\n        \"message\": \"Plan contains too many API calls which may lead to rate limiting\",\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": api_steps[0].id,  # Reference the first API call\n        \"metadata\": {\n            \"api_call_count\": count(api_steps),\n            \"max_recommended\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#contextual-validation","title":"Contextual Validation","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Validate operations based on business hours\ndeny[result] {\n    # Only apply this rule if business_hours context is provided\n    input.context.business_hours\n\n    some step in input.plan.steps\n    step.tool == \"schedule_maintenance\"\n\n    # Convert maintenance time to number for comparison\n    maintenance_hour := to_number(step.parameters.hour)\n\n    # Check if maintenance is scheduled during business hours\n    maintenance_hour &gt;= input.context.business_hours.start\n    maintenance_hour &lt; input.context.business_hours.end\n\n    result := {\n        \"rule\": \"maintenance_during_business_hours\",\n        \"message\": \"Maintenance should be scheduled outside of business hours\",\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"scheduled_hour\": maintenance_hour,\n            \"business_hours\": sprintf(\"%d-%d\", [input.context.business_hours.start, input.context.business_hours.end])\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#best-practices","title":"Best Practices","text":"<ol> <li>Be Specific: Target policies to specific tools or operations</li> <li>Use Severity Levels Consistently: Follow these guidelines:</li> <li><code>critical</code>: Issues that must be fixed immediately</li> <li><code>high</code>: Significant security or reliability concerns</li> <li><code>medium</code>: Important but not critical issues</li> <li><code>low</code>: Minor concerns or best practice suggestions</li> <li>Include Helpful Messages: Make policy violation messages actionable and clear</li> <li>Add Metadata: Include relevant data to help developers understand and fix issues</li> <li>Test Thoroughly: Create test cases for both compliant and non-compliant plans</li> <li>Consider Performance: Complex policies might slow down validation; optimize when necessary</li> </ol>"},{"location":"documentation/policy-authoring/#debugging-policies","title":"Debugging Policies","text":"<p>When your policy isn't working as expected:</p> <ol> <li> <p>Use the <code>--debug</code> flag when running <code>plan-lint</code>:    <pre><code>plan-lint validate --plan my_plan.json --policies my_policy.rego --debug\n</code></pre></p> </li> <li> <p>Add print statements for debugging:    <pre><code>deny[result] {\n    # ...\n    print(\"Checking step:\", step.id)\n    print(\"Parameter value:\", step.parameters.value)\n    # ...\n}\n</code></pre></p> </li> <li> <p>Break down complex policies into smaller ones to isolate issues</p> </li> </ol>"},{"location":"documentation/policy-authoring/#policy-version-control","title":"Policy Version Control","text":"<p>For maintainable policies:</p> <ol> <li> <p>Add headers with version and author information:    <pre><code># Policy: prevent_sensitive_data_exposure\n# Version: 1.2\n# Author: Security Team\n# Last Updated: 2023-10-15\n# Description: Prevents exposure of sensitive data in logs and external services\npackage planlint.custom\n</code></pre></p> </li> <li> <p>Add comments explaining the rationale behind policy decisions</p> </li> <li> <p>Consider using meaningful file names that describe the policy's purpose</p> </li> </ol>"},{"location":"documentation/policy-authoring/#example-rate-limiting-policy","title":"Example: Rate Limiting Policy","text":"<p>Complete policy example for enforcing API rate limits:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Rate limiting policy for API calls\n# Checks that the same API endpoint isn't called too frequently within a plan\n\n# Configuration\ndefault max_calls_per_endpoint = 3\n\n# Get customized limit from context if available\nmax_calls_per_endpoint = limit {\n    limit := input.context.api_rate_limits.max_calls_per_endpoint\n}\n\n# Group API calls by endpoint\napi_calls_by_endpoint[endpoint] = calls {\n    # Collect all API call steps\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n\n    # Group by endpoint\n    endpoints := {endpoint | some step in api_steps; endpoint := step.parameters.endpoint}\n\n    # For each endpoint, collect all steps that call it\n    some endpoint in endpoints\n    calls := [step | some step in api_steps; step.parameters.endpoint == endpoint]\n}\n\n# Detect rate limit violations\ndeny[result] {\n    some endpoint, calls in api_calls_by_endpoint\n    count(calls) &gt; max_calls_per_endpoint\n\n    result := {\n        \"rule\": \"api_rate_limit_exceeded\",\n        \"message\": sprintf(\"Too many calls to API endpoint '%s'\", [endpoint]),\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": calls[0].id,  # Reference the first call to this endpoint\n        \"metadata\": {\n            \"endpoint\": endpoint,\n            \"call_count\": count(calls),\n            \"max_allowed\": max_calls_per_endpoint,\n            \"all_calls\": [step.id | some step in calls]\n        }\n    }\n}\n</code></pre>"},{"location":"documentation/policy-authoring/#conclusion","title":"Conclusion","text":"<p>Creating effective policies is an iterative process. Start with simple rules and gradually build more complex validation logic as your understanding of potential issues grows. Remember that policies should balance security with usability - overly strict policies might frustrate users and lead to workarounds.</p> <p>For more examples and inspiration, check out the default policies included with Plan-Lint and the examples in the Plan-Lint documentation. </p>"},{"location":"documentation/policy-formats/","title":"Policy Formats","text":"<p>This page explains the different formats supported by Plan-Lint for defining policies.</p>"},{"location":"documentation/risk-scoring/","title":"Risk Scoring","text":"<p>This page explains how Plan-Lint calculates risk scores for plans.</p>"},{"location":"documentation/rule-types/","title":"Rule Types","text":"<p>This page describes the different types of rules available in Plan-Lint.</p>"},{"location":"documentation/user-guide/","title":"User Guide","text":"<p>This guide provides detailed instructions on how to use Plan-Lint to validate AI agent plans against security policies.</p>"},{"location":"documentation/user-guide/#installation","title":"Installation","text":"<p>Install Plan-Lint using pip:</p> <pre><code>pip install plan-lint\n</code></pre> <p>For development installation:</p> <pre><code>git clone https://github.com/masonlogan-dev/plan-lint.git\ncd plan-lint\npip install -e .\n</code></pre>"},{"location":"documentation/user-guide/#basic-usage","title":"Basic Usage","text":""},{"location":"documentation/user-guide/#command-line-interface","title":"Command Line Interface","text":"<p>Plan-Lint provides a simple CLI for validating plans:</p> <pre><code>plan-lint validate --plan path/to/plan.json\n</code></pre> <p>This will validate the plan against default policies and output any violations found.</p>"},{"location":"documentation/user-guide/#python-api","title":"Python API","text":"<p>You can also use Plan-Lint programmatically in your Python applications:</p> <pre><code>from planlint import validate_plan\n\nplan = {\n    \"steps\": [\n        {\n            \"id\": \"step1\",\n            \"tool\": \"execute_query\",\n            \"parameters\": {\n                \"query\": \"SELECT * FROM users\"\n            }\n        }\n    ]\n}\n\nresult = validate_plan(plan)\n\nif result.is_valid:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Found {len(result.violations)} violations:\")\n    for violation in result.violations:\n        print(f\"- {violation.rule}: {violation.message} (Severity: {violation.severity})\")\n</code></pre>"},{"location":"documentation/user-guide/#validating-plans","title":"Validating Plans","text":""},{"location":"documentation/user-guide/#plan-format","title":"Plan Format","text":"<p>Plan-Lint expects plans in the following JSON format:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"tool_name\",\n      \"parameters\": {\n        \"param1\": \"value1\",\n        \"param2\": \"value2\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"another_tool\",\n      \"parameters\": {\n        \"param1\": \"value1\"\n      }\n    }\n  ]\n}\n</code></pre> <p>Each step must have: - A unique <code>id</code> - A <code>tool</code> name - A <code>parameters</code> object containing the tool's parameters</p>"},{"location":"documentation/user-guide/#cli-options","title":"CLI Options","text":"<p>The <code>validate</code> command provides several options:</p> <pre><code>plan-lint validate --plan path/to/plan.json [OPTIONS]\n</code></pre> <p>Options: - <code>--policies</code>: Path to custom policy files (can be specified multiple times) - <code>--context</code>: Path to a JSON file with additional context for policy evaluation - <code>--output-format</code>: Format of the output (json, yaml, or text, default: text) - <code>--config</code>: Path to a configuration file</p> <p>Example:</p> <pre><code>plan-lint validate --plan plan.json --policies custom_policy.rego --context context.json --output-format json\n</code></pre>"},{"location":"documentation/user-guide/#configuration-file","title":"Configuration File","text":"<p>You can provide a configuration file to customize Plan-Lint's behavior:</p> <pre><code># plan-lint.yaml\npolicies:\n  - path/to/policy1.rego\n  - path/to/policy2.rego\npolicy_directories:\n  - path/to/policy_dir\ncontext_file: path/to/context.json\noutput_format: yaml\n</code></pre> <p>Then use it with:</p> <pre><code>plan-lint validate --plan plan.json --config plan-lint.yaml\n</code></pre>"},{"location":"documentation/user-guide/#working-with-policies","title":"Working with Policies","text":""},{"location":"documentation/user-guide/#default-policies","title":"Default Policies","text":"<p>Plan-Lint comes with built-in policies that check for common security issues:</p> <ol> <li>SQL Injection Detection: Identifies potential SQL injection vulnerabilities</li> <li>Sensitive Data Exposure: Detects exposure of sensitive information like passwords and API keys</li> <li>Excessive Transaction Amounts: Flags transactions with unusually high amounts</li> <li>Unauthorized Admin Operations: Identifies operations that require administrative privileges</li> <li>Dangerous Code Execution: Detects potentially harmful code execution patterns</li> </ol> <p>To use only specific default policies:</p> <pre><code>plan-lint validate --plan plan.json --use-default-policies sql_injection,sensitive_data\n</code></pre>"},{"location":"documentation/user-guide/#custom-policies","title":"Custom Policies","text":"<p>You can create custom policies to meet your specific security and compliance requirements. Policies are written in Rego, the policy language used by Open Policy Agent.</p> <p>To use custom policies:</p> <pre><code>plan-lint validate --plan plan.json --policies custom_policy1.rego custom_policy2.rego\n</code></pre> <p>For details on writing custom policies, see the Policy Authoring Guide.</p>"},{"location":"documentation/user-guide/#policy-directories","title":"Policy Directories","text":"<p>You can also specify directories containing policy files:</p> <pre><code>plan-lint validate --plan plan.json --policy-directories path/to/policies\n</code></pre>"},{"location":"documentation/user-guide/#providing-context","title":"Providing Context","text":"<p>Policies may need additional context information to properly evaluate a plan. You can provide this context as a JSON file:</p> <pre><code>{\n  \"user_role\": \"admin\",\n  \"environment\": \"production\",\n  \"is_maintenance_window\": true,\n  \"max_transaction_amount\": 5000\n}\n</code></pre> <p>Use it with:</p> <pre><code>plan-lint validate --plan plan.json --context context.json\n</code></pre> <p>or programmatically:</p> <pre><code>from planlint import validate_plan, load_context\n\nplan = {...}  # Your plan\ncontext = load_context(\"context.json\")\n\nresult = validate_plan(plan, context=context)\n</code></pre>"},{"location":"documentation/user-guide/#understanding-results","title":"Understanding Results","text":""},{"location":"documentation/user-guide/#validation-result-structure","title":"Validation Result Structure","text":"<p>The validation result includes:</p> <ul> <li>Whether the plan is valid (<code>is_valid</code>)</li> <li>A list of policy violations found</li> <li>A summary of the validation</li> </ul> <p>Each violation includes:</p> <ul> <li>The rule identifier</li> <li>A human-readable message explaining the issue</li> <li>The severity level (low, medium, high, critical)</li> <li>The category of the violation (security, privacy, etc.)</li> <li>The ID of the step that caused the violation</li> <li>Additional metadata specific to the violation</li> </ul>"},{"location":"documentation/user-guide/#output-formats","title":"Output Formats","text":"<p>Plan-Lint supports multiple output formats:</p>"},{"location":"documentation/user-guide/#text-default","title":"Text (Default)","text":"<pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] sql_injection_detection: Potential SQL injection detected in query (step: step1)\n  SQL query: SELECT * FROM users WHERE username = 'admin' OR '1'='1'\n</code></pre>"},{"location":"documentation/user-guide/#json","title":"JSON","text":"<pre><code>{\n  \"is_valid\": false,\n  \"violations\": [\n    {\n      \"rule\": \"sql_injection_detection\",\n      \"message\": \"Potential SQL injection detected in query\",\n      \"severity\": \"high\",\n      \"category\": \"security\",\n      \"step_id\": \"step1\",\n      \"metadata\": {\n        \"query\": \"SELECT * FROM users WHERE username = 'admin' OR '1'='1'\"\n      }\n    }\n  ],\n  \"summary\": \"Plan validation failed with 1 violation\"\n}\n</code></pre>"},{"location":"documentation/user-guide/#yaml","title":"YAML","text":"<pre><code>is_valid: false\nviolations:\n  - rule: sql_injection_detection\n    message: Potential SQL injection detected in query\n    severity: high\n    category: security\n    step_id: step1\n    metadata:\n      query: SELECT * FROM users WHERE username = 'admin' OR '1'='1'\nsummary: Plan validation failed with 1 violation\n</code></pre>"},{"location":"documentation/user-guide/#integration-examples","title":"Integration Examples","text":""},{"location":"documentation/user-guide/#integration-with-langchain","title":"Integration with LangChain","text":"<pre><code>from langchain.chains import LLMChain\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\nfrom planlint import validate_plan\n\nllm = OpenAI(temperature=0)\nprompt = PromptTemplate(\n    input_variables=[\"task\"],\n    template=\"Generate a plan to {task}. Format as JSON with steps.\"\n)\n\nchain = LLMChain(llm=llm, prompt=prompt)\n\n# Generate a plan\nresponse = chain.run(task=\"transfer money from account A to account B\")\nplan = json.loads(response)\n\n# Validate the plan\nresult = validate_plan(plan)\n\nif not result.is_valid:\n    print(\"The generated plan has security issues:\")\n    for violation in result.violations:\n        print(f\"- {violation.message}\")\n    # Handle violations (e.g., regenerate or modify the plan)\nelse:\n    # Execute the validated plan\n    execute_plan(plan)\n</code></pre>"},{"location":"documentation/user-guide/#integration-with-fastapi","title":"Integration with FastAPI","text":"<pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List, Dict, Any\nfrom planlint import validate_plan\n\napp = FastAPI()\n\nclass Step(BaseModel):\n    id: str\n    tool: str\n    parameters: Dict[str, Any]\n\nclass Plan(BaseModel):\n    steps: List[Step]\n\n@app.post(\"/validate-plan\")\nasync def validate_plan_endpoint(plan: Plan):\n    result = validate_plan(plan.dict())\n\n    if not result.is_valid:\n        return {\n            \"valid\": False,\n            \"violations\": [v.to_dict() for v in result.violations],\n            \"message\": \"Plan validation failed\"\n        }\n\n    return {\n        \"valid\": True,\n        \"message\": \"Plan validation successful\"\n    }\n</code></pre>"},{"location":"documentation/user-guide/#testing-policies","title":"Testing Policies","text":"<p>Plan-Lint includes a test command to verify your custom policies:</p> <pre><code>plan-lint test --policies path/to/policy.rego\n</code></pre> <p>This will run any test cases defined in the policy file or associated test files.</p> <p>For verbose output:</p> <pre><code>plan-lint test --policies path/to/policy.rego --verbose\n</code></pre>"},{"location":"documentation/user-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"documentation/user-guide/#common-issues","title":"Common Issues","text":"<ol> <li>Policy syntax errors: </li> <li>Error: <code>Error loading policy: rego_parse_error</code></li> <li> <p>Solution: Check your Rego syntax and ensure all brackets, braces, and parentheses are balanced.</p> </li> <li> <p>Invalid plan format:</p> </li> <li>Error: <code>Error: Plan must have a 'steps' field that is an array</code></li> <li> <p>Solution: Ensure your plan follows the expected format with a 'steps' array.</p> </li> <li> <p>Missing context data:</p> </li> <li>Error: <code>Error evaluating policy: undefined field context</code></li> <li> <p>Solution: Provide the required context information for your policies.</p> </li> <li> <p>Policy not working as expected:</p> </li> <li>Solution: Use the <code>--verbose</code> flag to see detailed evaluation information, which can help identify why a policy isn't catching violations.</li> </ol>"},{"location":"documentation/user-guide/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered in this guide:</p> <ol> <li>Check the GitHub repository for known issues</li> <li>Open a new issue with details about your problem and steps to reproduce it</li> </ol>"},{"location":"documentation/user-guide/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"documentation/user-guide/#environment-variables","title":"Environment Variables","text":"<p>Plan-Lint supports the following environment variables:</p> <ul> <li><code>PLANLINT_POLICY_DIRS</code>: Colon-separated list of policy directories</li> <li><code>PLANLINT_DEFAULT_POLICIES</code>: Comma-separated list of default policies to use</li> <li><code>PLANLINT_OUTPUT_FORMAT</code>: Default output format (text, json, yaml)</li> </ul> <p>Example:</p> <pre><code>export PLANLINT_POLICY_DIRS=/path/to/policies:/another/path\nexport PLANLINT_DEFAULT_POLICIES=sql_injection,excessive_amount\nexport PLANLINT_OUTPUT_FORMAT=json\n\nplan-lint validate --plan plan.json\n</code></pre>"},{"location":"documentation/user-guide/#ignoring-rules","title":"Ignoring Rules","text":"<p>You can ignore specific rules in your plan by adding metadata to steps:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"execute_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users\"\n      },\n      \"metadata\": {\n        \"planlint\": {\n          \"ignore_rules\": [\"sql_injection_detection\"]\n        }\n      }\n    }\n  ]\n}\n</code></pre> <p>This tells Plan-Lint not to flag this step for the specified rules. </p>"},{"location":"examples/","title":"Examples Overview","text":"<p>This section provides practical examples of using Plan-Lint to validate AI agent plans.</p>"},{"location":"examples/custom-rules/","title":"Plan-Lint Examples","text":"<p>This page provides practical examples of using Plan-Lint to validate AI agent plans.</p>"},{"location":"examples/custom-rules/#basic-example","title":"Basic Example","text":""},{"location":"examples/custom-rules/#sample-plan","title":"Sample Plan","text":"<p>Let's start with a simple plan that performs a database query and sends an email:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM customers WHERE id = 123\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"send_email\",\n      \"parameters\": {\n        \"to\": \"user@example.com\",\n        \"subject\": \"Your Account Information\",\n        \"body\": \"Here is your requested information: {{step1.result}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#validation-with-default-policies","title":"Validation with Default Policies","text":"<p>To validate this plan with default policies:</p> <pre><code>plan-lint validate --plan example_plan.json\n</code></pre> <p>This will check for potential issues such as SQL injection vulnerabilities and sensitive data exposure.</p>"},{"location":"examples/custom-rules/#sql-injection-detection","title":"SQL Injection Detection","text":""},{"location":"examples/custom-rules/#vulnerable-plan","title":"Vulnerable Plan","text":"<p>Consider a plan with a potential SQL injection vulnerability:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = '\" + username + \"'\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#validation-output","title":"Validation Output","text":"<p>Running Plan-Lint on this vulnerable plan:</p> <pre><code>plan-lint validate --plan vulnerable_plan.json\n</code></pre> <p>Would produce output similar to:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] sql_injection_detection: Potential SQL injection detected in query (step: step1)\n  SQL query contains string concatenation which is a common indicator of SQL injection vulnerability\n</code></pre>"},{"location":"examples/custom-rules/#fixed-plan","title":"Fixed Plan","text":"<p>A safer version of the plan would use parameterized queries:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"database_query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = ?\",\n        \"params\": [username]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#sensitive-data-exposure","title":"Sensitive Data Exposure","text":""},{"location":"examples/custom-rules/#vulnerable-plan_1","title":"Vulnerable Plan","text":"<p>This plan exposes sensitive data in the logs:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"authenticate\",\n      \"parameters\": {\n        \"username\": \"admin\",\n        \"password\": \"SecretP@ssw0rd\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"log_event\",\n      \"parameters\": {\n        \"message\": \"Authentication attempt with credentials: {{step1.parameters}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#validation-output_1","title":"Validation Output","text":"<pre><code>plan-lint validate --plan sensitive_data_plan.json\n</code></pre> <p>Would produce:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [CRITICAL] sensitive_data_exposure: Step references sensitive data that could be exposed (step: step2)\n  Parameter 'message' contains references to authentication credentials from step 'step1'\n</code></pre>"},{"location":"examples/custom-rules/#fixed-plan_1","title":"Fixed Plan","text":"<p>A safer version avoids logging sensitive information:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"authenticate\",\n      \"parameters\": {\n        \"username\": \"admin\",\n        \"password\": \"SecretP@ssw0rd\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"log_event\",\n      \"parameters\": {\n        \"message\": \"Authentication attempt for user: {{step1.parameters.username}}\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#excessive-transaction-amount","title":"Excessive Transaction Amount","text":""},{"location":"examples/custom-rules/#vulnerable-plan_2","title":"Vulnerable Plan","text":"<p>A plan with an unusually large transaction:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"transfer_funds\",\n      \"parameters\": {\n        \"from_account\": \"12345\",\n        \"to_account\": \"67890\",\n        \"amount\": 1000000\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#validation-with-context","title":"Validation with Context","text":"<pre><code>plan-lint validate --plan transaction_plan.json --context context.json\n</code></pre> <p>Where <code>context.json</code> contains:</p> <pre><code>{\n  \"max_transaction_amount\": 5000,\n  \"user_role\": \"standard\"\n}\n</code></pre> <p>Would produce:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] excessive_transaction_amount: Transaction amount exceeds allowed limit (step: step1)\n  Transaction amount 1000000 exceeds maximum allowed amount of 5000\n</code></pre>"},{"location":"examples/custom-rules/#fixed-plan_2","title":"Fixed Plan","text":"<p>A compliant version with a reasonable amount:</p> <pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"transfer_funds\",\n      \"parameters\": {\n        \"from_account\": \"12345\",\n        \"to_account\": \"67890\",\n        \"amount\": 3000\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#custom-policy-example","title":"Custom Policy Example","text":""},{"location":"examples/custom-rules/#custom-policy","title":"Custom Policy","text":"<p>Create a file named <code>enforce_retry_limit.rego</code>:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect excessive retry attempts\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"retry_operation\"\n    to_number(step.parameters.max_attempts) &gt; 5\n\n    result := {\n        \"rule\": \"excessive_retry_attempts\",\n        \"message\": \"Max retry attempts exceeds the recommended limit\",\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"max_attempts\": step.parameters.max_attempts,\n            \"recommended_limit\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"examples/custom-rules/#plan-to-validate","title":"Plan to Validate","text":"<pre><code>{\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"retry_operation\",\n      \"parameters\": {\n        \"operation\": \"transfer_funds\",\n        \"max_attempts\": 10\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/custom-rules/#validation-command","title":"Validation Command","text":"<pre><code>plan-lint validate --plan retry_plan.json --policies enforce_retry_limit.rego\n</code></pre>"},{"location":"examples/custom-rules/#validation-output_2","title":"Validation Output","text":"<pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [MEDIUM] excessive_retry_attempts: Max retry attempts exceeds the recommended limit (step: step1)\n  Max attempts: 10, Recommended limit: 5\n</code></pre>"},{"location":"examples/custom-rules/#programmatic-usage-example","title":"Programmatic Usage Example","text":"<p>Here's a more complex example of using Plan-Lint programmatically to validate plans in an AI agent system:</p> <pre><code>import json\nfrom planlint import validate_plan, load_policies_from_directory\n\n# Load custom policies\ncustom_policies = load_policies_from_directory(\"policies/\")\n\n# Load context from file\nwith open(\"agent_context.json\", \"r\") as f:\n    context = json.load(f)\n\ndef validate_agent_plan(plan, agent_id, user_id):\n    # Add dynamic context information\n    plan_context = context.copy()\n    plan_context[\"agent_id\"] = agent_id\n    plan_context[\"user_id\"] = user_id\n    plan_context[\"timestamp\"] = datetime.now().isoformat()\n\n    # Validate the plan\n    result = validate_plan(\n        plan=plan,\n        policies=custom_policies,\n        context=plan_context\n    )\n\n    # Log the validation results\n    log_validation_result(agent_id, result)\n\n    if not result.is_valid:\n        # Send alert for critical violations\n        critical_violations = [v for v in result.violations if v.severity == \"critical\"]\n        if critical_violations:\n            send_alert(agent_id, critical_violations)\n\n    return result\n\n# In your agent's execution pipeline\nasync def execute_agent_task(task, agent_id, user_id):\n    # Generate plan using LLM\n    plan = await generate_plan(task)\n\n    # Validate plan before execution\n    validation_result = validate_agent_plan(plan, agent_id, user_id)\n\n    if validation_result.is_valid:\n        # Execute the plan\n        result = await execute_plan(plan)\n        return result\n    else:\n        # Handle validation failure\n        return {\n            \"status\": \"error\",\n            \"message\": \"Plan failed validation\",\n            \"violations\": [v.to_dict() for v in validation_result.violations]\n        }\n</code></pre>"},{"location":"examples/custom-rules/#integration-with-cicd-pipeline","title":"Integration with CI/CD Pipeline","text":"<p>You can add Plan-Lint validation to your CI/CD pipeline to ensure all deployed agent plans meet your security requirements:</p> <pre><code># GitHub Actions workflow example\nname: Validate Agent Plans\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  validate-plans:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n\n      - name: Validate example plans\n        run: |\n          for plan in examples/plans/*.json; do\n            echo \"Validating $plan\"\n            plan-lint validate --plan $plan --policies policies/*.rego\n          done\n\n      - name: Run plan-lint tests\n        run: |\n          plan-lint test --policies policies/*.rego\n</code></pre>"},{"location":"examples/finance-agent-system/","title":"Finance Agent System","text":"<p>This example demonstrates using Plan-Lint to validate financial transaction plans.</p>"},{"location":"examples/sql-injection/","title":"SQL Injection Prevention","text":"<p>This example shows how Plan-Lint can detect and prevent SQL injection vulnerabilities.</p>"}]}