{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plan-Lint SDK","text":"<ul> <li> <p> Validate LLM Agent Plans</p> <p>Static analysis toolkit for checking and validating agent plans before they execute.</p> <p> Getting started</p> </li> <li> <p> Policy Authoring</p> <p>Learn to write Rego policies that define security boundaries for your agents.</p> <p> Policy guide</p> </li> <li> <p> MCP Integration</p> <p>Integrate plan-lint with MCP servers for enhanced security.</p> <p> MCP Integration</p> </li> <li> <p> API Reference</p> <p>Comprehensive API documentation for plan-lint.</p> <p> API Reference</p> </li> </ul>"},{"location":"#what-is-plan-lint","title":"What is Plan-Lint?","text":"<p>Plan-Lint is a static analysis toolkit for validating LLM agent plans before execution. It provides a robust security layer that can prevent harmful actions, detect suspicious patterns, and enforce authorization policies - all before any code executes.</p> <pre><code>from plan_lint import validate_plan\n\n# Your agent generates a plan\nplan = agent.generate_plan(user_query)\n\n# Validate the plan against your policies\nvalidation_result = validate_plan(plan, policies=[\"policies/security.rego\"])\n\nif validation_result.valid:\n    # Execute the plan only if it passed validation\n    agent.execute_plan(plan)\nelse:\n    # Handle validation failure\n    print(f\"Plan validation failed: {validation_result.violations}\")\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plan-lint\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from plan_lint import validate_plan\n\n# Validate a plan against security policies\nresult = validate_plan(\n    plan_data,\n    policies=[\"path/to/policies/security.rego\"]\n)\n\nif result.valid:\n    print(\"Plan is valid\")\nelse:\n    print(f\"Plan validation failed with {len(result.violations)} violations:\")\n    for violation in result.violations:\n        print(f\" - {violation.message}\")\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Static Analysis: Validate plans before execution to prevent security issues</li> <li>Rego Policies: Use OPA's Rego language to define flexible, powerful policies</li> <li>Integration: Works with OpenAI, Anthropic, and custom agent frameworks</li> <li>MCP Support: Integrates with MCP servers for OAuth-aware policy enforcement</li> <li>Custom Rules: Define your own security policies based on your specific needs</li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>Check out our examples to see Plan-Lint in action. </p>"},{"location":"contributing/","title":"Contributing","text":"<p>This page provides guidelines for contributing to Plan-Lint.</p>"},{"location":"getting-started/","title":"Getting Started with Plan-Linter","text":"<p>This guide will help you get up and running with Plan-Linter.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#using-pip","title":"Using pip","text":"<pre><code>pip install plan-lint\n</code></pre>"},{"location":"getting-started/#from-source","title":"From source","text":"<pre><code>git clone https://github.com/cirbuk/plan-lint.git\ncd plan-lint\npip install -e .\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use Plan-Linter is to run it on a JSON plan file:</p> <pre><code>plan-lint path/to/plan.json\n</code></pre> <p>This will validate the plan against the default schema and report any issues.</p>"},{"location":"getting-started/#using-a-policy-file","title":"Using a Policy File","text":"<p>For more control, create a policy YAML file:</p> <pre><code># policy.yaml\nallow_tools:\n  - sql.query_ro\n  - priceAPI.calculate\nbounds:\n  priceAPI.calculate.discount_pct: [-40, 0]\ndeny_tokens_regex:\n  - \"AWS_SECRET\"\n  - \"API_KEY\"\nmax_steps: 50\nrisk_weights:\n  tool_write: 0.4\n  raw_secret: 0.5\nfail_risk_threshold: 0.8\n</code></pre> <p>Then run Plan-Linter with the policy:</p> <pre><code>plan-lint path/to/plan.json --policy policy.yaml\n</code></pre>"},{"location":"getting-started/#output-formats","title":"Output Formats","text":"<p>Plan-Linter can output in different formats:</p>"},{"location":"getting-started/#cli-default","title":"CLI (default)","text":"<pre><code>plan-lint path/to/plan.json\n</code></pre> <p>This shows a rich formatted report in the terminal.</p>"},{"location":"getting-started/#json","title":"JSON","text":"<pre><code>plan-lint path/to/plan.json --format json\n</code></pre> <p>This outputs a machine-readable JSON report.</p>"},{"location":"getting-started/#saving-output","title":"Saving Output","text":"<p>To save the output to a file:</p> <pre><code>plan-lint path/to/plan.json --output results.txt\n</code></pre> <p>Or for JSON:</p> <pre><code>plan-lint path/to/plan.json --format json --output results.json\n</code></pre>"},{"location":"getting-started/#ci-integration","title":"CI Integration","text":"<p>Plan-Linter can be integrated into CI pipelines. Add this to your GitHub workflow:</p> <pre><code>- name: Lint agent plan\n  run: |\n    plan-lint path/to/plan.json --policy policy.yaml\n</code></pre> <p>The command will return a non-zero exit code if the plan fails validation, which will fail the CI step.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>See the README for more examples </li> <li>Read the Implementation Details</li> <li>Check out the Contributing Guide </li> </ul>"},{"location":"policy-authoring/","title":"Policy Authoring Guide","text":"<p>This guide will help you create custom policies for Plan-Lint using the Rego policy language.</p>"},{"location":"policy-authoring/#introduction-to-rego","title":"Introduction to Rego","text":"<p>Plan-Lint uses Rego, the policy language of Open Policy Agent (OPA), for defining validation rules. Rego is a declarative language specifically designed for expressing policies over complex data structures.</p>"},{"location":"policy-authoring/#basic-rego-concepts","title":"Basic Rego Concepts","text":"<ul> <li>Rules: Define conditions that should be met</li> <li>Packages: Group related rules together</li> <li>Imports: Include reusable functions or definitions</li> <li>Variables: Store intermediate values</li> <li>Comprehensions: Create collections by filtering and mapping</li> </ul>"},{"location":"policy-authoring/#plan-lint-policy-structure","title":"Plan-Lint Policy Structure","text":""},{"location":"policy-authoring/#package-naming","title":"Package Naming","text":"<p>All Plan-Lint policies should be defined in the <code>planlint.custom</code> package:</p> <pre><code>package planlint.custom\n</code></pre>"},{"location":"policy-authoring/#basic-policy-format","title":"Basic Policy Format","text":"<p>A typical policy rule follows this pattern:</p> <pre><code>deny[result] {\n    # Rule conditions\n    # ...\n\n    result := {\n        \"rule\": \"rule_name\",\n        \"message\": \"Human-readable message explaining the violation\",\n        \"severity\": \"high\",  # \"low\", \"medium\", \"high\", or \"critical\"\n        \"category\": \"category_name\",  # e.g., \"security\", \"performance\", etc.\n        \"step_id\": \"affected_step_id\",\n        \"metadata\": {\n            # Additional information about the violation\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#available-input-data","title":"Available Input Data","text":"<p>In your policies, you have access to:</p> <ul> <li><code>input.plan</code>: The full plan being validated</li> <li><code>input.context</code>: Additional context data provided during validation</li> </ul>"},{"location":"policy-authoring/#writing-your-first-policy","title":"Writing Your First Policy","text":"<p>Let's create a simple policy that detects file operations on sensitive paths:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Define sensitive paths\nsensitive_paths := [\"/etc/passwd\", \"/etc/shadow\", \"/var/log/auth.log\"]\n\n# Check if a file operation targets a sensitive path\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"file_operation\"\n\n    some path in sensitive_paths\n    startswith(step.parameters.path, path)\n\n    result := {\n        \"rule\": \"sensitive_path_access\",\n        \"message\": \"Operation attempts to access a sensitive system path\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"path\": step.parameters.path,\n            \"operation\": step.parameters.operation\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#advanced-policy-techniques","title":"Advanced Policy Techniques","text":""},{"location":"policy-authoring/#using-context-data","title":"Using Context Data","text":"<p>You can leverage context data to create more dynamic policies:</p> <pre><code>package planlint.custom\n\n# Check if a requested permission exceeds user's role\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"request_permission\"\n\n    # Get user role from context\n    user_role := input.context.user_role\n\n    # Define allowed permissions per role\n    allowed_permissions := {\n        \"user\": [\"read\"],\n        \"editor\": [\"read\", \"write\"],\n        \"admin\": [\"read\", \"write\", \"delete\", \"configure\"]\n    }\n\n    # Check if requested permission is allowed for this role\n    not step.parameters.permission in allowed_permissions[user_role]\n\n    result := {\n        \"rule\": \"permission_exceeds_role\",\n        \"message\": sprintf(\"User with role '%s' cannot request '%s' permission\", [user_role, step.parameters.permission]),\n        \"severity\": \"medium\",\n        \"category\": \"access_control\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"requested_permission\": step.parameters.permission,\n            \"user_role\": user_role,\n            \"allowed_permissions\": allowed_permissions[user_role]\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#step-dependencies-analysis","title":"Step Dependencies Analysis","text":"<p>You can analyze dependencies between steps:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect when sensitive data is passed to network operations\ndeny[result] {\n    # Find an authentication step\n    some auth_step in input.plan.steps\n    auth_step.tool == \"authenticate\"\n\n    # Find a network request step\n    some request_step in input.plan.steps\n    request_step.tool == \"http_request\"\n\n    # Check if auth data is referenced in request\n    contains(request_step.parameters.url, sprintf(\"{{%s.result}}\", [auth_step.id]))\n\n    result := {\n        \"rule\": \"auth_data_in_url\",\n        \"message\": \"Authentication data should not be included in URLs\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": request_step.id,\n        \"metadata\": {\n            \"auth_step\": auth_step.id,\n            \"url_parameter\": request_step.parameters.url\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#using-rego-built-in-functions","title":"Using Rego Built-in Functions","text":"<p>Rego provides many built-in functions for processing data:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Check for excessively large array operations\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"process_array\"\n\n    # Convert to number if string\n    array_size := to_number(step.parameters.size)\n\n    # Check if exceeds threshold\n    max_size := 10000\n    array_size &gt; max_size\n\n    result := {\n        \"rule\": \"large_array_operation\",\n        \"message\": \"Processing very large arrays can cause performance issues\",\n        \"severity\": \"medium\",\n        \"category\": \"performance\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"array_size\": array_size,\n            \"max_recommended_size\": max_size\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#pattern-matching-and-string-operations","title":"Pattern Matching and String Operations","text":"<p>Use pattern matching for detecting issues in string parameters:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Detect potential XSS vulnerabilities\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"render_html\"\n\n    # Look for common XSS patterns\n    dangerous_patterns := [\n        \"&lt;script&gt;\", \n        \"javascript:\", \n        \"onerror=\", \n        \"onload=\"\n    ]\n\n    some pattern in dangerous_patterns\n    contains(lower(step.parameters.content), pattern)\n\n    result := {\n        \"rule\": \"potential_xss\",\n        \"message\": \"HTML content contains potentially dangerous scripts\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"detected_pattern\": pattern\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#testing-your-policies","title":"Testing Your Policies","text":"<p>It's important to test policies with both valid and invalid plans:</p> <pre><code>package planlint.test\n\nimport data.planlint.custom\n\n# Test case for sensitive path access policy\ntest_sensitive_path_access {\n    # Define test plan with violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/etc/passwd\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that a violation was detected\n    count(violations) == 1\n    violations[_].rule == \"sensitive_path_access\"\n}\n\n# Test case for safe path\ntest_safe_path {\n    # Define test plan without violation\n    plan := {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"file_operation\",\n                \"parameters\": {\n                    \"operation\": \"read\",\n                    \"path\": \"/tmp/safe_file.txt\"\n                }\n            }\n        ]\n    }\n\n    # Run the policy\n    violations := custom.deny with input as {\"plan\": plan}\n\n    # Check that no violations were detected\n    count(violations) == 0\n}\n</code></pre> <p>To run these tests:</p> <pre><code>plan-lint test --policies your_policy.rego\n</code></pre>"},{"location":"policy-authoring/#organizing-multiple-policies","title":"Organizing Multiple Policies","text":"<p>For larger projects, organize policies into themes:</p> <pre><code>policies/\n  \u251c\u2500\u2500 security/\n  \u2502   \u251c\u2500\u2500 injection.rego\n  \u2502   \u251c\u2500\u2500 access_control.rego\n  \u2502   \u2514\u2500\u2500 data_exposure.rego\n  \u251c\u2500\u2500 performance/\n  \u2502   \u251c\u2500\u2500 resource_limits.rego\n  \u2502   \u2514\u2500\u2500 efficiency.rego\n  \u2514\u2500\u2500 reliability/\n      \u251c\u2500\u2500 error_handling.rego\n      \u2514\u2500\u2500 retries.rego\n</code></pre>"},{"location":"policy-authoring/#common-patterns-for-plan-lint-policies","title":"Common Patterns for Plan-Lint Policies","text":""},{"location":"policy-authoring/#detecting-dangerous-operations","title":"Detecting Dangerous Operations","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# List of dangerous system commands\ndangerous_commands := [\n    \"rm -rf\", \n    \"dd if=\", \n    \"mkfs\", \n    \"&gt; /dev/\",\n    \":(){ :|:&amp; };:\"  # Fork bomb\n]\n\n# Detect dangerous system commands\ndeny[result] {\n    some step in input.plan.steps\n    step.tool == \"execute_command\"\n\n    some cmd in dangerous_commands\n    contains(step.parameters.command, cmd)\n\n    result := {\n        \"rule\": \"dangerous_system_command\",\n        \"message\": \"Plan contains a potentially destructive system command\",\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"command\": step.parameters.command,\n            \"detected_pattern\": cmd\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#enforcing-tool-constraints","title":"Enforcing Tool Constraints","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Limit the number of API calls in a plan\ndeny[result] {\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n    count(api_steps) &gt; 5\n\n    result := {\n        \"rule\": \"too_many_api_calls\",\n        \"message\": \"Plan contains too many API calls which may lead to rate limiting\",\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": api_steps[0].id,  # Reference the first API call\n        \"metadata\": {\n            \"api_call_count\": count(api_steps),\n            \"max_recommended\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#contextual-validation","title":"Contextual Validation","text":"<pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Validate operations based on business hours\ndeny[result] {\n    # Only apply this rule if business_hours context is provided\n    input.context.business_hours\n\n    some step in input.plan.steps\n    step.tool == \"schedule_maintenance\"\n\n    # Convert maintenance time to number for comparison\n    maintenance_hour := to_number(step.parameters.hour)\n\n    # Check if maintenance is scheduled during business hours\n    maintenance_hour &gt;= input.context.business_hours.start\n    maintenance_hour &lt; input.context.business_hours.end\n\n    result := {\n        \"rule\": \"maintenance_during_business_hours\",\n        \"message\": \"Maintenance should be scheduled outside of business hours\",\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": step.id,\n        \"metadata\": {\n            \"scheduled_hour\": maintenance_hour,\n            \"business_hours\": sprintf(\"%d-%d\", [input.context.business_hours.start, input.context.business_hours.end])\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#best-practices","title":"Best Practices","text":"<ol> <li>Be Specific: Target policies to specific tools or operations</li> <li>Use Severity Levels Consistently: Follow these guidelines:</li> <li><code>critical</code>: Issues that must be fixed immediately</li> <li><code>high</code>: Significant security or reliability concerns</li> <li><code>medium</code>: Important but not critical issues</li> <li><code>low</code>: Minor concerns or best practice suggestions</li> <li>Include Helpful Messages: Make policy violation messages actionable and clear</li> <li>Add Metadata: Include relevant data to help developers understand and fix issues</li> <li>Test Thoroughly: Create test cases for both compliant and non-compliant plans</li> <li>Consider Performance: Complex policies might slow down validation; optimize when necessary</li> </ol>"},{"location":"policy-authoring/#debugging-policies","title":"Debugging Policies","text":"<p>When your policy isn't working as expected:</p> <ol> <li> <p>Use the <code>--debug</code> flag when running <code>plan-lint</code>:    <pre><code>plan-lint validate --plan my_plan.json --policies my_policy.rego --debug\n</code></pre></p> </li> <li> <p>Add print statements for debugging:    <pre><code>deny[result] {\n    # ...\n    print(\"Checking step:\", step.id)\n    print(\"Parameter value:\", step.parameters.value)\n    # ...\n}\n</code></pre></p> </li> <li> <p>Break down complex policies into smaller ones to isolate issues</p> </li> </ol>"},{"location":"policy-authoring/#policy-version-control","title":"Policy Version Control","text":"<p>For maintainable policies:</p> <ol> <li> <p>Add headers with version and author information:    <pre><code># Policy: prevent_sensitive_data_exposure\n# Version: 1.2\n# Author: Security Team\n# Last Updated: 2023-10-15\n# Description: Prevents exposure of sensitive data in logs and external services\npackage planlint.custom\n</code></pre></p> </li> <li> <p>Add comments explaining the rationale behind policy decisions</p> </li> <li> <p>Consider using meaningful file names that describe the policy's purpose</p> </li> </ol>"},{"location":"policy-authoring/#example-rate-limiting-policy","title":"Example: Rate Limiting Policy","text":"<p>Complete policy example for enforcing API rate limits:</p> <pre><code>package planlint.custom\n\nimport future.keywords.in\n\n# Rate limiting policy for API calls\n# Checks that the same API endpoint isn't called too frequently within a plan\n\n# Configuration\ndefault max_calls_per_endpoint = 3\n\n# Get customized limit from context if available\nmax_calls_per_endpoint = limit {\n    limit := input.context.api_rate_limits.max_calls_per_endpoint\n}\n\n# Group API calls by endpoint\napi_calls_by_endpoint[endpoint] = calls {\n    # Collect all API call steps\n    api_steps := [step | some step in input.plan.steps; step.tool == \"api_call\"]\n\n    # Group by endpoint\n    endpoints := {endpoint | some step in api_steps; endpoint := step.parameters.endpoint}\n\n    # For each endpoint, collect all steps that call it\n    some endpoint in endpoints\n    calls := [step | some step in api_steps; step.parameters.endpoint == endpoint]\n}\n\n# Detect rate limit violations\ndeny[result] {\n    some endpoint, calls in api_calls_by_endpoint\n    count(calls) &gt; max_calls_per_endpoint\n\n    result := {\n        \"rule\": \"api_rate_limit_exceeded\",\n        \"message\": sprintf(\"Too many calls to API endpoint '%s'\", [endpoint]),\n        \"severity\": \"medium\",\n        \"category\": \"reliability\",\n        \"step_id\": calls[0].id,  # Reference the first call to this endpoint\n        \"metadata\": {\n            \"endpoint\": endpoint,\n            \"call_count\": count(calls),\n            \"max_allowed\": max_calls_per_endpoint,\n            \"all_calls\": [step.id | some step in calls]\n        }\n    }\n}\n</code></pre>"},{"location":"policy-authoring/#conclusion","title":"Conclusion","text":"<p>Creating effective policies is an iterative process. Start with simple rules and gradually build more complex validation logic as your understanding of potential issues grows. Remember that policies should balance security with usability - overly strict policies might frustrate users and lead to workarounds.</p> <p>For more examples and inspiration, check out the default policies included with Plan-Lint and the examples in the Plan-Lint documentation. </p>"},{"location":"advanced/automating-validation/","title":"Automating Validation","text":"<p>This page explains how to automate the validation of plans with Plan-Lint.</p>"},{"location":"advanced/automating-validation/#automation-methods","title":"Automation Methods","text":"<p>Plan-Lint offers several ways to automate plan validation:</p> <ol> <li>Command Line Interface (CLI): For batch processing or scripting</li> <li>Python API: For programmatic integration</li> <li>Webhook Endpoints: For event-driven validation</li> <li>Scheduled Jobs: For periodic validation</li> </ol>"},{"location":"advanced/automating-validation/#cli-automation","title":"CLI Automation","text":"<p>The Plan-Lint CLI is designed for automation and can be easily integrated into shell scripts.</p>"},{"location":"advanced/automating-validation/#batch-processing","title":"Batch Processing","text":"<p>You can validate multiple plans with a single command:</p> <pre><code># Validate all plans in a directory\nplan-lint validate-batch --plans-dir ./plans/ --policy policy.yaml\n\n# Process with glob patterns\nplan-lint validate-batch --plans-pattern \"./plans/**/*.json\" --policy-dir ./policies/\n</code></pre>"},{"location":"advanced/automating-validation/#exit-codes","title":"Exit Codes","text":"<p>Plan-Lint CLI returns meaningful exit codes for automation:</p> <ul> <li><code>0</code>: All plans are valid (no violations found)</li> <li><code>1</code>: At least one plan has violations</li> <li><code>2</code>: Validation error (invalid input, missing policy, etc.)</li> </ul>"},{"location":"advanced/automating-validation/#generating-reports","title":"Generating Reports","text":"<pre><code># Generate JSON report\nplan-lint validate --plan plan.json --policy policy.yaml --report-format json --output report.json\n\n# Generate HTML report\nplan-lint validate --plan plan.json --policy policy.yaml --report-format html --output report.html\n</code></pre>"},{"location":"advanced/automating-validation/#python-api-automation","title":"Python API Automation","text":"<p>Plan-Lint's Python API allows for deep integration into your applications.</p>"},{"location":"advanced/automating-validation/#basic-validation","title":"Basic Validation","text":"<pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\n\n# Load plan and policy\nplan = load_plan(\"path/to/plan.json\")\npolicy = load_policy(\"path/to/policy.yaml\")\n\n# Validate\nresult = validate_plan(plan, policy)\n\n# Check result\nif result.is_valid:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Plan has {len(result.violations)} violations\")\n    for violation in result.violations:\n        print(f\"- {violation.rule}: {violation.message}\")\n</code></pre>"},{"location":"advanced/automating-validation/#batch-processing_1","title":"Batch Processing","text":"<pre><code>import glob\nimport json\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\n\n# Load policy\npolicy = load_policy(\"policy.yaml\")\n\n# Get all plan files\nplan_files = glob.glob(\"plans/*.json\")\n\n# Process each plan\nresults = {}\nfor plan_file in plan_files:\n    # Load plan\n    plan = load_plan(plan_file)\n\n    # Validate\n    result = validate_plan(plan, policy)\n\n    # Store result\n    results[plan_file] = {\n        \"is_valid\": result.is_valid,\n        \"violations\": [\n            {\n                \"rule\": v.rule,\n                \"message\": v.message,\n                \"severity\": v.severity,\n                \"step_id\": v.step_id\n            } for v in result.violations\n        ]\n    }\n\n# Write report\nwith open(\"validation_report.json\", \"w\") as f:\n    json.dump(results, f, indent=2)\n</code></pre>"},{"location":"advanced/automating-validation/#streaming-plans","title":"Streaming Plans","text":"<p>For high-throughput scenarios, you can stream plans through the validation system:</p> <pre><code>import json\nfrom plan_lint import PlanValidator\nfrom plan_lint.loader import load_policy\n\n# Create validator\npolicy = load_policy(\"policy.yaml\")\nvalidator = PlanValidator(policy)\n\n# Function to process stream\ndef process_plan_stream(stream):\n    for line in stream:\n        # Parse plan from line\n        plan_data = json.loads(line)\n\n        # Validate\n        result = validator.validate(plan_data)\n\n        # Process result\n        if not result.is_valid:\n            yield (plan_data.get(\"id\", \"unknown\"), result.violations)\n\n# Example: process from file\nwith open(\"plans_stream.jsonl\") as f:\n    for plan_id, violations in process_plan_stream(f):\n        print(f\"Plan {plan_id} has violations\")\n</code></pre>"},{"location":"advanced/automating-validation/#webhook-integration","title":"Webhook Integration","text":"<p>You can set up a Plan-Lint webhook server to validate plans on demand.</p>"},{"location":"advanced/automating-validation/#simple-flask-server","title":"Simple Flask Server","text":"<pre><code>from flask import Flask, request, jsonify\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\napp = Flask(__name__)\n\n# Load policy at startup\npolicy = load_policy(\"policy.yaml\")\n\n@app.route('/validate', methods=['POST'])\ndef validate():\n    # Get plan from request\n    plan_data = request.json\n\n    # Validate plan\n    result = validate_plan(plan_data, policy)\n\n    # Return result\n    return jsonify({\n        \"is_valid\": result.is_valid,\n        \"violations\": [\n            {\n                \"rule\": v.rule,\n                \"message\": v.message,\n                \"severity\": v.severity,\n                \"step_id\": v.step_id\n            } for v in result.violations\n        ]\n    })\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n</code></pre>"},{"location":"advanced/automating-validation/#fastapi-implementation","title":"FastAPI Implementation","text":"<p>For a more robust webhook server:</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Any, Optional\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\napp = FastAPI(title=\"Plan-Lint API\")\n\n# Load policies\ndefault_policy = load_policy(\"policy.yaml\")\npolicies = {\n    \"default\": default_policy,\n    \"strict\": load_policy(\"strict_policy.yaml\"),\n    \"enterprise\": load_policy(\"enterprise_policy.yaml\")\n}\n\nclass Plan(BaseModel):\n    goal: str = Field(..., description=\"The goal of the plan\")\n    steps: List[Dict[str, Any]] = Field(..., description=\"The steps of the plan\")\n    context: Optional[Dict[str, Any]] = Field(None, description=\"Additional context\")\n\nclass ValidationRequest(BaseModel):\n    plan: Plan\n    policy_name: Optional[str] = Field(\"default\", description=\"Policy to use for validation\")\n    context: Optional[Dict[str, Any]] = Field(None, description=\"Validation context\")\n\nclass ValidationResponse(BaseModel):\n    is_valid: bool\n    violations: List[Dict[str, Any]]\n\n@app.post(\"/api/validate\", response_model=ValidationResponse)\nasync def validate(request: ValidationRequest):\n    # Get policy\n    if request.policy_name not in policies:\n        raise HTTPException(status_code=400, detail=f\"Unknown policy: {request.policy_name}\")\n\n    policy = policies[request.policy_name]\n\n    # Validate plan\n    result = validate_plan(request.plan.dict(), policy, context=request.context)\n\n    # Return result\n    return {\n        \"is_valid\": result.is_valid,\n        \"violations\": [\n            {\n                \"rule\": v.rule,\n                \"message\": v.message,\n                \"severity\": v.severity,\n                \"step_id\": v.step_id\n            } for v in result.violations\n        ]\n    }\n\n# Run with: uvicorn app:app --host 0.0.0.0 --port 8000\n</code></pre>"},{"location":"advanced/automating-validation/#scheduled-validation","title":"Scheduled Validation","text":"<p>For scenarios where plans need to be validated on a schedule, you can set up cron jobs or other scheduling systems.</p>"},{"location":"advanced/automating-validation/#cron-job-example","title":"Cron Job Example","text":"<pre><code># /etc/cron.d/plan-lint\n# Run plan validation every hour\n0 * * * * planlint-user /usr/local/bin/plan-lint validate-batch --plans-dir /var/plans --policy /etc/planlint/policy.yaml --output /var/log/planlint/$(date +\\%Y\\%m\\%d\\%H).json\n</code></pre>"},{"location":"advanced/automating-validation/#airflow-dag","title":"Airflow DAG","text":"<p>For more complex scheduling with Apache Airflow:</p> <pre><code>from airflow import DAG\nfrom airflow.operators.bash import BashOperator\nfrom airflow.operators.python import PythonOperator\nfrom datetime import datetime, timedelta\nimport glob\nimport json\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\n\ndefault_args = {\n    'owner': 'airflow',\n    'depends_on_past': False,\n    'email_on_failure': True,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': timedelta(minutes=5),\n}\n\ndag = DAG(\n    'plan_lint_validation',\n    default_args=default_args,\n    description='Validate plans with Plan-Lint',\n    schedule_interval=timedelta(hours=1),\n    start_date=datetime(2023, 1, 1),\n    catchup=False,\n)\n\n# Task to list plans\nlist_plans = BashOperator(\n    task_id='list_plans',\n    bash_command='ls -1 /path/to/plans/*.json &gt; /tmp/plans_to_validate.txt',\n    dag=dag,\n)\n\n# Task to validate plans\ndef validate_plans():\n    # Load policy\n    policy = load_policy(\"/path/to/policy.yaml\")\n\n    # Get plan files\n    with open(\"/tmp/plans_to_validate.txt\") as f:\n        plan_files = [line.strip() for line in f]\n\n    # Validate each plan\n    results = {}\n    for plan_file in plan_files:\n        plan = load_plan(plan_file)\n        result = validate_plan(plan, policy)\n        results[plan_file] = {\n            \"is_valid\": result.is_valid,\n            \"violations\": [v.to_dict() for v in result.violations]\n        }\n\n    # Write report\n    timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    report_path = f\"/path/to/reports/validation_{timestamp}.json\"\n    with open(report_path, \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return report_path\n\nvalidate_task = PythonOperator(\n    task_id='validate_plans',\n    python_callable=validate_plans,\n    dag=dag,\n)\n\n# Define task order\nlist_plans &gt;&gt; validate_task\n</code></pre>"},{"location":"advanced/automating-validation/#integration-with-message-queues","title":"Integration with Message Queues","text":"<p>For high-scale automation, you can integrate Plan-Lint with message queues like RabbitMQ or Kafka.</p>"},{"location":"advanced/automating-validation/#rabbitmq-consumer","title":"RabbitMQ Consumer","text":"<pre><code>import pika\nimport json\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n# Load policy\npolicy = load_policy(\"policy.yaml\")\n\n# Connect to RabbitMQ\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\n\n# Declare queues\nchannel.queue_declare(queue='plans_to_validate')\nchannel.queue_declare(queue='validation_results')\n\n# Define callback\ndef callback(ch, method, properties, body):\n    # Parse plan\n    plan_data = json.loads(body)\n\n    # Validate plan\n    result = validate_plan(plan_data, policy)\n\n    # Create result message\n    result_message = {\n        \"plan_id\": plan_data.get(\"id\", \"unknown\"),\n        \"is_valid\": result.is_valid,\n        \"violations\": [\n            {\n                \"rule\": v.rule,\n                \"message\": v.message,\n                \"severity\": v.severity,\n                \"step_id\": v.step_id\n            } for v in result.violations\n        ]\n    }\n\n    # Publish result\n    channel.basic_publish(\n        exchange='',\n        routing_key='validation_results',\n        body=json.dumps(result_message)\n    )\n\n    # Acknowledge message\n    ch.basic_ack(delivery_tag=method.delivery_tag)\n\n# Set up consumer\nchannel.basic_consume(\n    queue='plans_to_validate',\n    on_message_callback=callback\n)\n\n# Start consuming\nprint('Waiting for plans to validate. To exit press CTRL+C')\nchannel.start_consuming()\n</code></pre>"},{"location":"advanced/automating-validation/#containerized-validation","title":"Containerized Validation","text":"<p>You can containerize Plan-Lint for consistent deployment across environments:</p>"},{"location":"advanced/automating-validation/#dockerfile","title":"Dockerfile","text":"<pre><code>FROM python:3.9-slim\n\nWORKDIR /app\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy policies and application\nCOPY policies/ ./policies/\nCOPY app.py .\n\n# Set environment variables\nENV PYTHONUNBUFFERED=1\n\n# Run the application\nCMD [\"python\", \"app.py\"]\n</code></pre>"},{"location":"advanced/automating-validation/#docker-compose","title":"Docker Compose","text":"<pre><code>version: '3'\n\nservices:\n  plan-lint:\n    build: .\n    volumes:\n      - ./plans:/app/plans\n      - ./reports:/app/reports\n    environment:\n      - POLICY_PATH=/app/policies/policy.yaml\n      - REPORT_DIR=/app/reports\n    ports:\n      - \"8000:8000\"\n</code></pre>"},{"location":"advanced/automating-validation/#monitoring-and-alerting","title":"Monitoring and Alerting","text":"<p>For production deployments, you can add monitoring and alerting:</p>"},{"location":"advanced/automating-validation/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code>from prometheus_client import Counter, Histogram, start_http_server\nimport time\n\n# Define metrics\nVALIDATION_COUNT = Counter('plan_lint_validations_total', 'Total number of validations')\nVIOLATION_COUNT = Counter('plan_lint_violations_total', 'Total number of violations', ['rule', 'severity'])\nVALIDATION_TIME = Histogram('plan_lint_validation_seconds', 'Time spent validating plans')\n\n# Start metrics server\nstart_http_server(8000)\n\n# Instrumented validation function\ndef validate_with_metrics(plan, policy):\n    # Count validation\n    VALIDATION_COUNT.inc()\n\n    # Time validation\n    start_time = time.time()\n    with VALIDATION_TIME.time():\n        result = validate_plan(plan, policy)\n\n    # Count violations\n    for violation in result.violations:\n        VIOLATION_COUNT.labels(\n            rule=violation.rule,\n            severity=violation.severity\n        ).inc()\n\n    return result\n</code></pre>"},{"location":"advanced/automating-validation/#slack-alerts","title":"Slack Alerts","text":"<pre><code>import requests\nimport json\n\ndef send_slack_alert(webhook_url, plan_id, violations):\n    # Skip if no violations\n    if not violations:\n        return\n\n    # Create message\n    message = {\n        \"text\": f\"\ud83d\udea8 Plan '{plan_id}' has validation violations\",\n        \"blocks\": [\n            {\n                \"type\": \"header\",\n                \"text\": {\n                    \"type\": \"plain_text\",\n                    \"text\": f\"\ud83d\udea8 Plan Validation Failed: {plan_id}\"\n                }\n            },\n            {\n                \"type\": \"section\",\n                \"text\": {\n                    \"type\": \"mrkdwn\",\n                    \"text\": f\"*{len(violations)}* violations were found in the plan.\"\n                }\n            }\n        ]\n    }\n\n    # Add violation details\n    for violation in violations[:5]:  # Limit to first 5\n        message[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"*{violation['rule']}* ({violation['severity']})\\n{violation['message']}\"\n            }\n        })\n\n    # Add footer if more violations\n    if len(violations) &gt; 5:\n        message[\"blocks\"].append({\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"_...and {len(violations) - 5} more violations_\"\n            }\n        })\n\n    # Send message\n    response = requests.post(\n        webhook_url,\n        data=json.dumps(message),\n        headers={\"Content-Type\": \"application/json\"}\n    )\n\n    return response.status_code == 200\n</code></pre>"},{"location":"advanced/automating-validation/#best-practices-for-automation","title":"Best Practices for Automation","text":"<ol> <li>Version Your Policies: Use version control for policies to track changes</li> <li>Staged Rollout: Implement new policies in monitoring mode before enforcing</li> <li>Performance Optimization: For high-throughput scenarios:</li> <li>Load policies once and reuse the validator instance</li> <li>Use batch processing when possible</li> <li>Consider multi-threading for parallel validation</li> <li>Error Handling: Implement robust error handling and fallbacks</li> <li>Logging: Add detailed logging for troubleshooting</li> <li>Authentication: Secure webhook endpoints with proper authentication</li> <li>Caching: Consider caching validation results for identical plans</li> </ol>"},{"location":"advanced/automating-validation/#example-complete-automated-workflow","title":"Example: Complete Automated Workflow","text":"<p>Here's an example workflow for automated validation in a production environment:</p> <ol> <li>Agent generates plan</li> <li>Plan is submitted to validation queue</li> <li>Validation service processes plan:</li> <li>Applies relevant policies based on context</li> <li>Records metrics and logs</li> <li>Stores validation result</li> <li>Action based on result:</li> <li>If valid: Execute plan</li> <li>If invalid: Block execution, notify appropriate team</li> <li>Monitoring system alerts on anomalies:</li> <li>High violation rates</li> <li>Validation service performance issues</li> <li>Policy application errors</li> </ol> <p>By automating validation with Plan-Lint, you can ensure consistent policy enforcement across your agent systems, reducing risk and increasing operational efficiency.</p>"},{"location":"advanced/ci-cd-integration/","title":"CI/CD Integration","text":"<p>This page explains how to integrate Plan-Lint into CI/CD pipelines.</p>"},{"location":"advanced/ci-cd-integration/#benefits-of-cicd-integration","title":"Benefits of CI/CD Integration","text":"<p>Integrating Plan-Lint into your CI/CD pipelines offers several advantages:</p> <ol> <li>Automated Validation: Automatically check agent plans before they reach production</li> <li>Early Detection: Catch harmful or non-compliant plans early in the development lifecycle</li> <li>Consistent Enforcement: Apply the same policies across all environments</li> <li>Quality Gates: Create security and compliance gates for agent plans</li> <li>Audit Trail: Maintain records of plan validations for compliance needs</li> </ol>"},{"location":"advanced/ci-cd-integration/#integration-patterns","title":"Integration Patterns","text":""},{"location":"advanced/ci-cd-integration/#pre-deployment-validation","title":"Pre-Deployment Validation","text":"<p>Validate plans before deployment to catch issues early:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2502  Commit     \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Build      \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Validate   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Deploy     \u2502\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/ci-cd-integration/#environmental-progression","title":"Environmental Progression","text":"<p>Apply different policies as plans move through environments:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2502  Dev        \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Test       \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Staging    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Production \u2502\n\u2502  Validation \u2502      \u2502  Validation \u2502      \u2502  Validation \u2502      \u2502  Validation \u2502\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/ci-cd-integration/#policy-testing","title":"Policy Testing","text":"<p>Test policies themselves to ensure they work as expected:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2502  Policy     \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy     \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy     \u2502\n\u2502  Changes    \u2502      \u2502  Tests      \u2502      \u2502  Deployment \u2502\n\u2502             \u2502      \u2502             \u2502      \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"advanced/ci-cd-integration/#github-actions-integration","title":"GitHub Actions Integration","text":""},{"location":"advanced/ci-cd-integration/#basic-validation-workflow","title":"Basic Validation Workflow","text":"<p>A simple GitHub Actions workflow to validate plans:</p> <pre><code># .github/workflows/validate-plans.yml\nname: Validate Agent Plans\n\non:\n  push:\n    branches: [ main, develop ]\n    paths:\n      - 'plans/**'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - 'plans/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n\n      - name: Validate plans\n        run: |\n          plan-lint validate-batch \\\n            --plans-dir plans/ \\\n            --policy policies/security.yaml \\\n            --report-format json \\\n            --output validation-report.json\n\n      - name: Check for critical violations\n        run: |\n          python -c \"\n          import json\n          import sys\n\n          with open('validation-report.json') as f:\n              report = json.load(f)\n\n          critical_violations = 0\n          for plan_path, result in report.items():\n              for violation in result.get('violations', []):\n                  if violation.get('severity') == 'critical':\n                      critical_violations += 1\n                      print(f'CRITICAL: {violation.get(\\\"message\\\")} in {plan_path}')\n\n          sys.exit(1 if critical_violations &gt; 0 else 0)\n          \"\n\n      - name: Upload validation report\n        uses: actions/upload-artifact@v3\n        with:\n          name: validation-report\n          path: validation-report.json\n</code></pre>"},{"location":"advanced/ci-cd-integration/#multi-environment-validation","title":"Multi-Environment Validation","text":"<p>A workflow that validates against multiple environment policies:</p> <pre><code># .github/workflows/multi-env-validation.yml\nname: Multi-Environment Validation\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - 'plans/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        environment: [development, staging, production]\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n\n      - name: Validate plans for ${{ matrix.environment }}\n        run: |\n          plan-lint validate-batch \\\n            --plans-dir plans/ \\\n            --policy policies/${{ matrix.environment }}.yaml \\\n            --report-format json \\\n            --output ${{ matrix.environment }}-report.json\n\n      - name: Check for violations\n        run: |\n          python -c \"\n          import json\n          import sys\n\n          with open('${{ matrix.environment }}-report.json') as f:\n              report = json.load(f)\n\n          # For production, any violation is a failure\n          # For staging, only critical and high are failures\n          # For development, only critical is a failure\n          environment = '${{ matrix.environment }}'\n          failure_severities = ['critical'] if environment == 'development' else (['critical', 'high'] if environment == 'staging' else ['critical', 'high', 'medium', 'low'])\n\n          violations = 0\n          for plan_path, result in report.items():\n              for violation in result.get('violations', []):\n                  if violation.get('severity') in failure_severities:\n                      violations += 1\n                      print(f'{violation.get(\\\"severity\\\").upper()}: {violation.get(\\\"message\\\")} in {plan_path}')\n\n          sys.exit(1 if violations &gt; 0 else 0)\n          \"\n\n      - name: Upload validation report\n        uses: actions/upload-artifact@v3\n        with:\n          name: ${{ matrix.environment }}-report\n          path: ${{ matrix.environment }}-report.json\n</code></pre>"},{"location":"advanced/ci-cd-integration/#scheduled-policy-application","title":"Scheduled Policy Application","text":"<p>A workflow that runs validation on a schedule:</p> <pre><code># .github/workflows/scheduled-validation.yml\nname: Scheduled Validation\n\non:\n  schedule:\n    # Run every night at midnight\n    - cron: '0 0 * * *'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint requests\n\n      - name: Fetch latest plans\n        run: |\n          # Example: Pull plans from a repository or API\n          python -c \"\n          import requests\n          import json\n          import os\n\n          # Create plans directory\n          os.makedirs('plans', exist_ok=True)\n\n          # Fetch plans from API\n          response = requests.get('https://api.example.com/agent-plans')\n          plans = response.json()\n\n          # Save plans to files\n          for i, plan in enumerate(plans):\n              with open(f'plans/plan_{i}.json', 'w') as f:\n                  json.dump(plan, f, indent=2)\n          \"\n\n      - name: Validate plans\n        run: |\n          plan-lint validate-batch \\\n            --plans-dir plans/ \\\n            --policy policies/production.yaml \\\n            --report-format json \\\n            --output validation-report.json\n\n      - name: Send report to monitoring system\n        run: |\n          python -c \"\n          import json\n          import requests\n\n          with open('validation-report.json') as f:\n              report = json.load(f)\n\n          # Send to monitoring system\n          requests.post(\n              'https://monitoring.example.com/webhooks/planlint',\n              json={\n                  'timestamp': '$(date -u +\\\"%Y-%m-%dT%H:%M:%SZ\\\")',\n                  'report': report\n              }\n          )\n          \"\n</code></pre>"},{"location":"advanced/ci-cd-integration/#gitlab-ci-integration","title":"GitLab CI Integration","text":""},{"location":"advanced/ci-cd-integration/#basic-validation-pipeline","title":"Basic Validation Pipeline","text":"<p>A GitLab CI pipeline to validate plans:</p> <pre><code># .gitlab-ci.yml\nstages:\n  - validate\n  - report\n\nvariables:\n  PYTHON_VERSION: \"3.9\"\n\nvalidate-plans:\n  stage: validate\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install plan-lint\n    - plan-lint validate-batch --plans-dir plans/ --policy policies/security.yaml --report-format json --output validation-report.json\n  artifacts:\n    paths:\n      - validation-report.json\n    expire_in: 1 week\n\ngenerate-report:\n  stage: report\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install plan-lint matplotlib pandas\n    - python -c \"\n        import json\n        import pandas as pd\n        import matplotlib.pyplot as plt\n\n        # Load report\n        with open('validation-report.json') as f:\n            report = json.load(f)\n\n        # Extract violations\n        violations = []\n        for plan_path, result in report.items():\n            for v in result.get('violations', []):\n                violations.append({\n                    'plan': plan_path,\n                    'rule': v.get('rule'),\n                    'severity': v.get('severity'),\n                    'message': v.get('message'),\n                    'step_id': v.get('step_id')\n                })\n\n        # Create dataframe\n        df = pd.DataFrame(violations)\n\n        # Generate stats\n        if not df.empty:\n            # Count by severity\n            severity_counts = df['severity'].value_counts()\n\n            # Plot\n            plt.figure(figsize=(10, 6))\n            severity_counts.plot(kind='bar')\n            plt.title('Violations by Severity')\n            plt.tight_layout()\n            plt.savefig('violations_by_severity.png')\n\n            # Output stats to file\n            with open('violation_stats.txt', 'w') as f:\n                f.write(f'Total violations: {len(violations)}\\n\\n')\n                f.write('Violations by severity:\\n')\n                for severity, count in severity_counts.items():\n                    f.write(f'- {severity}: {count}\\n')\n        else:\n            with open('violation_stats.txt', 'w') as f:\n                f.write('No violations found. All plans are valid!\\n')\n      \"\n  artifacts:\n    paths:\n      - validation-report.json\n      - violation_stats.txt\n      - violations_by_severity.png\n    expire_in: 1 month\n  dependencies:\n    - validate-plans\n</code></pre>"},{"location":"advanced/ci-cd-integration/#policy-testing-pipeline","title":"Policy Testing Pipeline","text":"<p>A pipeline to test policies before deployment:</p> <pre><code># .gitlab-ci.yml\nstages:\n  - lint\n  - test\n  - deploy\n\nvariables:\n  PYTHON_VERSION: \"3.9\"\n\nlint-policies:\n  stage: lint\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install plan-lint pyyaml\n    - |\n      python -c \"\n      import yaml\n      import glob\n      import sys\n\n      errors = 0\n      for file in glob.glob('policies/*.yaml'):\n          try:\n              with open(file) as f:\n                  data = yaml.safe_load(f)\n              print(f'\u2705 {file} is valid YAML')\n          except yaml.YAMLError as e:\n              print(f'\u274c Error in {file}: {e}')\n              errors += 1\n\n      sys.exit(errors)\n      \"\n\ntest-policies:\n  stage: test\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install plan-lint\n    - |\n      for policy in policies/*.yaml; do\n        echo \"Testing $policy...\"\n\n        # Run against known-good plans (should pass)\n        plan-lint validate-batch --plans-dir test-plans/valid/ --policy $policy || exit 1\n\n        # Run against known-bad plans (should fail)\n        if plan-lint validate-batch --plans-dir test-plans/invalid/ --policy $policy --quiet; then\n          echo \"\u274c Error: Policy $policy failed to detect invalid plans\"\n          exit 1\n        else\n          echo \"\u2705 Policy $policy correctly identified invalid plans\"\n        fi\n      done\n\ndeploy-policies:\n  stage: deploy\n  image: python:${PYTHON_VERSION}\n  script:\n    - pip install plan-lint\n    - |\n      # Bundle policies\n      plan-lint bundle --policy-dir policies/ --output policies-bundle.tar.gz\n\n      # Deploy to policy server\n      curl -X POST \\\n        -F \"policies=@policies-bundle.tar.gz\" \\\n        -H \"Authorization: Bearer ${POLICY_SERVER_TOKEN}\" \\\n        https://policy-server.example.com/api/v1/policies/upload\n  only:\n    - main\n</code></pre>"},{"location":"advanced/ci-cd-integration/#azure-devops-integration","title":"Azure DevOps Integration","text":""},{"location":"advanced/ci-cd-integration/#azure-pipelines-yaml","title":"Azure Pipelines YAML","text":"<pre><code># azure-pipelines.yml\ntrigger:\n  branches:\n    include:\n    - main\n    - release/*\n  paths:\n    include:\n    - plans/*\n    - policies/*\n\npool:\n  vmImage: 'ubuntu-latest'\n\nstages:\n- stage: Validate\n  jobs:\n  - job: ValidatePlans\n    steps:\n    - task: UsePythonVersion@0\n      inputs:\n        versionSpec: '3.9'\n        addToPath: true\n\n    - script: |\n        python -m pip install --upgrade pip\n        pip install plan-lint\n      displayName: 'Install dependencies'\n\n    - script: |\n        plan-lint validate-batch \\\n          --plans-dir $(System.DefaultWorkingDirectory)/plans/ \\\n          --policy $(System.DefaultWorkingDirectory)/policies/security.yaml \\\n          --report-format json \\\n          --output $(Build.ArtifactStagingDirectory)/validation-report.json\n      displayName: 'Validate plans'\n\n    - script: |\n        python -c \"\n        import json\n        import sys\n\n        with open('$(Build.ArtifactStagingDirectory)/validation-report.json') as f:\n            report = json.load(f)\n\n        critical_violations = 0\n        for plan_path, result in report.items():\n            for violation in result.get('violations', []):\n                if violation.get('severity') == 'critical':\n                    critical_violations += 1\n                    print(f'##vso[task.logissue type=error;]CRITICAL: {violation.get(\\\"message\\\")} in {plan_path}')\n\n        print(f'##vso[task.setvariable variable=criticalViolations;]{critical_violations}')\n        \"\n      displayName: 'Check for critical violations'\n\n    - script: |\n        if [ $(criticalViolations) -gt 0 ]; then\n          echo \"##vso[task.complete result=Failed;]Critical violations found\"\n        fi\n      displayName: 'Fail if critical violations exist'\n\n    - task: PublishBuildArtifacts@1\n      inputs:\n        pathtoPublish: '$(Build.ArtifactStagingDirectory)/validation-report.json'\n        artifactName: 'ValidationReport'\n      displayName: 'Publish Validation Report'\n\n- stage: Deploy\n  dependsOn: Validate\n  condition: succeeded()\n  jobs:\n  - job: DeployPlans\n    steps:\n    - task: DownloadBuildArtifacts@0\n      inputs:\n        buildType: 'current'\n        downloadType: 'single'\n        artifactName: 'ValidationReport'\n        downloadPath: '$(System.ArtifactsDirectory)'\n\n    - script: |\n        echo \"Deploying validated plans...\"\n        # Add deployment steps here\n      displayName: 'Deploy plans'\n</code></pre>"},{"location":"advanced/ci-cd-integration/#jenkins-integration","title":"Jenkins Integration","text":""},{"location":"advanced/ci-cd-integration/#jenkinsfile-with-pipeline","title":"Jenkinsfile with Pipeline","text":"<pre><code>// Jenkinsfile\npipeline {\n    agent {\n        docker {\n            image 'python:3.9'\n        }\n    }\n\n    stages {\n        stage('Setup') {\n            steps {\n                sh '''\n                python -m pip install --upgrade pip\n                pip install plan-lint\n                '''\n            }\n        }\n\n        stage('Validate') {\n            steps {\n                sh '''\n                plan-lint validate-batch \\\n                  --plans-dir ./plans/ \\\n                  --policy ./policies/security.yaml \\\n                  --report-format json \\\n                  --output validation-report.json\n                '''\n\n                script {\n                    def report = readJSON file: 'validation-report.json'\n                    def criticalViolations = 0\n\n                    report.each { planPath, result -&gt;\n                        result.violations.each { violation -&gt;\n                            if (violation.severity == 'critical') {\n                                criticalViolations++\n                                echo \"CRITICAL: ${violation.message} in ${planPath}\"\n                            }\n                        }\n                    }\n\n                    if (criticalViolations &gt; 0) {\n                        currentBuild.result = 'FAILURE'\n                        error \"Found ${criticalViolations} critical violations\"\n                    }\n                }\n\n                archiveArtifacts artifacts: 'validation-report.json', fingerprint: true\n            }\n        }\n\n        stage('Deploy') {\n            when {\n                expression { currentBuild.resultIsBetterOrEqualTo('SUCCESS') }\n            }\n            steps {\n                echo \"Deploying validated plans...\"\n                // Add deployment steps here\n            }\n        }\n    }\n\n    post {\n        always {\n            sh '''\n            if [ -f validation-report.json ]; then\n                python -c \"\n                import json\n\n                with open('validation-report.json') as f:\n                    report = json.load(f)\n\n                total_violations = 0\n                for plan_path, result in report.items():\n                    total_violations += len(result.get('violations', []))\n\n                print(f'Total violations: {total_violations}')\n                \"\n            fi\n            '''\n        }\n    }\n}\n</code></pre>"},{"location":"advanced/ci-cd-integration/#circleci-integration","title":"CircleCI Integration","text":""},{"location":"advanced/ci-cd-integration/#circleci-config","title":"CircleCI Config","text":"<pre><code># .circleci/config.yml\nversion: 2.1\n\njobs:\n  validate:\n    docker:\n      - image: cimg/python:3.9\n    steps:\n      - checkout\n      - run:\n          name: Install dependencies\n          command: |\n            python -m pip install --upgrade pip\n            pip install plan-lint\n      - run:\n          name: Validate plans\n          command: |\n            plan-lint validate-batch \\\n              --plans-dir ./plans/ \\\n              --policy ./policies/security.yaml \\\n              --report-format json \\\n              --output validation-report.json\n      - run:\n          name: Check for violations\n          command: |\n            python -c \"\n            import json\n            import sys\n\n            with open('validation-report.json') as f:\n                report = json.load(f)\n\n            critical_violations = 0\n            for plan_path, result in report.items():\n                for violation in result.get('violations', []):\n                    if violation.get('severity') == 'critical':\n                        critical_violations += 1\n                        print(f'CRITICAL: {violation.get(\\\"message\\\")} in {plan_path}')\n\n            if critical_violations &gt; 0:\n                print(f'Found {critical_violations} critical violations')\n                sys.exit(1)\n            else:\n                print('No critical violations found')\n            \"\n      - store_artifacts:\n          path: validation-report.json\n          destination: validation-report.json\n\n  deploy:\n    docker:\n      - image: cimg/python:3.9\n    steps:\n      - checkout\n      - run:\n          name: Deploy validated plans\n          command: |\n            echo \"Deploying validated plans...\"\n            # Add deployment steps here\n\nworkflows:\n  version: 2\n  validate-and-deploy:\n    jobs:\n      - validate\n      - deploy:\n          requires:\n            - validate\n          filters:\n            branches:\n              only: main\n</code></pre>"},{"location":"advanced/ci-cd-integration/#best-practices-for-cicd-integration","title":"Best Practices for CI/CD Integration","text":"<ol> <li>Policy Version Control: </li> <li>Keep policies in version control alongside application code</li> <li>Use policy versioning to track changes over time</li> <li> <p>Require code reviews for policy changes</p> </li> <li> <p>Fail Fast: </p> </li> <li>Validate plans early in the CI/CD pipeline</li> <li>Create focused policies for specific issues</li> <li> <p>Exit as soon as critical violations are detected</p> </li> <li> <p>Environment-Specific Policies:</p> </li> <li>Create gradual policy progression from development to production</li> <li>Be more permissive in dev, strict in production</li> <li> <p>Match policies to environment security requirements</p> </li> <li> <p>Handling Results:</p> </li> <li>Generate reports for validation results</li> <li>Archive validation reports as artifacts</li> <li> <p>Create dashboards to track violation trends</p> </li> <li> <p>Non-Blocking Modes:</p> </li> <li>Use monitoring mode for new policies before enforcing</li> <li>Consider warning vs. blocking based on severity</li> <li> <p>Implement notification channels for different severities</p> </li> <li> <p>Policy Testing:</p> </li> <li>Create test cases for policies with known-good and known-bad plans</li> <li>Validate that policies detect what they should</li> <li> <p>Test policy changes before deploying them</p> </li> <li> <p>Integration with Compliance:</p> </li> <li>Send validation results to compliance systems</li> <li>Generate evidence for audit requirements</li> <li>Track exceptions and approvals</li> </ol>"},{"location":"advanced/ci-cd-integration/#example-complete-cicd-workflow-for-agent-plans","title":"Example: Complete CI/CD Workflow for Agent Plans","text":"<p>A complete workflow might include:</p> <ol> <li>Develop:</li> <li>Author agent plans</li> <li>Run local validation with dev policies</li> <li> <p>Commit to feature branch</p> </li> <li> <p>Build:</p> </li> <li>Trigger CI pipeline</li> <li>Validate against development policies</li> <li> <p>Run unit tests for plans</p> </li> <li> <p>Test:</p> </li> <li>Deploy to test environment</li> <li>Run integration tests</li> <li> <p>Validate against staging policies</p> </li> <li> <p>Deploy:</p> </li> <li>Request approval if needed</li> <li>Validate against production policies</li> <li> <p>Deploy to production</p> </li> <li> <p>Monitor:</p> </li> <li>Collect runtime metrics</li> <li>Validate plans periodically</li> <li>Alert on policy violations</li> </ol> <p>By integrating Plan-Lint into your CI/CD pipelines, you ensure that agent plans adhere to security and compliance requirements before they reach production, reducing risk and increasing confidence in automated systems.</p>"},{"location":"advanced/contributing/","title":"Contributing","text":"<p>This guide explains how to contribute to the Plan-Lint project.</p>"},{"location":"advanced/contributing/#why-contribute","title":"Why Contribute?","text":"<p>Contributing to Plan-Lint helps: - Improve security of AI agent systems - Add new validation capabilities - Fix bugs and enhance existing features - Share your expertise with the community - Shape the future of agent safety</p>"},{"location":"advanced/contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to Plan-Lint:</p> <ol> <li>Report Issues: Report bugs, request features, or suggest improvements</li> <li>Improve Documentation: Fix errors, add examples, or clarify explanations</li> <li>Develop Code: Add features, fix bugs, or improve performance</li> <li>Share Policies: Contribute policy examples for specific use cases</li> <li>Spread the Word: Share your experience with Plan-Lint</li> </ol>"},{"location":"advanced/contributing/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"advanced/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or later</li> <li>Git</li> <li>A GitHub account</li> </ul>"},{"location":"advanced/contributing/#clone-and-set-up-the-repository","title":"Clone and Set Up the Repository","text":"<pre><code># Clone the repository\ngit clone https://github.com/yourusername/plan-lint.git\ncd plan-lint\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install development dependencies\npip install -e \".[dev]\"\n</code></pre>"},{"location":"advanced/contributing/#run-tests","title":"Run Tests","text":"<pre><code># Run unit tests\npytest\n\n# Run with coverage\npytest --cov=plan_lint tests/\n</code></pre>"},{"location":"advanced/contributing/#contribution-workflow","title":"Contribution Workflow","text":""},{"location":"advanced/contributing/#1-choose-an-issue","title":"1. Choose an Issue","text":"<ul> <li>Browse the issue tracker</li> <li>Look for issues labeled <code>good first issue</code> if you're new</li> <li>Comment on an issue to indicate you're working on it</li> </ul>"},{"location":"advanced/contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code># Update your main branch\ngit checkout main\ngit pull origin main\n\n# Create a new branch\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"advanced/contributing/#3-make-changes","title":"3. Make Changes","text":"<ul> <li>Write code following the style guidelines</li> <li>Add tests for new features</li> <li>Update documentation as needed</li> </ul>"},{"location":"advanced/contributing/#4-test-your-changes","title":"4. Test Your Changes","text":"<pre><code># Run tests to ensure everything works\npytest\n</code></pre>"},{"location":"advanced/contributing/#5-submit-a-pull-request","title":"5. Submit a Pull Request","text":"<pre><code># Push your branch to your fork\ngit push origin feature/your-feature-name\n</code></pre> <p>Then create a Pull Request on GitHub: 1. Go to the original repository 2. Click \"New Pull Request\" 3. Select your branch 4. Fill in the Pull Request template</p>"},{"location":"advanced/contributing/#code-style-guidelines","title":"Code Style Guidelines","text":"<p>Plan-Lint follows these style guidelines:</p> <ul> <li>PEP 8: Follow Python's style guide</li> <li>Type Hints: Use type hints for function parameters and return values</li> <li>Docstrings: Document classes and functions with docstrings</li> <li>Commit Messages: Write clear, concise commit messages</li> </ul> <p>We use the following tools to enforce style:</p> <pre><code># Run code formatters\nblack plan_lint tests\n\n# Run linters\nflake8 plan_lint tests\nmypy plan_lint\n</code></pre>"},{"location":"advanced/contributing/#adding-new-features","title":"Adding New Features","text":""},{"location":"advanced/contributing/#new-validators","title":"New Validators","text":"<p>To add a new validator:</p> <ol> <li>Create a new file in <code>plan_lint/validators/</code></li> <li>Implement the validator class extending <code>BaseValidator</code></li> <li>Register your validator in <code>plan_lint/validators/__init__.py</code></li> <li>Add tests in <code>tests/validators/</code></li> <li>Update documentation in <code>docs/</code></li> </ol> <p>Example validator structure:</p> <pre><code>from plan_lint.validators.base import BaseValidator, ValidationResult\n\nclass MyCustomValidator(BaseValidator):\n    \"\"\"Validator that checks for my custom condition.\"\"\"\n\n    def validate(self, plan, context=None):\n        \"\"\"Validate the plan.\"\"\"\n        violations = []\n\n        # Implement validation logic\n        for step in plan.get(\"steps\", []):\n            if self._check_violation(step):\n                violations.append({\n                    \"rule\": \"my_custom_rule\",\n                    \"message\": \"Description of the violation\",\n                    \"severity\": \"medium\",\n                    \"step_id\": step.get(\"id\")\n                })\n\n        return ValidationResult(violations)\n\n    def _check_violation(self, step):\n        \"\"\"Helper method to check for violations.\"\"\"\n        # Implement check logic\n        return False\n</code></pre>"},{"location":"advanced/contributing/#new-rule-types","title":"New Rule Types","text":"<p>To add a new rule type:</p> <ol> <li>Update <code>plan_lint/rules/</code></li> <li>Add parser and validation logic</li> <li>Update the schema in <code>plan_lint/schemas/</code></li> <li>Add tests in <code>tests/rules/</code></li> <li>Update documentation with examples</li> </ol>"},{"location":"advanced/contributing/#writing-tests","title":"Writing Tests","text":"<p>Plan-Lint uses pytest for testing. Follow these guidelines:</p> <ul> <li>Test each feature and edge case</li> <li>Use fixtures for reusable test data</li> <li>Structure tests following the project's organization</li> <li>Name tests descriptively (<code>test_should_detect_sql_injection</code>)</li> </ul> <p>Example test:</p> <pre><code>import pytest\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n@pytest.fixture\ndef vulnerable_plan():\n    return {\n        \"steps\": [\n            {\n                \"id\": \"step1\",\n                \"tool\": \"db.query\",\n                \"parameters\": {\n                    \"query\": \"SELECT * FROM users WHERE username = 'admin' OR 1=1\"\n                }\n            }\n        ]\n    }\n\ndef test_should_detect_sql_injection(vulnerable_plan):\n    policy = load_policy(\"tests/fixtures/sql_injection_policy.yaml\")\n    result = validate_plan(vulnerable_plan, policy)\n\n    assert not result.is_valid\n    assert len(result.violations) == 1\n    assert result.violations[0].rule == \"sql_injection\"\n</code></pre>"},{"location":"advanced/contributing/#updating-documentation","title":"Updating Documentation","text":"<p>Documentation is crucial for Plan-Lint. When making changes:</p> <ol> <li>Update relevant documentation files in <code>docs/</code></li> <li>Add examples for new features</li> <li>Ensure code examples work correctly</li> <li>Check for clarity and correctness</li> </ol>"},{"location":"advanced/contributing/#release-process","title":"Release Process","text":"<p>The release process follows these steps:</p> <ol> <li>Update version in <code>setup.py</code> and <code>plan_lint/__init__.py</code></li> <li>Update <code>CHANGELOG.md</code> with new changes</li> <li>Create a pull request for the release</li> <li>After approval, merge to main</li> <li>Create a new release on GitHub</li> <li>CI/CD will publish to PyPI</li> </ol>"},{"location":"advanced/contributing/#community-guidelines","title":"Community Guidelines","text":"<p>When contributing to Plan-Lint:</p> <ul> <li>Be respectful and inclusive</li> <li>Provide constructive feedback</li> <li>Help others with their contributions</li> <li>Follow the code of conduct</li> </ul>"},{"location":"advanced/contributing/#getting-help","title":"Getting Help","text":"<p>If you need help with your contribution:</p> <ul> <li>Ask questions in the issue you're working on</li> <li>Join the community discussion forum</li> <li>Check existing documentation and examples</li> </ul> <p>Thank you for contributing to Plan-Lint! Your efforts help make AI agent systems safer and more secure. </p>"},{"location":"advanced/enterprise-deployment/","title":"Enterprise Deployment","text":"<p>This guide provides strategies and best practices for deploying Plan-Lint in enterprise environments.</p>"},{"location":"advanced/enterprise-deployment/#enterprise-deployment-considerations","title":"Enterprise Deployment Considerations","text":"<p>Deploying Plan-Lint in enterprise environments requires attention to:</p> <ol> <li>Scalability: Supporting validation across multiple teams and systems</li> <li>Security: Ensuring policy enforcement and proper access controls</li> <li>Integration: Connecting with existing enterprise systems and workflows</li> <li>Governance: Establishing policy management and compliance processes</li> <li>Observability: Monitoring and managing the validation ecosystem</li> </ol>"},{"location":"advanced/enterprise-deployment/#deployment-architectures","title":"Deployment Architectures","text":""},{"location":"advanced/enterprise-deployment/#centralized-architecture","title":"Centralized Architecture","text":"<p>A centralized deployment model provides a single source of truth for policies and validations:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502\n\u2502  Policy Authors   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy Repository  \u2502\n\u2502                   \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502\n\u2502  Agent Systems    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Validation Service \u2502\n\u2502                   \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502\n\u2502  Security Team    \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502  Audit &amp; Reports    \u2502\n\u2502                   \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits: - Single source of truth for policies - Consistent enforcement across the organization - Centralized monitoring and reporting - Easy to update policies organization-wide</p>"},{"location":"advanced/enterprise-deployment/#federated-architecture","title":"Federated Architecture","text":"<p>A federated deployment allows teams to manage their own policies within governance guardrails:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502\n\u2502  Global Policies  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy Registry    \u2502\n\u2502                   \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n                                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502  Team A Policies  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Team A Validator   \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502  Team A Systems     \u2502\n\u2502                   \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502  Team B Policies  \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Team B Validator   \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502  Team B Systems     \u2502\n\u2502                   \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Benefits: - Local autonomy for teams - Ability to customize policies for specific use cases - Reduced central bottleneck - Isolation for sensitive domains</p>"},{"location":"advanced/enterprise-deployment/#installation-methods","title":"Installation Methods","text":""},{"location":"advanced/enterprise-deployment/#enterprise-package-distribution","title":"Enterprise Package Distribution","text":"<p>For controlled distribution and versioning:</p> <pre><code># Create an enterprise distribution package\npython -m build\n\n# Install via private PyPI server\npip install plan-lint --index-url https://pypi.internal.company.com/simple\n\n# Install from artifact repository\npip install plan-lint-1.0.0-py3-none-any.whl\n</code></pre>"},{"location":"advanced/enterprise-deployment/#docker-based-deployment","title":"Docker-based Deployment","text":"<p>For containerized environments:</p> <pre><code># Base image with Plan-Lint\nFROM python:3.9-slim\n\n# Install Plan-Lint\nRUN pip install plan-lint==1.0.0\n\n# Add enterprise policies\nCOPY ./enterprise-policies /opt/plan-lint/policies\n\n# Set default policy path\nENV PLAN_LINT_POLICY_PATH=/opt/plan-lint/policies/enterprise.yaml\n\n# Create validation service\nCOPY ./validation-service /app\nWORKDIR /app\n\n# Run service\nCMD [\"python\", \"validation_service.py\"]\n</code></pre>"},{"location":"advanced/enterprise-deployment/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<p>For scalable, resilient deployments:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: plan-lint-validator\n  namespace: security\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: plan-lint-validator\n  template:\n    metadata:\n      labels:\n        app: plan-lint-validator\n    spec:\n      containers:\n      - name: validator\n        image: company-registry.com/plan-lint:1.0.0\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"1000m\"\n        env:\n        - name: PLAN_LINT_POLICY_PATH\n          value: \"/etc/planlint/policies\"\n        volumeMounts:\n        - name: policy-volume\n          mountPath: /etc/planlint/policies\n          readOnly: true\n      volumes:\n      - name: policy-volume\n        configMap:\n          name: plan-lint-policies\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: plan-lint-validator\n  namespace: security\nspec:\n  selector:\n    app: plan-lint-validator\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: ClusterIP\n</code></pre>"},{"location":"advanced/enterprise-deployment/#policy-management","title":"Policy Management","text":""},{"location":"advanced/enterprise-deployment/#policy-as-code","title":"Policy-as-Code","text":"<p>Implement Policy-as-Code practices for enterprise governance:</p> <pre><code># Organization structure for enterprise policies\npolicies/\n  base/\n    core-security.yaml     # Base security policies for all\n  domains/\n    finance/               # Finance-specific policies\n      transactions.yaml\n      sensitive-data.yaml\n    healthcare/            # Healthcare-specific policies\n      hipaa.yaml\n      patient-data.yaml\n  environments/\n    production.yaml        # Production-only rules\n    development.yaml       # Development exceptions\n</code></pre>"},{"location":"advanced/enterprise-deployment/#versioning-and-distribution","title":"Versioning and Distribution","text":"<p>Version and distribute policies through CI/CD:</p> <pre><code># .gitlab-ci.yml example\nstages:\n  - lint\n  - test\n  - build\n  - deploy\n\npolicy-lint:\n  stage: lint\n  script:\n    - plan-lint lint --policy-dir policies/\n\npolicy-test:\n  stage: test\n  script:\n    - plan-lint test-policies --policy-dir policies/ --test-dir policy-tests/\n\npolicy-bundle:\n  stage: build\n  script:\n    - plan-lint bundle --policy-dir policies/ --output policy-bundle.tar.gz\n  artifacts:\n    paths:\n      - policy-bundle.tar.gz\n\ndeploy-policies:\n  stage: deploy\n  script:\n    - aws s3 cp policy-bundle.tar.gz s3://company-policies/plan-lint/\n    - kubectl create configmap plan-lint-policies --from-file=policies/ -o yaml --dry-run=client | kubectl apply -f -\n</code></pre>"},{"location":"advanced/enterprise-deployment/#policy-inheritance-and-composition","title":"Policy Inheritance and Composition","text":"<p>Implement policy hierarchy for maintainability:</p> <pre><code># Base policy with common rules\n# base.yaml\npolicies:\n  - name: base\n    rules:\n      - rule: prevent_sql_injection\n        severity: critical\n        description: \"Prevents SQL injection attacks\"\n        pattern:\n          tool: db.query\n          operation: matches\n          value: \"'; DROP TABLE|1=1|--\"\n\n# Team policy extending base\n# team-finance.yaml\nextends:\n  - base.yaml\npolicies:\n  - name: finance\n    rules:\n      - rule: check_transaction_limits\n        severity: high\n        description: \"Ensures transactions are within limits\"\n        pattern:\n          tool: payments.transfer\n          operation: amount_gt\n          value: 10000\n</code></pre>"},{"location":"advanced/enterprise-deployment/#security-compliance","title":"Security &amp; Compliance","text":""},{"location":"advanced/enterprise-deployment/#role-based-access-control","title":"Role-Based Access Control","text":"<p>Implement RBAC for policy management:</p> <pre><code># RBAC configuration\nroles:\n  policy_admin:\n    description: \"Full access to policy management\"\n    permissions:\n      - create_policy\n      - read_policy\n      - update_policy\n      - delete_policy\n      - apply_policy\n\n  policy_viewer:\n    description: \"Can view policies but not modify\"\n    permissions:\n      - read_policy\n\n  validator:\n    description: \"Can validate plans against policies\"\n    permissions:\n      - read_policy\n      - validate_plan\n</code></pre>"},{"location":"advanced/enterprise-deployment/#policy-signing","title":"Policy Signing","text":"<p>Implement policy signing for integrity:</p> <pre><code>from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.serialization import load_pem_private_key\n\ndef sign_policy(policy_path, private_key_path, password=None):\n    # Load policy\n    with open(policy_path, 'rb') as f:\n        policy_data = f.read()\n\n    # Load private key\n    with open(private_key_path, 'rb') as key_file:\n        private_key = load_pem_private_key(\n            key_file.read(),\n            password=password.encode() if password else None\n        )\n\n    # Sign policy\n    signature = private_key.sign(\n        policy_data,\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n\n    # Save signature\n    signature_path = f\"{policy_path}.sig\"\n    with open(signature_path, 'wb') as f:\n        f.write(signature)\n\n    return signature_path\n</code></pre>"},{"location":"advanced/enterprise-deployment/#audit-logging","title":"Audit Logging","text":"<p>Implement comprehensive audit logging:</p> <pre><code>import logging\nimport json\nfrom datetime import datetime\n\n# Configure structured logging\nlogger = logging.getLogger(\"plan_lint.audit\")\nlogger.setLevel(logging.INFO)\n\n# Add handler for audit logs\nhandler = logging.FileHandler(\"/var/log/plan-lint/audit.log\")\nhandler.setFormatter(logging.Formatter('%(message)s'))\nlogger.addHandler(handler)\n\ndef audit_validation(plan_id, policy_id, user, result):\n    \"\"\"Log an audit entry for plan validation.\"\"\"\n    audit_entry = {\n        \"timestamp\": datetime.utcnow().isoformat(),\n        \"action\": \"validate_plan\",\n        \"plan_id\": plan_id,\n        \"policy_id\": policy_id,\n        \"user\": user,\n        \"result\": {\n            \"is_valid\": result.is_valid,\n            \"violation_count\": len(result.violations),\n            \"violations\": [v.to_dict() for v in result.violations]\n        }\n    }\n    logger.info(json.dumps(audit_entry))\n</code></pre>"},{"location":"advanced/enterprise-deployment/#integration-with-enterprise-systems","title":"Integration with Enterprise Systems","text":""},{"location":"advanced/enterprise-deployment/#identity-access-management","title":"Identity &amp; Access Management","text":"<p>Integrate with enterprise IAM solutions:</p> <pre><code>from flask import Flask, request, jsonify\nimport requests\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\napp = Flask(__name__)\n\n# Load policy\npolicy = load_policy(\"enterprise-policy.yaml\")\n\ndef verify_token(token):\n    \"\"\"Verify JWT token with enterprise IAM.\"\"\"\n    response = requests.get(\n        \"https://auth.company.com/verify\",\n        headers={\"Authorization\": f\"Bearer {token}\"}\n    )\n    if response.status_code == 200:\n        return response.json()\n    return None\n\n@app.route('/validate', methods=['POST'])\ndef validate():\n    # Get auth token\n    token = request.headers.get('Authorization', '').replace('Bearer ', '')\n\n    # Verify token\n    user_info = verify_token(token)\n    if not user_info:\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Check permissions\n    if \"validate_plan\" not in user_info.get(\"permissions\", []):\n        return jsonify({\"error\": \"Forbidden\"}), 403\n\n    # Get plan from request\n    plan_data = request.json\n\n    # Validate plan\n    result = validate_plan(plan_data, policy)\n\n    # Log validation for audit\n    audit_validation(\n        plan_id=plan_data.get(\"id\", \"unknown\"),\n        policy_id=\"enterprise-policy\",\n        user=user_info[\"username\"],\n        result=result\n    )\n\n    # Return result\n    return jsonify({\n        \"is_valid\": result.is_valid,\n        \"violations\": [v.to_dict() for v in result.violations]\n    })\n</code></pre>"},{"location":"advanced/enterprise-deployment/#siem-integration","title":"SIEM Integration","text":"<p>Forward validation results to enterprise SIEM systems:</p> <pre><code>import json\nimport socket\nfrom plan_lint import validate_plan\n\ndef send_to_siem(event):\n    \"\"\"Send event to SIEM system via syslog.\"\"\"\n    syslog_host = \"siem.company.com\"\n    syslog_port = 514\n\n    # Format as CEF (Common Event Format)\n    cef_event = (\n        f\"CEF:0|PlanLint|Validator|1.0|{event['rule']}|{event['message']}|\"\n        f\"{event['severity']}|planId={event['plan_id']} stepId={event['step_id']}\"\n    )\n\n    # Send via syslog\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.sendto(cef_event.encode(), (syslog_host, syslog_port))\n    sock.close()\n\ndef validate_with_siem(plan, policy):\n    \"\"\"Validate plan and send violations to SIEM.\"\"\"\n    result = validate_plan(plan, policy)\n\n    if not result.is_valid:\n        for violation in result.violations:\n            # Create event for SIEM\n            event = {\n                \"rule\": violation.rule,\n                \"message\": violation.message,\n                \"severity\": violation.severity,\n                \"plan_id\": plan.get(\"id\", \"unknown\"),\n                \"step_id\": violation.step_id\n            }\n\n            # Send to SIEM\n            send_to_siem(event)\n\n    return result\n</code></pre>"},{"location":"advanced/enterprise-deployment/#cicd-integration","title":"CI/CD Integration","text":"<p>Integrate Plan-Lint into enterprise CI/CD pipelines:</p> <pre><code># GitHub Actions workflow example\nname: Agent Plan Validation\n\non:\n  push:\n    branches: [ main ]\n    paths:\n      - 'agent/plans/**'\n  pull_request:\n    branches: [ main ]\n    paths:\n      - 'agent/plans/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n\n      - name: Fetch policies\n        run: |\n          # Pull policies from secure storage\n          aws s3 cp s3://company-policies/plan-lint/policy-bundle.tar.gz .\n          tar -xzf policy-bundle.tar.gz\n\n      - name: Validate plans\n        run: |\n          plan-lint validate-batch \\\n            --plans-dir agent/plans/ \\\n            --policy-dir policies/ \\\n            --report-format json \\\n            --output validation-report.json\n\n      - name: Check for violations\n        run: |\n          python -c \"\n          import json\n          with open('validation-report.json') as f:\n              report = json.load(f)\n          critical_violations = 0\n          for plan_result in report.values():\n              for violation in plan_result['violations']:\n                  if violation['severity'] == 'critical':\n                      critical_violations += 1\n          exit(1 if critical_violations &gt; 0 else 0)\n          \"\n\n      - name: Upload report as artifact\n        uses: actions/upload-artifact@v2\n        with:\n          name: validation-report\n          path: validation-report.json\n</code></pre>"},{"location":"advanced/enterprise-deployment/#high-availability-disaster-recovery","title":"High Availability &amp; Disaster Recovery","text":""},{"location":"advanced/enterprise-deployment/#redundant-deployment","title":"Redundant Deployment","text":"<p>Implement redundancy for critical environments:</p> <pre><code># Kubernetes StatefulSet for HA deployment\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: plan-lint-validator\n  namespace: security\nspec:\n  serviceName: \"plan-lint-validator\"\n  replicas: 3\n  selector:\n    matchLabels:\n      app: plan-lint-validator\n  template:\n    metadata:\n      labels:\n        app: plan-lint-validator\n    spec:\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: app\n                    operator: In\n                    values:\n                      - plan-lint-validator\n              topologyKey: \"kubernetes.io/hostname\"\n      containers:\n      - name: validator\n        image: company-registry.com/plan-lint:1.0.0\n        volumeMounts:\n        - name: policy-storage\n          mountPath: /etc/planlint/policies\n  volumeClaimTemplates:\n  - metadata:\n      name: policy-storage\n    spec:\n      accessModes: [ \"ReadWriteOnce\" ]\n      resources:\n        requests:\n          storage: 1Gi\n</code></pre>"},{"location":"advanced/enterprise-deployment/#backup-recovery","title":"Backup &amp; Recovery","text":"<p>Implement policy backup and recovery:</p> <pre><code>#!/bin/bash\n# policy-backup.sh\n\n# Set variables\nBACKUP_DIR=\"/mnt/backups/plan-lint\"\nPOLICY_DIR=\"/etc/planlint/policies\"\nDATE=$(date +%Y%m%d-%H%M%S)\nBACKUP_FILE=\"$BACKUP_DIR/policy-backup-$DATE.tar.gz\"\n\n# Create backup directory if it doesn't exist\nmkdir -p $BACKUP_DIR\n\n# Create backup\ntar -czf $BACKUP_FILE $POLICY_DIR\n\n# Rotate backups (keep last 10)\nls -t $BACKUP_DIR/policy-backup-*.tar.gz | tail -n +11 | xargs rm -f\n\n# Store metadata\necho \"{\\\"timestamp\\\": \\\"$DATE\\\", \\\"file\\\": \\\"$BACKUP_FILE\\\", \\\"size\\\": $(stat -c%s $BACKUP_FILE)}\" &gt; $BACKUP_DIR/latest-backup.json\n\n# Optional: Send to remote storage\naws s3 cp $BACKUP_FILE s3://company-backups/plan-lint/\n</code></pre>"},{"location":"advanced/enterprise-deployment/#monitoring-observability","title":"Monitoring &amp; Observability","text":""},{"location":"advanced/enterprise-deployment/#metrics-for-enterprise-monitoring","title":"Metrics for Enterprise Monitoring","text":"<p>Expose comprehensive metrics:</p> <pre><code>from prometheus_client import Counter, Histogram, Gauge, Summary, start_http_server\nimport time\n\n# Define metrics\nVALIDATION_COUNT = Counter(\n    'plan_lint_validations_total', \n    'Total number of validations',\n    ['team', 'environment']\n)\n\nVIOLATION_COUNT = Counter(\n    'plan_lint_violations_total', \n    'Total number of violations', \n    ['rule', 'severity', 'team']\n)\n\nVALIDATION_TIME = Histogram(\n    'plan_lint_validation_seconds', \n    'Time spent validating plans',\n    ['plan_size', 'policy_size']\n)\n\nPOLICY_RULES = Gauge(\n    'plan_lint_policy_rules', \n    'Number of rules in policy',\n    ['policy']\n)\n\nVALIDATION_ERRORS = Counter(\n    'plan_lint_validation_errors_total', \n    'Total number of validation errors',\n    ['error_type']\n)\n\n# Start metrics server\nstart_http_server(8000)\n</code></pre>"},{"location":"advanced/enterprise-deployment/#health-checks","title":"Health Checks","text":"<p>Implement comprehensive health checks:</p> <pre><code>from flask import Flask, jsonify\nimport os\nimport json\nimport psutil\nimport yaml\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Basic health check.\"\"\"\n    return jsonify({\"status\": \"healthy\"})\n\n@app.route('/health/ready')\ndef readiness_check():\n    \"\"\"Readiness check with policy verification.\"\"\"\n    try:\n        # Check policy files\n        policy_dir = os.environ.get(\"PLAN_LINT_POLICY_PATH\", \"/etc/planlint/policies\")\n        policy_files = [f for f in os.listdir(policy_dir) if f.endswith(('.yaml', '.yml'))]\n\n        # Check if we can parse a policy\n        if policy_files:\n            with open(os.path.join(policy_dir, policy_files[0])) as f:\n                yaml.safe_load(f)\n\n        # Check system resources\n        system_metrics = {\n            \"memory_percent\": psutil.virtual_memory().percent,\n            \"cpu_percent\": psutil.cpu_percent(interval=0.1),\n            \"disk_percent\": psutil.disk_usage('/').percent\n        }\n\n        # Ready if resources are available\n        is_ready = (\n            system_metrics[\"memory_percent\"] &lt; 90 and\n            system_metrics[\"cpu_percent\"] &lt; 90 and\n            system_metrics[\"disk_percent\"] &lt; 90\n        )\n\n        return jsonify({\n            \"status\": \"ready\" if is_ready else \"not_ready\",\n            \"policy_count\": len(policy_files),\n            \"system_metrics\": system_metrics\n        })\n    except Exception as e:\n        return jsonify({\n            \"status\": \"not_ready\",\n            \"error\": str(e)\n        }), 503\n\n@app.route('/health/deep')\ndef deep_health_check():\n    \"\"\"Deep health check with policy validation test.\"\"\"\n    try:\n        # Run a test validation\n        from plan_lint import validate_plan\n        from plan_lint.loader import load_policy\n\n        # Test plan\n        test_plan = {\n            \"goal\": \"health check\",\n            \"steps\": [\n                {\n                    \"id\": \"step1\",\n                    \"tool\": \"health.check\",\n                    \"parameters\": {}\n                }\n            ]\n        }\n\n        # Load and validate against default policy\n        policy_path = os.environ.get(\"PLAN_LINT_POLICY_PATH\", \"/etc/planlint/policies\")\n        if os.path.isdir(policy_path):\n            policy_files = [f for f in os.listdir(policy_path) if f.endswith(('.yaml', '.yml'))]\n            if policy_files:\n                policy_path = os.path.join(policy_path, policy_files[0])\n\n        policy = load_policy(policy_path)\n        result = validate_plan(test_plan, policy)\n\n        return jsonify({\n            \"status\": \"healthy\",\n            \"policy_validation_works\": True,\n            \"policy_path\": policy_path\n        })\n    except Exception as e:\n        return jsonify({\n            \"status\": \"unhealthy\",\n            \"error\": str(e)\n        }), 503\n</code></pre>"},{"location":"advanced/enterprise-deployment/#enterprise-best-practices","title":"Enterprise Best Practices","text":"<ol> <li>Policy Governance:</li> <li>Establish a policy review and approval process</li> <li>Document policy rationale and scope</li> <li>Perform regular policy audits</li> <li> <p>Monitor policy effectiveness metrics</p> </li> <li> <p>Deployment Strategy:</p> </li> <li>Implement canary deployments for policy updates</li> <li>Use blue/green deployments for validator service</li> <li>Gradually roll out policy changes to minimize disruption</li> <li> <p>Create policy simulation environments</p> </li> <li> <p>Security Hardening:</p> </li> <li>Run validators with minimal permissions</li> <li>Use secure communication channels (mTLS)</li> <li>Encrypt sensitive data in transit and at rest</li> <li> <p>Implement strict network policies for validator services</p> </li> <li> <p>Performance at Scale:</p> </li> <li>Use caching to reduce validation overhead</li> <li>Implement horizontal scaling based on validation load</li> <li>Optimize policy evaluation with proper rule ordering</li> <li> <p>Use distributed processing for large-scale validation</p> </li> <li> <p>Compliance &amp; Reporting:</p> </li> <li>Generate compliance reports for regulatory requirements</li> <li>Track policy exceptions and approvals</li> <li>Maintain validation audit trails for compliance evidence</li> <li>Create dashboards for policy effectiveness</li> </ol>"},{"location":"advanced/enterprise-deployment/#sample-enterprise-architecture","title":"Sample Enterprise Architecture","text":"<p>For large enterprises, a complete architecture might include:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502  Policy Authoring   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy Registry    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Policy CI/CD       \u2502\n\u2502  &amp; Management UI    \u2502      \u2502  (Version Control)  \u2502      \u2502                     \u2502\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                                     \u2502\n                                                                     \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502  Validation Service \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502  Policy Distributor \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2502  Policy Bundles     \u2502\n\u2502  (HA Cluster)       \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u2502\n          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2502  Agent Systems      \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Results Database   \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Analytics &amp;        \u2502\n\u2502                     \u2502      \u2502                     \u2502      \u2502  Dashboards         \u2502\n\u2502                     \u2502      \u2502                     \u2502      \u2502                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n                                      \u25bc\n                             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                             \u2502                     \u2502      \u2502                     \u2502\n                             \u2502  Enterprise SIEM    \u2502\u2500\u2500\u2500\u2500\u2500\u25b6\u2502  Security Response  \u2502\n                             \u2502                     \u2502      \u2502  Team               \u2502\n                             \u2502                     \u2502      \u2502                     \u2502\n                             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>By following these enterprise deployment practices, organizations can successfully integrate Plan-Lint into their security and governance frameworks, ensuring that agent plans adhere to corporate policies and regulatory requirements. </p>"},{"location":"advanced/opa-integration/","title":"OPA Integration","text":"<p>This page explains how to integrate Plan-Lint with the Open Policy Agent (OPA) for advanced policy enforcement.</p>"},{"location":"advanced/opa-integration/#what-is-opa","title":"What is OPA?","text":"<p>Open Policy Agent (OPA) is an open-source, general-purpose policy engine that enables unified policy enforcement across the stack. OPA provides a high-level declarative language called Rego for expressing policies.</p> <p>Plan-Lint leverages OPA to provide powerful policy validation capabilities for agent plans.</p>"},{"location":"advanced/opa-integration/#benefits-of-opa-integration","title":"Benefits of OPA Integration","text":"<p>Integrating Plan-Lint with OPA offers several advantages:</p> <ol> <li>Powerful Policy Expression: Rego is a purpose-built language for policy that can express complex validation rules</li> <li>Separation of Concerns: Keep policy logic separate from your application code</li> <li>Consistent Enforcement: Apply the same policies across different environments and systems</li> <li>Scalability: OPA is designed for high-performance policy evaluation</li> <li>Ecosystem: Benefit from OPA's tooling, documentation, and community</li> </ol>"},{"location":"advanced/opa-integration/#setup-opa-for-plan-lint","title":"Setup OPA for Plan-Lint","text":"<p>To use OPA with Plan-Lint, you need to install OPA:</p>"},{"location":"advanced/opa-integration/#local-installation","title":"Local Installation","text":"<pre><code># Download OPA binary\ncurl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64\nchmod +x opa\nsudo mv opa /usr/local/bin/\n\n# Verify the installation\nopa version\n</code></pre>"},{"location":"advanced/opa-integration/#docker-installation","title":"Docker Installation","text":"<pre><code>docker pull openpolicyagent/opa:latest\n</code></pre>"},{"location":"advanced/opa-integration/#python-opa-client-installation","title":"Python OPA Client Installation","text":"<p>Plan-Lint includes the necessary OPA client, but if you want to use it directly:</p> <pre><code>pip install opa-python\n</code></pre>"},{"location":"advanced/opa-integration/#writing-rego-policies-for-plan-lint","title":"Writing Rego Policies for Plan-Lint","text":"<p>Rego policies for Plan-Lint should be organized under the <code>planlint</code> package.</p>"},{"location":"advanced/opa-integration/#basic-policy-structure","title":"Basic Policy Structure","text":"<pre><code># basic.rego\npackage planlint\n\nimport future.keywords.in\n\n# Default deny\ndefault allow = false\n\n# Allow if no violations found\nallow {\n    count(violations) == 0\n}\n\n# Define violations\nviolations[result] {\n    # Get a step from the plan\n    step := input.plan.steps[_]\n\n    # Example validation: Check if tool is allowed\n    not step.tool in [\"db.query_ro\", \"notify.email\"]\n\n    # Create a violation result\n    result := {\n        \"rule\": \"unauthorized_tool\",\n        \"message\": sprintf(\"Tool '%s' is not allowed\", [step.tool]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n</code></pre>"},{"location":"advanced/opa-integration/#input-structure","title":"Input Structure","text":"<p>When Plan-Lint sends a plan to OPA for validation, it provides the following input structure:</p> <pre><code>{\n  \"plan\": {\n    \"goal\": \"Plan goal\",\n    \"steps\": [\n      {\n        \"id\": \"step1\",\n        \"tool\": \"db.query_ro\",\n        \"parameters\": {...}\n      },\n      ...\n    ],\n    \"context\": {...}\n  },\n  \"context\": {\n    // Additional context provided during validation\n    \"user_role\": \"admin\",\n    \"environment\": \"production\",\n    ...\n  }\n}\n</code></pre>"},{"location":"advanced/opa-integration/#accessing-plan-data-in-rego","title":"Accessing Plan Data in Rego","text":"<pre><code># Access plan steps\nstep := input.plan.steps[_]\n\n# Access step parameters\nquery := step.parameters.query\n\n# Access plan context\nuser_role := input.context.user_role\n</code></pre>"},{"location":"advanced/opa-integration/#using-opa-with-plan-lint","title":"Using OPA with Plan-Lint","text":""},{"location":"advanced/opa-integration/#command-line","title":"Command Line","text":"<p>To validate a plan with a Rego policy:</p> <pre><code>plan-lint validate --plan plan.json --policy policy.rego --use-opa\n</code></pre>"},{"location":"advanced/opa-integration/#programmatic-usage","title":"Programmatic Usage","text":"<pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\n\n# Load plan and policy\nplan = load_plan(\"plan.json\")\npolicy, rego_policy = load_policy(\"policy.rego\")\n\n# Validate with OPA\nresult = validate_plan(\n    plan,\n    policy,\n    rego_policy=rego_policy,\n    use_opa=True,\n    context={\"user_role\": \"admin\"}\n)\n</code></pre>"},{"location":"advanced/opa-integration/#advanced-rego-policy-examples","title":"Advanced Rego Policy Examples","text":""},{"location":"advanced/opa-integration/#role-based-access-control","title":"Role-Based Access Control","text":"<pre><code>package planlint\n\nimport future.keywords.in\n\n# Define role permissions\nrole_permissions := {\n    \"admin\": {\n        \"db.query\": true,\n        \"db.write\": true,\n        \"payments.transfer\": true,\n        \"system.configure\": true\n    },\n    \"operator\": {\n        \"db.query\": true,\n        \"db.query_ro\": true,\n        \"payments.transfer\": true\n    },\n    \"viewer\": {\n        \"db.query_ro\": true\n    }\n}\n\n# Tool permission check\nviolations[result] {\n    # Get user role\n    role := input.context.user_role\n\n    # Get step\n    step := input.plan.steps[i]\n\n    # Get permissions for this role\n    permissions := role_permissions[role]\n\n    # Check if tool is allowed\n    not step.tool in keys(permissions)\n\n    result := {\n        \"rule\": \"role_authorization\",\n        \"message\": sprintf(\"User with role '%s' is not authorized to use tool '%s'\", [role, step.tool]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n</code></pre>"},{"location":"advanced/opa-integration/#dependency-validation","title":"Dependency Validation","text":"<pre><code>package planlint\n\n# Validate step dependencies\nviolations[result] {\n    # Get step with dependencies\n    step := input.plan.steps[i]\n    step.depends_on\n\n    # Check if any dependency is missing\n    some dep in step.depends_on\n\n    # Get all step IDs\n    step_ids := {s.id | s := input.plan.steps[_]}\n\n    # Check if dependency exists\n    not dep in step_ids\n\n    result := {\n        \"rule\": \"missing_dependency\",\n        \"message\": sprintf(\"Step '%s' depends on non-existent step '%s'\", [step.id, dep]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n\n# Detect circular dependencies\nviolations[result] {\n    # Get a step\n    step := input.plan.steps[i]\n\n    # Check if it depends on itself (directly or indirectly)\n    depends_on_self(step.id, step.depends_on)\n\n    result := {\n        \"rule\": \"circular_dependency\",\n        \"message\": sprintf(\"Step '%s' has a circular dependency\", [step.id]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n\n# Helper function to check for circular dependencies\ndepends_on_self(id, deps) {\n    # Direct dependency\n    id in deps\n} else {\n    # Indirect dependency\n    some dep in deps\n    some step in input.plan.steps\n    step.id == dep\n    step.depends_on\n    depends_on_self(id, step.depends_on)\n}\n</code></pre>"},{"location":"advanced/opa-integration/#complex-data-validation","title":"Complex Data Validation","text":"<pre><code>package planlint\n\n# Validate that email notifications match transaction recipients\nviolations[result] {\n    # Find payment steps\n    payment_step := input.plan.steps[i]\n    payment_step.tool == \"payments.transfer\"\n    recipient_account := payment_step.parameters.to_account\n\n    # Find email notification steps that depend on this payment\n    notification_steps := [step |\n        step := input.plan.steps[_];\n        step.tool == \"notify.email\";\n        payment_step.id in step.depends_on\n    ]\n\n    # Check if we have at least one notification\n    count(notification_steps) &gt; 0\n\n    # Check if we have recipient account info in context\n    account_info := [account |\n        account := input.context.accounts[_];\n        account.account_number == recipient_account\n    ]\n\n    count(account_info) &gt; 0\n    recipient_email := account_info[0].email\n\n    # Check if any notification is sent to the account owner\n    not any([\n        step.parameters.to == recipient_email |\n        step := notification_steps[_]\n    ])\n\n    result := {\n        \"rule\": \"missing_recipient_notification\",\n        \"message\": sprintf(\"No notification sent to account owner of %s\", [recipient_account]),\n        \"severity\": \"medium\",\n        \"step_id\": payment_step.id\n    }\n}\n</code></pre>"},{"location":"advanced/opa-integration/#testing-rego-policies","title":"Testing Rego Policies","text":"<p>OPA provides tools for testing your policies. Create a <code>test</code> directory with test cases:</p> <pre><code>policies/\n  security.rego\n  rbac.rego\ntest/\n  security_test.rego\n  rbac_test.rego\n</code></pre>"},{"location":"advanced/opa-integration/#example-test","title":"Example Test","text":"<pre><code># test/security_test.rego\npackage planlint.test\n\nimport data.planlint\n\ntest_sql_injection {\n    # Test input\n    input := {\n        \"plan\": {\n            \"steps\": [\n                {\n                    \"id\": \"step1\",\n                    \"tool\": \"db.query\",\n                    \"parameters\": {\n                        \"query\": \"SELECT * FROM users WHERE username = 'admin' OR 1=1\"\n                    }\n                }\n            ]\n        }\n    }\n\n    # Expected violations\n    violations := planlint.violations with input as input\n    count(violations) == 1\n    violations[_].rule == \"sql_injection\"\n}\n</code></pre>"},{"location":"advanced/opa-integration/#running-tests","title":"Running Tests","text":"<pre><code>opa test -v policies/ test/\n</code></pre>"},{"location":"advanced/opa-integration/#opa-http-api-service","title":"OPA HTTP API Service","text":"<p>You can also run OPA as a service and have Plan-Lint communicate with it via HTTP:</p>"},{"location":"advanced/opa-integration/#start-opa-server","title":"Start OPA Server","text":"<pre><code>opa run --server --addr :8181 policies/\n</code></pre>"},{"location":"advanced/opa-integration/#configure-plan-lint-to-use-opa-server","title":"Configure Plan-Lint to Use OPA Server","text":"<pre><code>from plan_lint import validate_plan\nfrom plan_lint.opa import OPAClient\n\n# Create OPA client\nopa_client = OPAClient(url=\"http://localhost:8181\")\n\n# Validate with remote OPA\nresult = validate_plan(\n    plan,\n    policy,\n    opa_client=opa_client,\n    context={\"user_role\": \"admin\"}\n)\n</code></pre>"},{"location":"advanced/opa-integration/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Policy Indexing: Use indexing in Rego to improve performance</li> <li>Batching: For bulk validation, use batch requests to OPA</li> <li>Local OPA: For performance-critical applications, use the embedded OPA mode</li> </ul>"},{"location":"advanced/opa-integration/#integration-with-opa-bundle-server","title":"Integration with OPA Bundle Server","text":"<p>For enterprise environments, you can use OPA's bundle feature to distribute policies:</p> <pre><code># Start OPA with bundle server\nopa run --server --addr :8181 --bundle https://example.com/bundles/planlint\n</code></pre> <p>This allows centralized policy management and updates without requiring changes to your application code.</p> <p>By leveraging OPA with Plan-Lint, you can implement sophisticated policy validation for your agent plans that goes well beyond the built-in capabilities, while maintaining a clean separation between your policy logic and application code.</p>"},{"location":"advanced/performance-optimization/","title":"Performance Optimization","text":"<p>This guide provides strategies for optimizing Plan-Lint performance in high-throughput environments.</p>"},{"location":"advanced/performance-optimization/#understanding-performance-factors","title":"Understanding Performance Factors","text":"<p>Several factors affect Plan-Lint's validation performance:</p> <ol> <li>Plan Size and Complexity: Larger plans with more steps take longer to validate</li> <li>Policy Complexity: More complex policies and rules increase processing time</li> <li>Validation Volume: High-throughput scenarios require different optimization strategies</li> <li>Available Resources: CPU, memory, and I/O constraints impact performance</li> </ol>"},{"location":"advanced/performance-optimization/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"advanced/performance-optimization/#policy-optimization","title":"Policy Optimization","text":"<p>The most effective way to improve performance is to optimize your policies:</p>"},{"location":"advanced/performance-optimization/#rule-simplification","title":"Rule Simplification","text":"<pre><code># Before: Complex nested conditions\n- rule: check_sql_injection\n  description: Detects SQL injection attempts\n  pattern:\n    tool: sql_query\n    operation: contains\n    value: \"'; DROP TABLE\"\n    or:\n      - pattern:\n          operation: contains\n          value: \"1=1\"\n      - pattern:\n          operation: contains\n          value: \"-- \"\n      - pattern:\n          operation: contains\n          value: \"/*\"\n\n# After: Simplified with regex\n- rule: check_sql_injection\n  description: Detects SQL injection attempts\n  pattern:\n    tool: sql_query\n    operation: matches\n    value: \"'; DROP TABLE|1=1|-- |/\\\\*\"\n</code></pre>"},{"location":"advanced/performance-optimization/#efficient-rule-order","title":"Efficient Rule Order","text":"<p>Order rules with most frequent violations first to fail fast:</p> <pre><code>policies:\n  - name: efficient_policy\n    rules:\n      # Common violations first\n      - rule: check_basic_syntax\n        severity: error\n      - rule: check_sql_injection\n        severity: error\n      # Less common violations later\n      - rule: check_excessive_permissions\n        severity: warning\n</code></pre>"},{"location":"advanced/performance-optimization/#avoid-redundant-rules","title":"Avoid Redundant Rules","text":"<p>Combine related checks to reduce overhead:</p> <pre><code># Before: Separate rules\n- rule: check_email_retrieval\n  pattern:\n    tool: email_api\n    operation: equals\n    action: \"get\"\n\n- rule: check_email_data_access\n  pattern:\n    tool: email_api\n    operation: equals\n    data_type: \"sensitive\"\n\n# After: Combined rule\n- rule: check_email_sensitive_data\n  pattern:\n    tool: email_api\n    and:\n      - pattern:\n          operation: equals\n          action: \"get\"\n      - pattern:\n          operation: equals\n          data_type: \"sensitive\"\n</code></pre>"},{"location":"advanced/performance-optimization/#implementation-optimization","title":"Implementation Optimization","text":""},{"location":"advanced/performance-optimization/#validator-reuse","title":"Validator Reuse","text":"<p>Create a validator once and reuse it for multiple validations:</p> <pre><code>from plan_lint import PlanValidator\nfrom plan_lint.loader import load_policy\n\n# Load policy once\npolicy = load_policy(\"policy.yaml\")\n\n# Create validator once\nvalidator = PlanValidator(policy)\n\n# Use for multiple validations\ndef validate_plans(plans):\n    results = []\n    for plan in plans:\n        result = validator.validate(plan)\n        results.append(result)\n    return results\n</code></pre>"},{"location":"advanced/performance-optimization/#batch-processing","title":"Batch Processing","text":"<p>Process multiple plans in a single operation:</p> <pre><code>from plan_lint import batch_validate_plans\nfrom plan_lint.loader import load_policy, load_plans\n\n# Load policy\npolicy = load_policy(\"policy.yaml\")\n\n# Load multiple plans\nplans = load_plans(\"plans/*.json\")\n\n# Validate all at once\nresults = batch_validate_plans(plans, policy)\n</code></pre>"},{"location":"advanced/performance-optimization/#parallel-processing","title":"Parallel Processing","text":"<p>Use multi-threading or multiprocessing for parallel validation:</p> <pre><code>import concurrent.futures\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy, load_plan\n\ndef validate_worker(plan_path):\n    # Each worker loads the policy (or use a shared policy with thread-safety)\n    policy = load_policy(\"policy.yaml\")\n    plan = load_plan(plan_path)\n    return validate_plan(plan, policy)\n\n# List of plan paths\nplan_paths = [\"plan1.json\", \"plan2.json\", \"plan3.json\", ...]\n\n# Process in parallel\nwith concurrent.futures.ProcessPoolExecutor(max_workers=4) as executor:\n    results = list(executor.map(validate_worker, plan_paths))\n</code></pre>"},{"location":"advanced/performance-optimization/#memory-management","title":"Memory Management","text":"<p>For large validation jobs, manage memory usage:</p> <pre><code>import gc\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy, load_plan\n\ndef validate_with_memory_management(plan_paths, batch_size=100):\n    # Load policy once\n    policy = load_policy(\"policy.yaml\")\n\n    results = []\n\n    # Process in batches\n    for i in range(0, len(plan_paths), batch_size):\n        batch = plan_paths[i:i+batch_size]\n\n        # Process batch\n        batch_results = []\n        for path in batch:\n            plan = load_plan(path)\n            result = validate_plan(plan, policy)\n            batch_results.append((path, result))\n\n        # Store results\n        results.extend(batch_results)\n\n        # Force garbage collection\n        gc.collect()\n\n    return results\n</code></pre>"},{"location":"advanced/performance-optimization/#stream-processing","title":"Stream Processing","text":"<p>For continuous validation, use stream processing techniques:</p> <pre><code>import json\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\ndef validate_stream(input_stream, output_stream):\n    # Load policy once\n    policy = load_policy(\"policy.yaml\")\n\n    # Process stream\n    for line in input_stream:\n        # Parse plan\n        plan = json.loads(line)\n\n        # Validate\n        result = validate_plan(plan, policy)\n\n        # Write result\n        output_stream.write(json.dumps({\n            \"plan_id\": plan.get(\"id\", \"unknown\"),\n            \"is_valid\": result.is_valid,\n            \"violations\": [v.to_dict() for v in result.violations]\n        }) + \"\\n\")\n        output_stream.flush()\n</code></pre>"},{"location":"advanced/performance-optimization/#infrastructure-optimization","title":"Infrastructure Optimization","text":""},{"location":"advanced/performance-optimization/#caching-strategy","title":"Caching Strategy","text":"<p>Implement caching for plans that are validated frequently:</p> <pre><code>import hashlib\nimport json\nimport redis\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n# Connect to Redis\ncache = redis.Redis(host='localhost', port=6379, db=0)\n\ndef cached_validate(plan, policy=None, cache_ttl=3600):\n    if policy is None:\n        policy = load_policy(\"policy.yaml\")\n\n    # Generate cache key\n    plan_hash = hashlib.md5(json.dumps(plan, sort_keys=True).encode()).hexdigest()\n    policy_hash = hashlib.md5(json.dumps(policy, sort_keys=True).encode()).hexdigest()\n    cache_key = f\"planlint:validation:{plan_hash}:{policy_hash}\"\n\n    # Check cache\n    cached_result = cache.get(cache_key)\n    if cached_result:\n        return json.loads(cached_result)\n\n    # Validate\n    result = validate_plan(plan, policy)\n\n    # Cache result\n    cache.setex(\n        cache_key,\n        cache_ttl,\n        json.dumps({\n            \"is_valid\": result.is_valid,\n            \"violations\": [v.to_dict() for v in result.violations]\n        })\n    )\n\n    return result\n</code></pre>"},{"location":"advanced/performance-optimization/#distributed-processing","title":"Distributed Processing","text":"<p>For very high throughput, distribute validation across multiple nodes:</p> <pre><code># Worker code (validate_worker.py)\nfrom celery import Celery\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\napp = Celery('validate_worker', broker='pyamqp://guest@localhost//')\n\n@app.task\ndef validate_task(plan_data, policy_path=\"policy.yaml\"):\n    policy = load_policy(policy_path)\n    result = validate_plan(plan_data, policy)\n    return {\n        \"is_valid\": result.is_valid,\n        \"violations\": [v.to_dict() for v in result.violations]\n    }\n\n# Client code\nfrom validate_worker import validate_task\n\n# Submit plan for validation\nresult = validate_task.delay(plan_data)\n\n# Get result when ready\nvalidation_result = result.get()\n</code></pre>"},{"location":"advanced/performance-optimization/#service-scaling","title":"Service Scaling","text":"<p>For cloud deployments, consider auto-scaling validation services:</p> <pre><code># Kubernetes deployment example\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: plan-lint-validator\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: plan-lint-validator\n  template:\n    metadata:\n      labels:\n        app: plan-lint-validator\n    spec:\n      containers:\n      - name: validator\n        image: planlint/validator:latest\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"1000m\"\n        env:\n        - name: POLICY_PATH\n          value: \"/etc/planlint/policy.yaml\"\n---\napiVersion: autoscaling/v2beta2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: plan-lint-validator-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: plan-lint-validator\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n</code></pre>"},{"location":"advanced/performance-optimization/#profiling-and-benchmarking","title":"Profiling and Benchmarking","text":""},{"location":"advanced/performance-optimization/#performance-profiling","title":"Performance Profiling","text":"<p>Use profiling to identify bottlenecks:</p> <pre><code>import cProfile\nimport pstats\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy, load_plan\n\ndef profile_validation():\n    # Load data\n    policy = load_policy(\"policy.yaml\")\n    plan = load_plan(\"plan.json\")\n\n    # Profile\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    # Run validation\n    result = validate_plan(plan, policy)\n\n    # Disable profiler\n    profiler.disable()\n\n    # Print stats\n    stats = pstats.Stats(profiler).sort_stats('cumtime')\n    stats.print_stats(20)  # Print top 20 time-consuming operations\n\n    return result\n\nprofile_validation()\n</code></pre>"},{"location":"advanced/performance-optimization/#benchmarking","title":"Benchmarking","text":"<p>Measure validation performance across different scenarios:</p> <pre><code>import time\nimport statistics\nfrom plan_lint import validate_plan\nfrom plan_lint.loader import load_policy, load_plan\n\ndef benchmark_validation(plan_paths, iterations=10):\n    # Load policy\n    policy = load_policy(\"policy.yaml\")\n\n    # Results\n    results = {}\n\n    for path in plan_paths:\n        # Load plan\n        plan = load_plan(path)\n\n        # Run benchmark\n        times = []\n        for _ in range(iterations):\n            start = time.time()\n            validate_plan(plan, policy)\n            end = time.time()\n            times.append(end - start)\n\n        # Calculate stats\n        results[path] = {\n            \"min\": min(times),\n            \"max\": max(times),\n            \"mean\": statistics.mean(times),\n            \"median\": statistics.median(times),\n            \"stdev\": statistics.stdev(times) if len(times) &gt; 1 else 0\n        }\n\n    return results\n\n# Run benchmark\nbenchmark_results = benchmark_validation([\n    \"small_plan.json\",\n    \"medium_plan.json\",\n    \"large_plan.json\"\n])\n\n# Print results\nfor path, stats in benchmark_results.items():\n    print(f\"Plan: {path}\")\n    print(f\"  Min: {stats['min']:.6f}s\")\n    print(f\"  Max: {stats['max']:.6f}s\")\n    print(f\"  Mean: {stats['mean']:.6f}s\")\n    print(f\"  Median: {stats['median']:.6f}s\")\n    print(f\"  StdDev: {stats['stdev']:.6f}s\")\n</code></pre>"},{"location":"advanced/performance-optimization/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Policy Optimization:</li> <li>Simplify complex rules</li> <li>Order rules efficiently</li> <li>Use regex for pattern matching when appropriate</li> <li> <p>Avoid redundant checks</p> </li> <li> <p>Implementation Optimization:</p> </li> <li>Reuse validator instances</li> <li>Process plans in batches</li> <li>Use parallel processing for high volumes</li> <li> <p>Manage memory usage for large workloads</p> </li> <li> <p>Infrastructure Optimization:</p> </li> <li>Implement caching for repeated validations</li> <li>Use distributed processing for high throughput</li> <li>Scale validation services based on demand</li> <li> <p>Allocate appropriate resources based on workload</p> </li> <li> <p>Continual Improvement:</p> </li> <li>Profile to identify bottlenecks</li> <li>Benchmark to establish performance baselines</li> <li>Monitor performance in production</li> <li>Refine policies based on performance data</li> </ol> <p>By following these optimization strategies, you can significantly improve Plan-Lint's performance, especially in high-throughput environments where validation speed is critical. </p>"},{"location":"api/","title":"API Reference Overview","text":"<p>This section provides detailed information about the Plan-Lint API.</p>"},{"location":"api/#api-sections","title":"API Sections","text":"<p>The Plan-Lint API is organized into the following sections:</p> <ul> <li>Core: Core functions for validating plans</li> <li>Types: Data types for representing plans, steps, policies, and validation results</li> <li>Loader: Functions for loading plans, policies, and schemas</li> <li>Rules: Rule validation functions for checking specific aspects of plans</li> <li>Validator: Reusable validator class for validating plans against policies</li> </ul>"},{"location":"api/#quick-start","title":"Quick Start","text":"<p>Here's a quick example to get you started with the Plan-Lint API:</p> <pre><code>from plan_lint.core import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\nfrom plan_lint.types import Status\n\n# Load plan and policy\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.yaml\")\n\n# Validate plan\nresult = validate_plan(plan, policy)\n\n# Check results\nif result.status == Status.PASS:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Plan validation failed with risk score: {result.risk_score}\")\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg} ({error.code})\")\n</code></pre>"},{"location":"api/#installation","title":"Installation","text":"<p>To use the Plan-Lint API, first install the package:</p> <pre><code>pip install plan-lint\n</code></pre>"},{"location":"api/#python-version-compatibility","title":"Python Version Compatibility","text":"<p>Plan-Lint requires Python 3.8 or later.</p>"},{"location":"api/#error-handling","title":"Error Handling","text":"<p>Plan-Lint functions raise exceptions in the following cases:</p> <ul> <li><code>ValueError</code>: Invalid plan or policy structure</li> <li><code>FileNotFoundError</code>: Referenced plan or policy file not found</li> <li><code>jsonschema.exceptions.ValidationError</code>: Plan schema validation failure</li> </ul> <p>Always handle these exceptions in production code:</p> <pre><code>from plan_lint.loader import load_plan, load_policy\nfrom plan_lint.core import validate_plan\nimport jsonschema\n\ntry:\n    plan = load_plan(\"plans/customer_refund.json\")\n    policy, rego_policy = load_policy(\"policies/security.yaml\")\n    result = validate_plan(plan, policy)\n\n    # Process result...\n\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid plan or policy: {e}\")\nexcept jsonschema.exceptions.ValidationError as e:\n    print(f\"Plan schema validation failed: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"api/core/","title":"Core API","text":"<p>This page documents the core functions of Plan-Lint.</p>"},{"location":"api/core/#validate_plan","title":"<code>validate_plan</code>","text":"<p>The main function for validating agent plans.</p> <pre><code>from plan_lint.core import validate_plan\n\nresult = validate_plan(\n    plan,\n    policy,\n    rego_policy=None,\n    use_opa=False\n)\n</code></pre>"},{"location":"api/core/#parameters","title":"Parameters","text":"Parameter Type Description <code>plan</code> <code>Plan</code> The agent plan to validate <code>policy</code> <code>Policy</code> Policy object containing validation rules <code>rego_policy</code> <code>Optional[str]</code> Optional Rego policy as a string <code>use_opa</code> <code>bool</code> Whether to use OPA for validation (defaults to False)"},{"location":"api/core/#returns","title":"Returns","text":"<p>Returns a <code>ValidationResult</code> object containing:</p> Attribute Type Description <code>status</code> <code>Status</code> Status of validation (PASS, WARN, ERROR) <code>risk_score</code> <code>float</code> Risk score between 0.0 and 1.0 <code>errors</code> <code>List[PlanError]</code> List of validation errors <code>warnings</code> <code>List[PlanWarning]</code> List of validation warnings"},{"location":"api/core/#calculate_risk_score","title":"<code>calculate_risk_score</code>","text":"<p>Calculate a risk score for the plan based on errors and warnings.</p> <pre><code>from plan_lint.core import calculate_risk_score\n\nrisk_score = calculate_risk_score(errors, warnings, risk_weights)\n</code></pre>"},{"location":"api/core/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>errors</code> <code>List[PlanError]</code> List of errors found during validation <code>warnings</code> <code>List[PlanWarning]</code> List of warnings found during validation <code>risk_weights</code> <code>Dict[str, float]</code> Dictionary mapping error/warning types to weights"},{"location":"api/core/#returns_1","title":"Returns","text":"<p>Returns a float between 0.0 and 1.0 representing the risk score.</p>"},{"location":"api/core/#example-usage","title":"Example Usage","text":"<pre><code>from plan_lint.core import validate_plan, calculate_risk_score\nfrom plan_lint.loader import load_plan, load_policy\nfrom plan_lint.types import Status, PlanError, ErrorCode\n\n# Basic validation example\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.yaml\")\n\n# Validate plan\nresult = validate_plan(plan, policy)\n\n# Check results\nif result.status == Status.PASS:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Plan validation failed with risk score: {result.risk_score}\")\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg} ({error.code})\")\n\n# Manual risk score calculation\nerrors = [\n    PlanError(step=1, code=ErrorCode.RAW_SECRET, msg=\"Sensitive data detected\"),\n    PlanError(step=2, code=ErrorCode.BOUND_VIOLATION, msg=\"Amount exceeds maximum\")\n]\nwarnings = []\nrisk_weights = {\n    \"raw_secret\": 0.7,\n    \"bound_violation\": 0.4\n}\n\nrisk_score = calculate_risk_score(errors, warnings, risk_weights)\nprint(f\"Risk score: {risk_score}\")\n</code></pre>"},{"location":"api/loader/","title":"Loader API","text":"<p>This page documents the loader functions for loading plans, policies, and schemas.</p>"},{"location":"api/loader/#load_plan","title":"<code>load_plan</code>","text":"<p>Load a plan from a JSON file.</p> <pre><code>from plan_lint.loader import load_plan\n\nplan = load_plan(\"path/to/plan.json\")\n</code></pre>"},{"location":"api/loader/#parameters","title":"Parameters","text":"Parameter Type Description <code>plan_path</code> <code>str</code> Path to a JSON plan file"},{"location":"api/loader/#returns","title":"Returns","text":"<p>Returns a <code>Plan</code> object.</p>"},{"location":"api/loader/#load_policy","title":"<code>load_policy</code>","text":"<p>Load a policy from a YAML or Rego file.</p> <pre><code>from plan_lint.loader import load_policy\n\npolicy, rego_policy = load_policy(\"path/to/policy.yaml\")\n# or\npolicy, rego_policy = load_policy(\"path/to/policy.rego\")\n</code></pre>"},{"location":"api/loader/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>Optional[str]</code> Path to a policy file (YAML or Rego)"},{"location":"api/loader/#returns_1","title":"Returns","text":"<p>Returns a tuple of (<code>Policy</code> object, Optional Rego policy string).</p>"},{"location":"api/loader/#load_yaml_policy","title":"<code>load_yaml_policy</code>","text":"<p>Load a policy specifically from a YAML file.</p> <pre><code>from plan_lint.loader import load_yaml_policy\n\npolicy = load_yaml_policy(\"path/to/policy.yaml\")\n</code></pre>"},{"location":"api/loader/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>str</code> Path to a YAML policy file"},{"location":"api/loader/#returns_2","title":"Returns","text":"<p>Returns a <code>Policy</code> object.</p>"},{"location":"api/loader/#load_rego_policy","title":"<code>load_rego_policy</code>","text":"<p>Load a Rego policy from a file.</p> <pre><code>from plan_lint.loader import load_rego_policy\n\nrego_policy = load_rego_policy(\"path/to/policy.rego\")\n</code></pre>"},{"location":"api/loader/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>str</code> Path to a Rego policy file"},{"location":"api/loader/#returns_3","title":"Returns","text":"<p>Returns the Rego policy as a string.</p>"},{"location":"api/loader/#load_schema","title":"<code>load_schema</code>","text":"<p>Load a JSON schema for plan validation.</p> <pre><code>from plan_lint.loader import load_schema\n\nschema = load_schema()  # Use default schema\n# or\nschema = load_schema(\"path/to/custom/schema.json\")\n</code></pre>"},{"location":"api/loader/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>schema_path</code> <code>Optional[str]</code> Path to a JSON schema file (None for default)"},{"location":"api/loader/#returns_4","title":"Returns","text":"<p>Returns the schema as a dictionary.</p>"},{"location":"api/loader/#example-usage","title":"Example Usage","text":"<pre><code>from plan_lint.loader import load_plan, load_policy\nfrom plan_lint.core import validate_plan\n\n# Load plan and policy\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.yaml\")\n\n# Validate plan\nresult = validate_plan(plan, policy)\n\n# For a Rego policy\npolicy, rego_policy = load_policy(\"policies/security.rego\")\nresult = validate_plan(plan, policy, rego_policy=rego_policy, use_opa=True)\n</code></pre>"},{"location":"api/reference/","title":"API Reference","text":"<p>This document provides detailed information about the Plan-Lint API, including the main functions, classes, and their parameters.</p>"},{"location":"api/reference/#core-functions","title":"Core Functions","text":""},{"location":"api/reference/#validate_plan","title":"<code>validate_plan</code>","text":"<p>The primary function for validating plans against policies.</p> <pre><code>def validate_plan(\n    plan: Dict[str, Any],\n    policies: Optional[List[str]] = None,\n    context: Optional[Dict[str, Any]] = None,\n    config: Optional[Dict[str, Any]] = None\n) -&gt; ValidationResult:\n    \"\"\"\n    Validate a plan against policies.\n\n    Args:\n        plan: The plan to validate, containing steps and their tools/parameters\n        policies: Optional list of paths to policy files. If None, uses default policies\n        context: Optional context information to provide to the policies\n        config: Optional configuration for the validation process\n\n    Returns:\n        A ValidationResult object containing validation results\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#load_policy","title":"<code>load_policy</code>","text":"<p>Load a Rego policy from a file.</p> <pre><code>def load_policy(\n    policy_path: str\n) -&gt; str:\n    \"\"\"\n    Load a Rego policy file.\n\n    Args:\n        policy_path: Path to the Rego policy file\n\n    Returns:\n        The policy content as a string\n\n    Raises:\n        FileNotFoundError: If the policy file doesn't exist\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#format_plan","title":"<code>format_plan</code>","text":"<p>Format a plan to ensure it meets the expected structure for validation.</p> <pre><code>def format_plan(\n    plan: Dict[str, Any]\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Format a plan to ensure it has the expected structure.\n\n    Args:\n        plan: The plan to format\n\n    Returns:\n        The formatted plan\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#classes","title":"Classes","text":""},{"location":"api/reference/#validationresult","title":"<code>ValidationResult</code>","text":"<p>Contains the results of plan validation.</p> <pre><code>class ValidationResult:\n    \"\"\"\n    Result of a plan validation.\n\n    Attributes:\n        valid (bool): Whether the plan is valid according to all policies\n        violations (List[PolicyViolation]): List of policy violations found\n        details (Dict[str, Any]): Additional details about the validation\n\n    Methods:\n        to_dict(): Convert the result to a dictionary\n        to_json(): Convert the result to a JSON string\n    \"\"\"\n\n    @property\n    def valid(self) -&gt; bool:\n        \"\"\"Whether the plan is valid (no violations).\"\"\"\n\n    @property\n    def violations(self) -&gt; List[\"PolicyViolation\"]:\n        \"\"\"List of policy violations.\"\"\"\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert the result to a dictionary.\"\"\"\n\n    def to_json(self, **kwargs) -&gt; str:\n        \"\"\"Convert the result to a JSON string.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyviolation","title":"<code>PolicyViolation</code>","text":"<p>Represents a violation of a policy rule.</p> <pre><code>class PolicyViolation:\n    \"\"\"\n    Represents a violation of a policy rule.\n\n    Attributes:\n        rule (str): The policy rule that was violated\n        message (str): Description of the violation\n        severity (str): Severity level ('low', 'medium', 'high', 'critical')\n        category (str): Category of the violation (e.g., 'security', 'privacy')\n        step_id (Optional[str]): ID of the step that caused the violation\n        metadata (Dict[str, Any]): Additional metadata about the violation\n    \"\"\"\n\n    @property\n    def rule(self) -&gt; str:\n        \"\"\"The policy rule that was violated.\"\"\"\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Description of the violation.\"\"\"\n\n    @property\n    def severity(self) -&gt; str:\n        \"\"\"Severity level of the violation.\"\"\"\n\n    @property\n    def category(self) -&gt; str:\n        \"\"\"Category of the violation.\"\"\"\n\n    @property\n    def step_id(self) -&gt; Optional[str]:\n        \"\"\"ID of the step that caused the violation, if applicable.\"\"\"\n\n    @property\n    def metadata(self) -&gt; Dict[str, Any]:\n        \"\"\"Additional metadata about the violation.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyengine","title":"<code>PolicyEngine</code>","text":"<p>Manages policy evaluation using the Open Policy Agent.</p> <pre><code>class PolicyEngine:\n    \"\"\"\n    Engine for evaluating Rego policies against plans.\n\n    Methods:\n        evaluate(plan, policies, context): Evaluate policies against a plan\n    \"\"\"\n\n    def evaluate(\n        self,\n        plan: Dict[str, Any],\n        policies: List[str],\n        context: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Evaluate policies against a plan.\n\n        Args:\n            plan: The plan to evaluate\n            policies: List of policy file paths\n            context: Optional context information\n\n        Returns:\n            Evaluation results as a dictionary\n        \"\"\"\n</code></pre>"},{"location":"api/reference/#cli-commands","title":"CLI Commands","text":""},{"location":"api/reference/#plan-lint-validate","title":"<code>plan-lint validate</code>","text":"<p>Command-line interface for validating plans.</p> <pre><code>Usage: plan-lint validate [OPTIONS] PLAN_FILE\n\n  Validate a plan against policies.\n\nOptions:\n  --policies PATH...  Custom policy files to use\n  --context FILE      JSON file containing context information\n  --output FORMAT     Output format (text, json, yaml) [default: text]\n  --config FILE       Configuration file\n  --help              Show this message and exit\n</code></pre>"},{"location":"api/reference/#plan-lint-test","title":"<code>plan-lint test</code>","text":"<p>Command-line interface for testing policies.</p> <pre><code>Usage: plan-lint test [OPTIONS] [TEST_DIR]\n\n  Run policy tests.\n\nOptions:\n  --policies PATH...  Custom policy files to test\n  --verbose           Show detailed test output\n  --help              Show this message and exit\n</code></pre>"},{"location":"api/reference/#constants","title":"Constants","text":""},{"location":"api/reference/#severity-levels","title":"Severity Levels","text":"<pre><code>class Severity:\n    \"\"\"Severity levels for policy violations.\"\"\"\n\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n</code></pre>"},{"location":"api/reference/#violation-categories","title":"Violation Categories","text":"<pre><code>class Category:\n    \"\"\"Categories for policy violations.\"\"\"\n\n    SECURITY = \"security\"\n    PRIVACY = \"privacy\"\n    AUTHORIZATION = \"authorization\"\n    COMPLIANCE = \"compliance\"\n    RESOURCE = \"resource\"\n    GENERAL = \"general\"\n</code></pre>"},{"location":"api/reference/#error-classes","title":"Error Classes","text":""},{"location":"api/reference/#policyerror","title":"<code>PolicyError</code>","text":"<p>Base class for policy-related errors.</p> <pre><code>class PolicyError(Exception):\n    \"\"\"Base class for policy-related errors.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyloaderror","title":"<code>PolicyLoadError</code>","text":"<p>Error raised when a policy cannot be loaded.</p> <pre><code>class PolicyLoadError(PolicyError):\n    \"\"\"Raised when a policy cannot be loaded.\"\"\"\n</code></pre>"},{"location":"api/reference/#policyevaluationerror","title":"<code>PolicyEvaluationError</code>","text":"<p>Error raised when policy evaluation fails.</p> <pre><code>class PolicyEvaluationError(PolicyError):\n    \"\"\"Raised when policy evaluation fails.\"\"\"\n</code></pre>"},{"location":"api/reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api/reference/#get_default_policies","title":"<code>get_default_policies</code>","text":"<p>Get the paths to the default policy files.</p> <pre><code>def get_default_policies() -&gt; List[str]:\n    \"\"\"\n    Get the paths to the default policy files.\n\n    Returns:\n        List of paths to default policy files\n    \"\"\"\n</code></pre>"},{"location":"api/reference/#load_context","title":"<code>load_context</code>","text":"<p>Load context information from a file.</p> <pre><code>def load_context(context_path: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Load context information from a JSON file.\n\n    Args:\n        context_path: Path to the context file\n\n    Returns:\n        Context information as a dictionary\n\n    Raises:\n        FileNotFoundError: If the context file doesn't exist\n        json.JSONDecodeError: If the context file is not valid JSON\n    \"\"\"\n</code></pre>"},{"location":"api/rules/","title":"Rules API","text":"<p>This page documents the rule validation functions of Plan-Lint.</p>"},{"location":"api/rules/#built-in-rule-functions","title":"Built-in Rule Functions","text":"<p>Plan-Lint provides several built-in rule functions for validating different aspects of plans.</p>"},{"location":"api/rules/#check_tools_allowed","title":"<code>check_tools_allowed</code>","text":"<p>Check if a step's tool is allowed by the policy.</p> <pre><code>from plan_lint.core import check_tools_allowed\n\nerror = check_tools_allowed(step, allowed_tools, step_idx)\n</code></pre>"},{"location":"api/rules/#parameters","title":"Parameters","text":"Parameter Type Description <code>step</code> <code>PlanStep</code> The plan step to check <code>allowed_tools</code> <code>List[str]</code> List of allowed tool names <code>step_idx</code> <code>int</code> Index of the step in the plan"},{"location":"api/rules/#returns","title":"Returns","text":"<p>Returns a <code>PlanError</code> if the tool is not allowed, <code>None</code> otherwise.</p>"},{"location":"api/rules/#check_bounds","title":"<code>check_bounds</code>","text":"<p>Check if a step's arguments are within bounds defined by the policy.</p> <pre><code>from plan_lint.core import check_bounds\n\nerrors = check_bounds(step, bounds, step_idx)\n</code></pre>"},{"location":"api/rules/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>step</code> <code>PlanStep</code> The plan step to check <code>bounds</code> <code>Dict[str, List[float]]</code> Dictionary mapping tool.arg paths to [min, max] bounds <code>step_idx</code> <code>int</code> Index of the step in the plan"},{"location":"api/rules/#returns_1","title":"Returns","text":"<p>Returns a list of <code>PlanError</code> for any bounds violations.</p>"},{"location":"api/rules/#check_raw_secrets","title":"<code>check_raw_secrets</code>","text":"<p>Check if a step contains raw secrets or sensitive data.</p> <pre><code>from plan_lint.core import check_raw_secrets\n\nerrors = check_raw_secrets(step, deny_patterns, step_idx)\n</code></pre>"},{"location":"api/rules/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>step</code> <code>PlanStep</code> The plan step to check <code>deny_patterns</code> <code>List[str]</code> List of regex patterns to deny <code>step_idx</code> <code>int</code> Index of the step in the plan"},{"location":"api/rules/#returns_2","title":"Returns","text":"<p>Returns a list of <code>PlanError</code> for any detected secrets.</p>"},{"location":"api/rules/#detect_cycles","title":"<code>detect_cycles</code>","text":"<p>Detect cycles in the plan's step dependencies.</p> <pre><code>from plan_lint.core import detect_cycles\n\nerror = detect_cycles(plan)\n</code></pre>"},{"location":"api/rules/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>plan</code> <code>Plan</code> The plan to check"},{"location":"api/rules/#returns_3","title":"Returns","text":"<p>Returns a <code>PlanError</code> if a cycle is detected, <code>None</code> otherwise.</p>"},{"location":"api/rules/#creating-custom-rule-functions","title":"Creating Custom Rule Functions","text":"<p>You can create custom rule functions to add your own validation logic:</p> <pre><code>from typing import List, Dict, Any, Optional\nfrom plan_lint.types import Plan, PlanStep, PlanError, ErrorCode\n\ndef check_custom_rule(\n    plan: Plan, \n    context: Optional[Dict[str, Any]] = None\n) -&gt; List[PlanError]:\n    \"\"\"\n    Custom rule to validate some aspect of the plan.\n\n    Args:\n        plan: The plan to validate\n        context: Optional context information\n\n    Returns:\n        List of errors found during validation\n    \"\"\"\n    errors = []\n\n    # Example: Check that payment operations have an approval step\n    for i, step in enumerate(plan.steps):\n        if step.tool.startswith(\"payments.\"):\n            # Look for an approval step that depends on this payment\n            approval_step_exists = False\n            for j, other_step in enumerate(plan.steps):\n                if (other_step.tool == \"approval.request\" and \n                    step.id in other_step.depends_on):\n                    approval_step_exists = True\n                    break\n\n            if not approval_step_exists:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=f\"Payment operation in step {step.id} requires an approval step\"\n                    )\n                )\n\n    return errors\n</code></pre>"},{"location":"api/rules/#using-custom-rules","title":"Using Custom Rules","text":"<p>You can use custom rules with the <code>validate_plan</code> function:</p> <pre><code>from plan_lint.core import validate_plan\nfrom my_custom_rules import check_custom_rule\n\n# Load plan and policy\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.yaml\")\n\n# Create custom validators list\ncustom_validators = [check_custom_rule]\n\n# Validate with custom rules\nresult = validate_plan(\n    plan, \n    policy,\n    custom_validators=custom_validators,\n    context={\"user_role\": \"admin\"}\n)\n</code></pre>"},{"location":"api/types/","title":"Types API","text":"<p>This page documents the data types used in Plan-Lint.</p>"},{"location":"api/types/#plan","title":"<code>Plan</code>","text":"<p>Represents an agent plan to be validated.</p> <pre><code>from plan_lint.types import Plan, PlanStep\n\nplan = Plan(\n    goal=\"Process customer refund\",\n    steps=[\n        PlanStep(\n            id=\"step1\",\n            tool=\"db.query\",\n            args={\"query\": \"SELECT * FROM users\"}\n        ),\n        PlanStep(\n            id=\"step2\",\n            tool=\"notify.email\",\n            args={\"to\": \"user@example.com\", \"body\": \"Your refund is processed\"}\n        )\n    ],\n    context={\"user_id\": \"123\"}\n)\n</code></pre>"},{"location":"api/types/#attributes","title":"Attributes","text":"Attribute Type Description <code>goal</code> <code>str</code> The goal or purpose of the plan <code>steps</code> <code>List[PlanStep]</code> Steps to be executed in the plan <code>context</code> <code>Optional[Dict[str, Any]]</code> Additional context for the plan <code>meta</code> <code>Optional[Dict[str, Any]]</code> Metadata about the plan"},{"location":"api/types/#planstep","title":"<code>PlanStep</code>","text":"<p>Represents a single step in an agent plan.</p> <pre><code>from plan_lint.types import PlanStep\n\nstep = PlanStep(\n    id=\"step1\",\n    tool=\"db.query\",\n    args={\"query\": \"SELECT * FROM users\"},\n    on_fail=\"abort\"\n)\n</code></pre>"},{"location":"api/types/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>id</code> <code>str</code> Unique identifier for the step <code>tool</code> <code>str</code> The tool to be used in this step <code>args</code> <code>Dict[str, Any]</code> Arguments to pass to the tool <code>on_fail</code> <code>str</code> Action to take if step fails (default: \"abort\")"},{"location":"api/types/#policy","title":"<code>Policy</code>","text":"<p>Represents a policy for plan validation.</p> <pre><code>from plan_lint.types import Policy\n\npolicy = Policy(\n    allow_tools=[\"db.query_ro\", \"notify.email\"],\n    bounds={\"payments.transfer.amount\": [0.01, 1000.00]},\n    deny_tokens_regex=[\"password\", \"secret\", \"DROP TABLE\"],\n    max_steps=10,\n    risk_weights={\"TOOL_DENY\": 0.8, \"RAW_SECRET\": 0.6},\n    fail_risk_threshold=0.7\n)\n</code></pre>"},{"location":"api/types/#attributes_2","title":"Attributes","text":"Attribute Type Description <code>allow_tools</code> <code>List[str]</code> List of allowed tools <code>bounds</code> <code>Dict[str, List[Union[int, float]]]</code> Parameter boundaries <code>deny_tokens_regex</code> <code>List[str]</code> Patterns to reject <code>max_steps</code> <code>int</code> Maximum allowed steps in a plan <code>risk_weights</code> <code>Dict[str, float]</code> Weights for different violation types <code>fail_risk_threshold</code> <code>float</code> Risk threshold for failing validation"},{"location":"api/types/#planerror","title":"<code>PlanError</code>","text":"<p>Represents an error found during plan validation.</p> <pre><code>from plan_lint.types import PlanError, ErrorCode\n\nerror = PlanError(\n    step=1,\n    code=ErrorCode.TOOL_DENY,\n    msg=\"Tool 'db.write' is not allowed by policy\"\n)\n</code></pre>"},{"location":"api/types/#attributes_3","title":"Attributes","text":"Attribute Type Description <code>step</code> <code>Optional[int]</code> Index of the step where the error was found <code>code</code> <code>ErrorCode</code> Error code <code>msg</code> <code>str</code> Human-readable error message"},{"location":"api/types/#planwarning","title":"<code>PlanWarning</code>","text":"<p>Represents a warning found during plan validation.</p> <pre><code>from plan_lint.types import PlanWarning\n\nwarning = PlanWarning(\n    step=1,\n    code=\"PERFORMANCE\",\n    msg=\"This query might be slow for large datasets\"\n)\n</code></pre>"},{"location":"api/types/#attributes_4","title":"Attributes","text":"Attribute Type Description <code>step</code> <code>Optional[int]</code> Index of the step where the warning was found <code>code</code> <code>str</code> Warning code <code>msg</code> <code>str</code> Human-readable warning message"},{"location":"api/types/#errorcode","title":"<code>ErrorCode</code>","text":"<p>Enum of error codes for plan validation failures.</p> <pre><code>from plan_lint.types import ErrorCode\n\n# Available error codes\nErrorCode.SCHEMA_INVALID      # Invalid plan schema\nErrorCode.TOOL_DENY           # Unauthorized tool\nErrorCode.BOUND_VIOLATION     # Parameter out of bounds\nErrorCode.RAW_SECRET          # Sensitive data exposure\nErrorCode.LOOP_DETECTED       # Circular dependency detected\nErrorCode.MAX_STEPS_EXCEEDED  # Too many steps in plan\nErrorCode.MISSING_HANDLER     # Missing error handler\n</code></pre>"},{"location":"api/types/#status","title":"<code>Status</code>","text":"<p>Enum of validation status values.</p> <pre><code>from plan_lint.types import Status\n\nStatus.PASS    # Plan passed validation\nStatus.WARN    # Plan has warnings but passed\nStatus.ERROR   # Plan failed validation\n</code></pre>"},{"location":"api/types/#validationresult","title":"<code>ValidationResult</code>","text":"<p>Contains the results of plan validation.</p> <pre><code>from plan_lint.types import ValidationResult, Status\n\nresult = ValidationResult(\n    status=Status.ERROR,\n    risk_score=0.6,\n    errors=[error1, error2],\n    warnings=[warning1]\n)\n</code></pre>"},{"location":"api/types/#attributes_5","title":"Attributes","text":"Attribute Type Description <code>status</code> <code>Status</code> Status of validation (PASS, WARN, ERROR) <code>risk_score</code> <code>float</code> Risk score between 0.0 and 1.0 <code>errors</code> <code>List[PlanError]</code> List of validation errors <code>warnings</code> <code>List[PlanWarning]</code> List of validation warnings"},{"location":"api/validator/","title":"Validator API","text":"<p>This page documents the policy validator class for reusable validation.</p>"},{"location":"api/validator/#policyvalidator","title":"<code>PolicyValidator</code>","text":"<p>Class for creating a reusable validator with specific policies.</p> <pre><code>from plan_lint.validator import PolicyValidator\n\nvalidator = PolicyValidator(\n    policy_files=[\"policies/security.yaml\", \"policies/custom.rego\"],\n    custom_validators=[my_custom_validator],\n    allow_undefined_tools=False\n)\n\nresult = validator.validate(plan, context={\"user_role\": \"admin\"})\n</code></pre>"},{"location":"api/validator/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description <code>policy_files</code> <code>List[str]</code> List of policy file paths (YAML or Rego) <code>custom_validators</code> <code>List[Callable]</code> Optional list of custom validator functions <code>allow_undefined_tools</code> <code>bool</code> Whether to allow tools not defined in policies"},{"location":"api/validator/#methods","title":"Methods","text":""},{"location":"api/validator/#validateplan-contextnone-silentfalse","title":"<code>validate(plan, context=None, silent=False)</code>","text":"<p>Validate a plan using the configured policies.</p> <pre><code>result = validator.validate(plan, context={\"user_role\": \"admin\"})\n</code></pre> Parameter Type Description <code>plan</code> <code>Dict[str, Any]</code> or <code>Plan</code> The plan to validate <code>context</code> <code>Dict[str, Any]</code> Optional context information for validation <code>silent</code> <code>bool</code> Whether to suppress console output <p>Returns a <code>ValidationResult</code> object.</p>"},{"location":"api/validator/#add_policy_filefile_path","title":"<code>add_policy_file(file_path)</code>","text":"<p>Add a policy file to the validator.</p> <pre><code>validator.add_policy_file(\"policies/additional.yaml\")\n</code></pre> Parameter Type Description <code>file_path</code> <code>str</code> Path to the policy file to add"},{"location":"api/validator/#add_custom_validatorvalidator_func","title":"<code>add_custom_validator(validator_func)</code>","text":"<p>Add a custom validator function.</p> <pre><code>validator.add_custom_validator(my_custom_validator)\n</code></pre> Parameter Type Description <code>validator_func</code> <code>Callable</code> Custom validator function to add"},{"location":"api/validator/#example-usage","title":"Example Usage","text":"<pre><code>from plan_lint.validator import PolicyValidator\nfrom plan_lint.types import Plan, PlanStep\n\n# Create a validator with policies\nvalidator = PolicyValidator(\n    policy_files=[\"policies/security.yaml\", \"policies/operations.rego\"]\n)\n\n# Validate a plan\nplan = Plan(\n    goal=\"Process customer refund\",\n    steps=[\n        PlanStep(\n            id=\"step1\",\n            tool=\"db.query_ro\",\n            args={\n                \"query\": \"SELECT account FROM customers WHERE id = ?\",\n                \"params\": [\"customer-123\"]\n            }\n        ),\n        PlanStep(\n            id=\"step2\",\n            tool=\"payments.transfer\",\n            args={\n                \"amount\": 100.00,\n                \"account\": \"ACC-123\"\n            }\n        )\n    ]\n)\n\n# Validate with context\nresult = validator.validate(\n    plan,\n    context={\n        \"user_role\": \"admin\",\n        \"environment\": \"production\"\n    }\n)\n\n# Check results\nif result.valid:\n    print(\"Plan is valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg}\")\n</code></pre>"},{"location":"api/validator/#web-service-integration","title":"Web Service Integration","text":"<p>Example of using PolicyValidator in a web service:</p> <pre><code>from flask import Flask, request, jsonify\nfrom plan_lint.validator import PolicyValidator\n\napp = Flask(__name__)\n\n# Create a validator at service startup\nvalidator = PolicyValidator(\n    policy_files=[\"policies/security.yaml\", \"policies/operations.rego\"]\n)\n\n@app.route(\"/validate\", methods=[\"POST\"])\ndef validate():\n    data = request.json\n\n    plan = data.get(\"plan\")\n    context = data.get(\"context\", {})\n\n    if not plan:\n        return jsonify({\"error\": \"Missing plan\"}), 400\n\n    result = validator.validate(plan, context=context)\n\n    return jsonify({\n        \"valid\": result.valid,\n        \"risk_score\": result.risk_score,\n        \"errors\": [\n            {\n                \"step\": error.step,\n                \"code\": error.code.name,\n                \"message\": error.msg\n            }\n            for error in result.errors\n        ]\n    })\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n</code></pre>"},{"location":"documentation/","title":"Documentation Overview","text":"<p>Learn how to use and configure Plan-Lint.</p>"},{"location":"documentation/api-reference/","title":"API Reference","text":"<p>The API Reference documentation has moved to the API Reference section of the documentation.</p> <p>Please see the following pages for detailed API information:</p> <ul> <li>API Overview</li> <li>Core API</li> <li>Types API</li> <li>Loader API</li> <li>Rules API</li> <li>Validator API</li> </ul>"},{"location":"documentation/api-reference/#core-functions","title":"Core Functions","text":""},{"location":"documentation/api-reference/#validate_plan","title":"<code>validate_plan</code>","text":"<p>The main function for validating agent plans.</p> <pre><code>from plan_lint.core import validate_plan\n\nresult = validate_plan(\n    plan,\n    policy,\n    rego_policy=None,\n    use_opa=False\n)\n</code></pre>"},{"location":"documentation/api-reference/#parameters","title":"Parameters","text":"Parameter Type Description <code>plan</code> <code>Plan</code> The agent plan to validate <code>policy</code> <code>Policy</code> Policy object containing validation rules <code>rego_policy</code> <code>Optional[str]</code> Optional Rego policy as a string <code>use_opa</code> <code>bool</code> Whether to use OPA for validation (defaults to False)"},{"location":"documentation/api-reference/#returns","title":"Returns","text":"<p>Returns a <code>ValidationResult</code> object containing:</p> Attribute Type Description <code>status</code> <code>Status</code> Status of validation (PASS, WARN, ERROR) <code>risk_score</code> <code>float</code> Risk score between 0.0 and 1.0 <code>errors</code> <code>List[PlanError]</code> List of validation errors <code>warnings</code> <code>List[PlanWarning]</code> List of validation warnings"},{"location":"documentation/api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"documentation/api-reference/#load_plan","title":"<code>load_plan</code>","text":"<p>Load a plan from a JSON file.</p> <pre><code>from plan_lint.loader import load_plan\n\nplan = load_plan(\"path/to/plan.json\")\n</code></pre>"},{"location":"documentation/api-reference/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>plan_path</code> <code>str</code> Path to a JSON plan file"},{"location":"documentation/api-reference/#returns_1","title":"Returns","text":"<p>Returns a <code>Plan</code> object.</p>"},{"location":"documentation/api-reference/#load_policy","title":"<code>load_policy</code>","text":"<p>Load a policy from a YAML or Rego file.</p> <pre><code>from plan_lint.loader import load_policy\n\npolicy, rego_policy = load_policy(\"path/to/policy.yaml\")\n# or\npolicy, rego_policy = load_policy(\"path/to/policy.rego\")\n</code></pre>"},{"location":"documentation/api-reference/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>Optional[str]</code> Path to a policy file (YAML or Rego)"},{"location":"documentation/api-reference/#returns_2","title":"Returns","text":"<p>Returns a tuple of (<code>Policy</code> object, Optional Rego policy string).</p>"},{"location":"documentation/api-reference/#load_yaml_policy","title":"<code>load_yaml_policy</code>","text":"<p>Load a policy specifically from a YAML file.</p> <pre><code>from plan_lint.loader import load_yaml_policy\n\npolicy = load_yaml_policy(\"path/to/policy.yaml\")\n</code></pre>"},{"location":"documentation/api-reference/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>str</code> Path to a YAML policy file"},{"location":"documentation/api-reference/#returns_3","title":"Returns","text":"<p>Returns a <code>Policy</code> object.</p>"},{"location":"documentation/api-reference/#load_rego_policy","title":"<code>load_rego_policy</code>","text":"<p>Load a Rego policy from a file.</p> <pre><code>from plan_lint.loader import load_rego_policy\n\nrego_policy = load_rego_policy(\"path/to/policy.rego\")\n</code></pre>"},{"location":"documentation/api-reference/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>policy_path</code> <code>str</code> Path to a Rego policy file"},{"location":"documentation/api-reference/#returns_4","title":"Returns","text":"<p>Returns the Rego policy as a string.</p>"},{"location":"documentation/api-reference/#data-types","title":"Data Types","text":""},{"location":"documentation/api-reference/#plan","title":"<code>Plan</code>","text":"<p>Represents an agent plan to be validated.</p> <pre><code>from plan_lint.types import Plan, PlanStep\n\nplan = Plan(\n    goal=\"Process customer refund\",\n    steps=[\n        PlanStep(\n            id=\"step1\",\n            tool=\"db.query\",\n            args={\"query\": \"SELECT * FROM users\"}\n        ),\n        PlanStep(\n            id=\"step2\",\n            tool=\"notify.email\",\n            args={\"to\": \"user@example.com\", \"body\": \"Your refund is processed\"}\n        )\n    ],\n    context={\"user_id\": \"123\"}\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes","title":"Attributes","text":"Attribute Type Description <code>goal</code> <code>str</code> The goal or purpose of the plan <code>steps</code> <code>List[PlanStep]</code> Steps to be executed in the plan <code>context</code> <code>Optional[Dict[str, Any]]</code> Additional context for the plan <code>meta</code> <code>Optional[Dict[str, Any]]</code> Metadata about the plan"},{"location":"documentation/api-reference/#planstep","title":"<code>PlanStep</code>","text":"<p>Represents a single step in an agent plan.</p> <pre><code>from plan_lint.types import PlanStep\n\nstep = PlanStep(\n    id=\"step1\",\n    tool=\"db.query\",\n    args={\"query\": \"SELECT * FROM users\"},\n    on_fail=\"abort\"\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>id</code> <code>str</code> Unique identifier for the step <code>tool</code> <code>str</code> The tool to be used in this step <code>args</code> <code>Dict[str, Any]</code> Arguments to pass to the tool <code>on_fail</code> <code>str</code> Action to take if step fails (default: \"abort\")"},{"location":"documentation/api-reference/#policy","title":"<code>Policy</code>","text":"<p>Represents a policy for plan validation.</p> <pre><code>from plan_lint.types import Policy\n\npolicy = Policy(\n    allow_tools=[\"db.query_ro\", \"notify.email\"],\n    bounds={\"payments.transfer.amount\": [0.01, 1000.00]},\n    deny_tokens_regex=[\"password\", \"secret\", \"DROP TABLE\"],\n    max_steps=10,\n    risk_weights={\"TOOL_DENY\": 0.8, \"RAW_SECRET\": 0.6},\n    fail_risk_threshold=0.7\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes_2","title":"Attributes","text":"Attribute Type Description <code>allow_tools</code> <code>List[str]</code> List of allowed tools <code>bounds</code> <code>Dict[str, List[Union[int, float]]]</code> Parameter boundaries <code>deny_tokens_regex</code> <code>List[str]</code> Patterns to reject <code>max_steps</code> <code>int</code> Maximum allowed steps in a plan <code>risk_weights</code> <code>Dict[str, float]</code> Weights for different violation types <code>fail_risk_threshold</code> <code>float</code> Risk threshold for failing validation"},{"location":"documentation/api-reference/#planerror","title":"<code>PlanError</code>","text":"<p>Represents an error found during plan validation.</p> <pre><code>from plan_lint.types import PlanError, ErrorCode\n\nerror = PlanError(\n    step=1,\n    code=ErrorCode.TOOL_DENY,\n    msg=\"Tool 'db.write' is not allowed by policy\"\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes_3","title":"Attributes","text":"Attribute Type Description <code>step</code> <code>Optional[int]</code> Index of the step where the error was found <code>code</code> <code>ErrorCode</code> Error code <code>msg</code> <code>str</code> Human-readable error message"},{"location":"documentation/api-reference/#planwarning","title":"<code>PlanWarning</code>","text":"<p>Represents a warning found during plan validation.</p> <pre><code>from plan_lint.types import PlanWarning\n\nwarning = PlanWarning(\n    step=1,\n    code=\"PERFORMANCE\",\n    msg=\"This query might be slow for large datasets\"\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes_4","title":"Attributes","text":"Attribute Type Description <code>step</code> <code>Optional[int]</code> Index of the step where the warning was found <code>code</code> <code>str</code> Warning code <code>msg</code> <code>str</code> Human-readable warning message"},{"location":"documentation/api-reference/#errorcode","title":"<code>ErrorCode</code>","text":"<p>Enum of error codes for plan validation failures.</p> <pre><code>from plan_lint.types import ErrorCode\n\n# Available error codes\nErrorCode.SCHEMA_INVALID      # Invalid plan schema\nErrorCode.TOOL_DENY           # Unauthorized tool\nErrorCode.BOUND_VIOLATION     # Parameter out of bounds\nErrorCode.RAW_SECRET          # Sensitive data exposure\nErrorCode.LOOP_DETECTED       # Circular dependency detected\nErrorCode.MAX_STEPS_EXCEEDED  # Too many steps in plan\nErrorCode.MISSING_HANDLER     # Missing error handler\n</code></pre>"},{"location":"documentation/api-reference/#status","title":"<code>Status</code>","text":"<p>Enum of validation status values.</p> <pre><code>from plan_lint.types import Status\n\nStatus.PASS    # Plan passed validation\nStatus.WARN    # Plan has warnings but passed\nStatus.ERROR   # Plan failed validation\n</code></pre>"},{"location":"documentation/api-reference/#validationresult","title":"<code>ValidationResult</code>","text":"<p>Contains the results of plan validation.</p> <pre><code>from plan_lint.types import ValidationResult, Status\n\nresult = ValidationResult(\n    status=Status.ERROR,\n    risk_score=0.6,\n    errors=[error1, error2],\n    warnings=[warning1]\n)\n</code></pre>"},{"location":"documentation/api-reference/#attributes_5","title":"Attributes","text":"Attribute Type Description <code>status</code> <code>Status</code> Status of validation (PASS, WARN, ERROR) <code>risk_score</code> <code>float</code> Risk score between 0.0 and 1.0 <code>errors</code> <code>List[PlanError]</code> List of validation errors <code>warnings</code> <code>List[PlanWarning]</code> List of validation warnings"},{"location":"documentation/api-reference/#examples","title":"Examples","text":""},{"location":"documentation/api-reference/#basic-validation","title":"Basic Validation","text":"<pre><code>from plan_lint.core import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\nfrom plan_lint.types import Status\n\n# Load plan and policy\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.yaml\")\n\n# Validate plan\nresult = validate_plan(plan, policy)\n\n# Check results\nif result.status == Status.PASS:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Plan validation failed with risk score: {result.risk_score}\")\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg} ({error.code})\")\n</code></pre>"},{"location":"documentation/api-reference/#using-rego-policies","title":"Using Rego Policies","text":"<pre><code>from plan_lint.core import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\n\n# Load plan and policy\nplan = load_plan(\"plans/customer_refund.json\")\npolicy, rego_policy = load_policy(\"policies/security.rego\")\n\n# Validate with Rego policy\nresult = validate_plan(plan, policy, rego_policy=rego_policy, use_opa=True)\n\n# Check results\nif result.status == Status.PASS:\n    print(\"Plan is valid!\")\nelse:\n    print(f\"Plan validation failed with risk score: {result.risk_score}\")\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg} ({error.code})\")\n</code></pre>"},{"location":"documentation/api-reference/#creating-plans-programmatically","title":"Creating Plans Programmatically","text":"<pre><code>from plan_lint.core import validate_plan\nfrom plan_lint.types import Plan, PlanStep, Policy\n\n# Create a plan programmatically\nplan = Plan(\n    goal=\"Send account statement to user\",\n    steps=[\n        PlanStep(\n            id=\"step1\",\n            tool=\"db.query_ro\",\n            args={\n                \"query\": \"SELECT balance FROM accounts WHERE user_id = ?\",\n                \"params\": [\"user-123\"]\n            }\n        ),\n        PlanStep(\n            id=\"step2\",\n            tool=\"notify.email\",\n            args={\n                \"to\": \"user@example.com\",\n                \"subject\": \"Your Account Statement\",\n                \"body\": \"Your current balance is $5000\"\n            }\n        )\n    ],\n    context={\"user_id\": \"user-123\"}\n)\n\n# Create a policy programmatically\npolicy = Policy(\n    allow_tools=[\"db.query_ro\", \"notify.email\"],\n    bounds={},\n    deny_tokens_regex=[\"password\", \"secret\", \"DROP TABLE\"],\n    max_steps=5\n)\n\n# Validate plan\nresult = validate_plan(plan, policy)\n</code></pre>"},{"location":"documentation/api-reference/#calculating-risk-score","title":"Calculating Risk Score","text":"<p>```python from plan_lint.core import calculate_risk_score from plan_lint.types import PlanError, ErrorCode</p>"},{"location":"documentation/api-reference/#define-errors-and-risk-weights","title":"Define errors and risk weights","text":"<p>errors = [     PlanError(step=1, code=ErrorCode.RAW_SECRET, msg=\"Sensitive data detected\"),     PlanError(step=2, code=ErrorCode.BOUND_VIOLATION, msg=\"Amount exceeds maximum\") ]</p> <p>warnings = [] risk_weights = {     \"raw_secret\": 0.7,     \"bound_violation\": 0.4 }</p>"},{"location":"documentation/api-reference/#calculate-risk-score","title":"Calculate risk score","text":"<p>risk_score = calculate_risk_score(errors, warnings, risk_weights) print(f\"Risk score: {risk_score}\")  # Output: Risk score: 1.0 </p>"},{"location":"documentation/custom-rule-development/","title":"Custom Rule Development","text":"<p>This page guides you through creating custom validation rules for Plan-Lint.</p>"},{"location":"documentation/custom-rule-development/#overview","title":"Overview","text":"<p>Plan-Lint allows you to extend its validation capabilities by creating custom rules. Custom rules can help you enforce organization-specific policies, business logic, or unique security requirements not covered by built-in rules.</p> <p>There are three main approaches to developing custom rules for Plan-Lint:</p> <ol> <li>YAML Rules: Simple, declarative rules for common validation patterns</li> <li>Rego Policies: Complex, powerful rules using the Open Policy Agent's Rego language</li> <li>Python Extensions: Programmatic rules with full access to the Plan-Lint API</li> </ol>"},{"location":"documentation/custom-rule-development/#creating-yaml-rules","title":"Creating YAML Rules","text":"<p>YAML rules provide a straightforward way to define validation logic using a declarative syntax. They are best suited for simple validation scenarios.</p>"},{"location":"documentation/custom-rule-development/#basic-structure","title":"Basic Structure","text":"<p>A basic YAML policy file looks like this:</p> <pre><code># custom_policy.yaml\nallow_tools:\n  - db.query_ro\n  - payments.transfer.small\n  - notify.email\n\nbounds:\n  payments.transfer.small.amount: [0.01, 100.00]\n\ndeny_tokens_regex:\n  - \"DROP TABLE\"\n  - \"1=1\"\n  - \"password\"\n  - \"secret\"\n\nrisk_weights:\n  sql_injection: 0.8\n  sensitive_data_exposure: 0.7\n  unauthorized_tool: 0.9\n\nfail_risk_threshold: 0.5\nmax_steps: 15\n</code></pre>"},{"location":"documentation/custom-rule-development/#available-rule-types","title":"Available Rule Types","text":"<p>YAML policies support several rule types:</p> Rule Type Description Example <code>allow_tools</code> List of allowed tools <code>- db.query_ro</code> <code>bounds</code> Parameter boundaries <code>payments.transfer.amount: [0.01, 1000.00]</code> <code>deny_tokens_regex</code> Patterns to reject <code>- \"DROP TABLE\"</code> <code>risk_weights</code> Custom risk scores <code>sql_injection: 0.8</code> <code>fail_risk_threshold</code> Maximum tolerated risk <code>0.5</code> <code>max_steps</code> Maximum plan steps <code>15</code>"},{"location":"documentation/custom-rule-development/#custom-tool-patterns","title":"Custom Tool Patterns","text":"<p>You can define custom tool patterns to match specific tool name patterns:</p> <pre><code># Custom tool pattern for small payments\ntool_patterns:\n  payments.transfer.small:\n    pattern: \"payments.transfer\"\n    conditions:\n      - \"parameters.amount &lt;= 100.0\"\n</code></pre> <p>This defines a virtual tool type <code>payments.transfer.small</code> that will match any <code>payments.transfer</code> tool with an amount parameter less than or equal to 100.0.</p>"},{"location":"documentation/custom-rule-development/#using-custom-yaml-rules","title":"Using Custom YAML Rules","text":"<p>To use your custom YAML rules:</p> <pre><code>from plan_lint import validate_plan\n\nplan = {\n    \"goal\": \"Process customer refund\",\n    \"steps\": [\n        # Plan steps here\n    ]\n}\n\nresult = validate_plan(plan, policy_files=[\"path/to/custom_policy.yaml\"])\n</code></pre>"},{"location":"documentation/custom-rule-development/#creating-rego-policies","title":"Creating Rego Policies","text":"<p>Rego is a powerful policy language that provides more flexibility and expressiveness than YAML.</p>"},{"location":"documentation/custom-rule-development/#basic-structure_1","title":"Basic Structure","text":"<p>A basic Rego policy file looks like this:</p> <pre><code># custom_policy.rego\npackage planlint\n\nimport future.keywords.in\n\n# Default deny\ndefault allow = false\n\n# Set of allowed tools\nallowed_tools = {\n    \"db.query_ro\",\n    \"payments.transfer\",\n    \"notify.email\"\n}\n\n# Allow if no violations\nallow {\n    count(violations) == 0\n}\n\n# Define violations\nviolations[result] {\n    # Get the step\n    step := input.plan.steps[_]\n\n    # Check if tool is allowed\n    not step.tool in allowed_tools\n\n    # Create violation result\n    result := {\n        \"rule\": \"unauthorized_tool\",\n        \"message\": sprintf(\"Tool '%s' is not authorized\", [step.tool]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n\n# Example parameter boundary check\nviolations[result] {\n    # Get the step\n    step := input.plan.steps[_]\n    step.tool == \"payments.transfer\"\n\n    # Check amount boundaries\n    amount := to_number(step.parameters.amount)\n    amount &gt; 1000.00\n\n    # Create violation result\n    result := {\n        \"rule\": \"parameter_bounds\",\n        \"message\": sprintf(\"Amount %f exceeds maximum allowed (1000.00)\", [amount]),\n        \"severity\": \"medium\",\n        \"step_id\": step.id\n    }\n}\n\n# Calculate risk score (0.0 to 1.0)\nrisk_score = score {\n    # Define risk weights for different violations\n    weights := {\n        \"unauthorized_tool\": 0.9,\n        \"parameter_bounds\": 0.6,\n        \"sql_injection\": 0.8\n    }\n\n    # Sum up risk weights for all violations\n    total_weight := sum([weights[v.rule] | v := violations[_]; v.rule in weights])\n\n    # Cap at 1.0\n    score := min(total_weight, 1.0)\n}\n</code></pre>"},{"location":"documentation/custom-rule-development/#accessing-plan-data","title":"Accessing Plan Data","text":"<p>In Rego policies, you can access the plan data through the <code>input</code> document:</p> <pre><code># Access plan goal\ngoal := input.plan.goal\n\n# Access plan steps\nsteps := input.plan.steps\n\n# Access context\nuser_role := input.context.user_role\n\n# Access a specific step\nfirst_step := input.plan.steps[0]\n\n# Access a parameter in a step\namount := input.plan.steps[0].parameters.amount\n</code></pre>"},{"location":"documentation/custom-rule-development/#advanced-rego-examples","title":"Advanced Rego Examples","text":""},{"location":"documentation/custom-rule-development/#context-based-authorization","title":"Context-Based Authorization","text":"<pre><code>violations[result] {\n    # Get user role from context\n    role := input.context.user_role\n\n    # Role-specific allowed tools\n    allowed_tools_by_role := {\n        \"admin\": {\"db.query\", \"db.write\", \"payments.transfer\"},\n        \"editor\": {\"db.query\", \"payments.view\"},\n        \"viewer\": {\"db.query_ro\"}\n    }\n\n    # Get allowed tools for this role\n    role_tools := allowed_tools_by_role[role]\n\n    # Check each step\n    step := input.plan.steps[_]\n    not step.tool in role_tools\n\n    result := {\n        \"rule\": \"role_authorization\",\n        \"message\": sprintf(\"Role '%s' is not authorized to use tool '%s'\", [role, step.tool]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n</code></pre>"},{"location":"documentation/custom-rule-development/#dependency-chain-analysis","title":"Dependency Chain Analysis","text":"<pre><code># Detect circular dependencies\nviolations[result] {\n    # Get a step\n    step := input.plan.steps[_]\n\n    # Check if this step is in its own dependency chain\n    is_circular := depends_on_self(step.id, step.depends_on)\n    is_circular\n\n    result := {\n        \"rule\": \"circular_dependency\",\n        \"message\": sprintf(\"Step '%s' has a circular dependency\", [step.id]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n\n# Recursive function to check for circular dependencies\ndepends_on_self(id, deps) {\n    # Direct dependency on self\n    id in deps\n} else {\n    # Check indirect dependencies\n    some dep in deps\n    some step in input.plan.steps\n    step.id == dep\n    step.depends_on\n    depends_on_self(id, step.depends_on)\n}\n</code></pre>"},{"location":"documentation/custom-rule-development/#using-custom-rego-policies","title":"Using Custom Rego Policies","text":"<p>To use your custom Rego policies:</p> <pre><code>from plan_lint import validate_plan\n\nplan = {\n    \"goal\": \"Process customer refund\",\n    \"steps\": [\n        # Plan steps here\n    ]\n}\n\nresult = validate_plan(plan, policy_files=[\"path/to/custom_policy.rego\"])\n</code></pre>"},{"location":"documentation/custom-rule-development/#creating-python-extensions","title":"Creating Python Extensions","text":"<p>For the most complex validation logic, you can write custom Python rules that have full access to the Plan-Lint API.</p>"},{"location":"documentation/custom-rule-development/#basic-python-rule","title":"Basic Python Rule","text":"<pre><code>from typing import List, Dict, Any\nfrom plan_lint.types import Plan, PlanError, ErrorCode\n\ndef check_custom_requirements(plan: Plan, context: Dict[str, Any] = None) -&gt; List[PlanError]:\n    \"\"\"Custom rule to check specific business requirements.\"\"\"\n    errors = []\n\n    # Example: Ensure payments to certain accounts are limited\n    for i, step in enumerate(plan.steps):\n        if step.tool == \"payments.transfer\":\n            amount = float(step.parameters.get(\"amount\", 0))\n            account = step.parameters.get(\"account\", \"\")\n\n            # Check for high-risk accounts\n            high_risk_accounts = [\"ACC123\", \"ACC456\"]\n            if account in high_risk_accounts and amount &gt; 500:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=f\"Payments to high-risk account {account} must be less than $500 (found ${amount})\",\n                    )\n                )\n\n    return errors\n</code></pre>"},{"location":"documentation/custom-rule-development/#integrating-custom-python-rules","title":"Integrating Custom Python Rules","text":"<p>To use your custom Python rules, create a module and import it into your validation code:</p> <pre><code>from plan_lint import validate_plan\nfrom my_custom_rules import check_custom_requirements\n\nplan = {\n    \"goal\": \"Process customer refund\",\n    \"steps\": [\n        # Plan steps here\n    ]\n}\n\n# Register custom rule with the validator\ncustom_validators = [check_custom_requirements]\n\nresult = validate_plan(plan, custom_validators=custom_validators)\n</code></pre>"},{"location":"documentation/custom-rule-development/#advanced-python-rule-examples","title":"Advanced Python Rule Examples","text":""},{"location":"documentation/custom-rule-development/#cross-step-correlation","title":"Cross-Step Correlation","text":"<pre><code>def check_cross_step_correlation(plan: Plan, context: Dict[str, Any] = None) -&gt; List[PlanError]:\n    \"\"\"Check that the email recipient matches the transaction recipient.\"\"\"\n    errors = []\n\n    # Find payment and notification steps\n    payment_steps = []\n    notification_steps = []\n\n    for i, step in enumerate(plan.steps):\n        if step.tool == \"payments.transfer\":\n            payment_steps.append((i, step))\n        elif step.tool == \"notify.email\":\n            notification_steps.append((i, step))\n\n    # Check that each payment has a matching notification\n    for i, payment_step in payment_steps:\n        recipient_account = payment_step.parameters.get(\"recipient_account\", \"\")\n        recipient_email = None\n\n        # Try to find the recipient's email from context\n        if context and \"accounts\" in context:\n            for account in context[\"accounts\"]:\n                if account.get(\"account_number\") == recipient_account:\n                    recipient_email = account.get(\"email\")\n\n        if recipient_email:\n            # Check if there's a notification to the correct recipient\n            notification_found = False\n            for j, notification_step in notification_steps:\n                if notification_step.parameters.get(\"to\") == recipient_email:\n                    notification_found = True\n                    break\n\n            if not notification_found:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=f\"Payment to account {recipient_account} must be accompanied by an email notification to {recipient_email}\",\n                    )\n                )\n\n    return errors\n</code></pre>"},{"location":"documentation/custom-rule-development/#time-based-restrictions","title":"Time-Based Restrictions","text":"<pre><code>import datetime\n\ndef check_time_restrictions(plan: Plan, context: Dict[str, Any] = None) -&gt; List[PlanError]:\n    \"\"\"Check that high-value transfers are only scheduled during business hours.\"\"\"\n    errors = []\n\n    # Define business hours\n    business_start = datetime.time(9, 0)  # 9:00 AM\n    business_end = datetime.time(17, 0)   # 5:00 PM\n\n    # Get current time, or use time from context if provided\n    current_time = datetime.datetime.now().time()\n    if context and \"current_time\" in context:\n        current_time = context[\"current_time\"]\n\n    # Check each payment step\n    for i, step in enumerate(plan.steps):\n        if step.tool == \"payments.transfer\":\n            amount = float(step.parameters.get(\"amount\", 0))\n\n            # Check if it's a high-value transfer (over $10,000)\n            if amount &gt; 10000:\n                # Check if current time is within business hours\n                is_business_hours = (\n                    current_time &gt;= business_start and \n                    current_time &lt;= business_end\n                )\n\n                if not is_business_hours:\n                    errors.append(\n                        PlanError(\n                            step=i,\n                            code=ErrorCode.CUSTOM,\n                            msg=f\"High-value transfers (${amount}) can only be scheduled during business hours (9:00 AM - 5:00 PM)\",\n                        )\n                    )\n\n    return errors\n</code></pre>"},{"location":"documentation/custom-rule-development/#best-practices-for-custom-rules","title":"Best Practices for Custom Rules","text":""},{"location":"documentation/custom-rule-development/#rule-design","title":"Rule Design","text":"<ol> <li>Focus on Specific Concerns: Each rule should address a specific security or operational concern.</li> <li>Balance Security and Usability: Rules that are too restrictive may lead to workarounds.</li> <li>Provide Clear Error Messages: Help users understand why a plan failed validation and how to fix it.</li> <li>Use Appropriate Severity Levels: Use severity levels (e.g., high, medium, low) to indicate the importance of a violation.</li> </ol>"},{"location":"documentation/custom-rule-development/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Optimize Rule Evaluation: For Rego policies, use indexing to improve performance:    <pre><code># Inefficient\nviolations[result] {\n    step := input.plan.steps[_]\n    step.tool == \"db.query\"\n    # ...\n}\n\n# Efficient (indexed)\ndb_query_steps[step] {\n    step := input.plan.steps[_]\n    step.tool == \"db.query\"\n}\n\nviolations[result] {\n    step := db_query_steps[_]\n    # ...\n}\n</code></pre></p> </li> <li> <p>Minimize External API Calls: If your rules need to make external API calls, consider caching results.</p> </li> </ol>"},{"location":"documentation/custom-rule-development/#testing-custom-rules","title":"Testing Custom Rules","text":"<p>Always test your custom rules with both valid and invalid plans:</p> <pre><code>import unittest\nfrom plan_lint import validate_plan\nfrom my_custom_rules import check_custom_requirements\n\nclass TestCustomRules(unittest.TestCase):\n    def test_valid_plan(self):\n        plan = {\n            \"goal\": \"Process small refund\",\n            \"steps\": [\n                {\n                    \"id\": \"step1\",\n                    \"tool\": \"payments.transfer\",\n                    \"parameters\": {\n                        \"amount\": \"50.00\",\n                        \"account\": \"ACC789\"\n                    }\n                }\n            ]\n        }\n\n        result = validate_plan(\n            plan, \n            custom_validators=[check_custom_requirements]\n        )\n\n        self.assertTrue(result.valid)\n        self.assertEqual(len(result.errors), 0)\n\n    def test_invalid_plan(self):\n        plan = {\n            \"goal\": \"Process large refund\",\n            \"steps\": [\n                {\n                    \"id\": \"step1\",\n                    \"tool\": \"payments.transfer\",\n                    \"parameters\": {\n                        \"amount\": \"1000.00\",\n                        \"account\": \"ACC123\"  # High-risk account\n                    }\n                }\n            ]\n        }\n\n        result = validate_plan(\n            plan, \n            custom_validators=[check_custom_requirements]\n        )\n\n        self.assertFalse(result.valid)\n        self.assertEqual(len(result.errors), 1)\n        self.assertIn(\"high-risk account\", result.errors[0].msg)\n\nif __name__ == \"__main__\":\n    unittest.main()\n</code></pre>"},{"location":"documentation/custom-rule-development/#packaging-and-distribution","title":"Packaging and Distribution","text":"<p>For organization-wide use, consider packaging your custom rules:</p>"},{"location":"documentation/custom-rule-development/#directory-structure","title":"Directory Structure","text":"<pre><code>my-custom-rules/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_custom_rules/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 python_rules.py\n\u2502       \u2514\u2500\u2500 policies/\n\u2502           \u251c\u2500\u2500 custom_policy.yaml\n\u2502           \u2514\u2500\u2500 custom_policy.rego\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_rules.py\n</code></pre>"},{"location":"documentation/custom-rule-development/#package-installation","title":"Package Installation","text":"<pre><code>pip install my-custom-rules\n</code></pre>"},{"location":"documentation/custom-rule-development/#usage-after-packaging","title":"Usage After Packaging","text":"<pre><code>from plan_lint import validate_plan\nfrom my_custom_rules import get_custom_validators, get_policy_files\n\nplan = {\n    \"goal\": \"Process customer refund\",\n    \"steps\": [\n        # Plan steps here\n    ]\n}\n\nresult = validate_plan(\n    plan, \n    custom_validators=get_custom_validators(),\n    policy_files=get_policy_files()\n)\n</code></pre>"},{"location":"documentation/custom-rule-development/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>To enforce policy compliance in your CI/CD pipeline:</p> <pre><code># .github/workflows/validate-plans.yml\nname: Validate Agent Plans\n\non:\n  pull_request:\n    paths:\n      - 'plans/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint my-custom-rules\n\n      - name: Validate plans\n        run: |\n          python -c \"\n          import glob\n          import json\n          import sys\n          from plan_lint import validate_plan\n          from my_custom_rules import get_custom_validators, get_policy_files\n\n          failed = False\n          for plan_file in glob.glob('plans/**/*.json'):\n              with open(plan_file, 'r') as f:\n                  plan = json.load(f)\n\n              result = validate_plan(\n                  plan, \n                  custom_validators=get_custom_validators(),\n                  policy_files=get_policy_files()\n              )\n\n              if not result.valid:\n                  print(f'\u274c {plan_file} failed validation:')\n                  for error in result.errors:\n                      print(f'  - {error.msg}')\n                  failed = True\n              else:\n                  print(f'\u2705 {plan_file} passed validation')\n\n          if failed:\n              sys.exit(1)\n          \"\n</code></pre>"},{"location":"documentation/custom-rule-development/#conclusion","title":"Conclusion","text":"<p>Custom rules allow you to tailor Plan-Lint's validation to your specific requirements. By using the appropriate rule type (YAML, Rego, or Python) for your needs, you can create a comprehensive validation framework that ensures all agent-generated plans comply with your security and operational policies.</p> <p>For more examples and detailed API documentation, refer to the API Reference section and the Examples page.</p>"},{"location":"documentation/mcp-integration/","title":"Integrating Plan-Lint with MCP Servers","text":"<p>This guide explains how to integrate plan-lint with Model Context Protocol (MCP) servers to create a comprehensive security architecture that leverages both authentication and behavioral validation.</p>"},{"location":"documentation/mcp-integration/#understanding-the-relationship","title":"Understanding the Relationship","text":"<p>MCP servers and plan-lint serve complementary security functions:</p> Feature MCP OAuth 2.1 Plan-Lint Primary Function Authentication &amp; Authorization Behavior Validation Validates Who can access resources What actions are allowed Security Layer External boundary Internal safety When Applied Before access is granted Before plans execute"},{"location":"documentation/mcp-integration/#security-architecture","title":"Security Architecture","text":"<p>When combined, MCP's OAuth and plan-lint create a defense-in-depth approach:</p> <pre><code>graph LR\n    A[Client Request] --&gt; B[MCP OAuth Authentication]\n    B --&gt;|Authenticated| C[Plan Generation]\n    C --&gt; D[Plan-Lint Validation]\n    D --&gt;|Valid Plan| E[Plan Execution]\n    D --&gt;|Invalid Plan| F[Rejection]\n    B --&gt;|Unauthenticated| G[Auth Error]\n</code></pre>"},{"location":"documentation/mcp-integration/#integration-patterns","title":"Integration Patterns","text":""},{"location":"documentation/mcp-integration/#1-mcp-tool-wrapper-pattern","title":"1. MCP Tool Wrapper Pattern","text":"<p>The most straightforward integration is to wrap each MCP tool with plan-lint validation:</p> <pre><code>from plan_lint.loader import load_policy\nfrom plan_lint.core import validate_plan\nfrom plan_lint.types import Plan\n\nclass PaymentTool:\n    def __init__(self):\n        # Load policy once during initialization\n        self.policy, self.rego_policy = load_policy(\"payment_policy.rego\")\n\n    @mcp_server.tool(\"payments.transfer\")\n    def transfer(self, request):\n        # Extract OAuth context from MCP request\n        oauth_context = request.get_oauth_context()\n\n        # Convert the request to a plan\n        plan = Plan(\n            goal=\"Transfer funds\",\n            context={\n                \"user_id\": oauth_context[\"sub\"], \n                \"role\": oauth_context[\"scope\"].split(\" \")\n            },\n            steps=[\n                {\n                    \"id\": \"transfer-step\",\n                    \"tool\": \"payments.transfer\",\n                    \"args\": request.get_args()\n                }\n            ]\n        )\n\n        # Validate plan\n        result = validate_plan(plan, self.policy, rego_policy=self.rego_policy)\n\n        if not result.valid:\n            return {\n                \"status\": \"error\",\n                \"code\": \"POLICY_VIOLATION\",\n                \"message\": f\"Plan validation failed: {result.errors}\"\n            }\n\n        # Perform the actual transfer if validation passed\n        # ...\n</code></pre>"},{"location":"documentation/mcp-integration/#2-middleware-pattern","title":"2. Middleware Pattern","text":"<p>For MCP servers with middleware support, you can implement plan-lint as a validation layer:</p> <pre><code>class PlanLintMiddleware:\n    def __init__(self, policy_path):\n        self.policy, self.rego_policy = load_policy(policy_path)\n\n    async def __call__(self, request, next):\n        # Skip validation for non-plan requests\n        if not request.is_plan_request():\n            return await next(request)\n\n        # Extract plan from request\n        plan = request.get_plan()\n\n        # Validate plan\n        result = validate_plan(plan, self.policy, rego_policy=self.rego_policy)\n\n        if not result.valid:\n            return MCPResponse(\n                status=403,\n                body={\n                    \"error\": \"Policy Violation\",\n                    \"details\": [str(error) for error in result.errors]\n                }\n            )\n\n        # Continue to the next middleware or handler\n        return await next(request)\n\n# Register middleware with MCP server\nmcp_server.add_middleware(PlanLintMiddleware(\"security_policy.rego\"))\n</code></pre>"},{"location":"documentation/mcp-integration/#3-oauth-aware-rego-policies","title":"3. OAuth-Aware Rego Policies","text":"<p>Create dynamic Rego policies that incorporate OAuth context:</p> <pre><code>package planlint\n\n# Import OAuth scopes into policy evaluation\noauth_scopes := split(input.context.oauth_scopes, \" \")\n\n# Check if user has required scope\nhas_scope(required_scope) {\n    some scope\n    oauth_scopes[scope] == required_scope\n}\n\n# Different rules based on OAuth scopes\nallow_write_operations if {\n    has_scope(\"write:data\")\n}\n\n# Validate SQL based on scopes\ncheck_sql_operation(i) = violation if {\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Extract operation type\n    query := lower(step.args.query)\n    contains(query, \"insert\") \n    contains(query, \"update\")\n    contains(query, \"delete\")\n\n    # Check if write operations are allowed\n    not allow_write_operations\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_SCOPE\",\n        \"msg\": \"Write operations require the write:data scope\"\n    }\n}\n</code></pre>"},{"location":"documentation/mcp-integration/#using-mcp-oauth-tokens-with-plan-lint","title":"Using MCP OAuth Tokens with Plan-Lint","text":"<p>When validating plans in an MCP context, the OAuth token can provide valuable context:</p> <pre><code>def validate_mcp_plan(plan_json, auth_token):\n    # Decode and validate the OAuth token\n    oauth_claims = decode_verify_token(auth_token)\n\n    # Parse the plan\n    plan_data = json.loads(plan_json)\n\n    # Enhance plan context with OAuth information\n    if \"context\" not in plan_data:\n        plan_data[\"context\"] = {}\n\n    # Add OAuth context to plan\n    plan_data[\"context\"].update({\n        \"user_id\": oauth_claims[\"sub\"],\n        \"oauth_scopes\": oauth_claims[\"scope\"],\n        \"oauth_client_id\": oauth_claims[\"client_id\"],\n        \"oauth_issued_at\": oauth_claims[\"iat\"],\n        \"oauth_expires_at\": oauth_claims[\"exp\"]\n    })\n\n    # Create Plan object\n    plan = Plan(**plan_data)\n\n    # Load policy\n    policy, rego_policy = load_policy(\"security_policy.rego\")\n\n    # Validate with context-aware policy\n    result = validate_plan(plan, policy, rego_policy=rego_policy)\n\n    return result\n</code></pre>"},{"location":"documentation/mcp-integration/#example-role-based-security-policy","title":"Example: Role-Based Security Policy","text":"<p>Here's a complete example of a Rego policy that leverages OAuth roles:</p> <pre><code>package planlint\n\ndefault allow = false\ndefault violations = []\ndefault risk_score = 0.0\n\n# Define role-based permissions\nrole_permissions = {\n    \"admin\": {\n        \"max_transaction_amount\": 50000,\n        \"can_query_all_records\": true,\n        \"can_modify_data\": true\n    },\n    \"manager\": {\n        \"max_transaction_amount\": 10000,\n        \"can_query_all_records\": true,\n        \"can_modify_data\": false\n    },\n    \"user\": {\n        \"max_transaction_amount\": 1000,\n        \"can_query_all_records\": false,\n        \"can_modify_data\": false\n    }\n}\n\n# Get role from OAuth context, default to lowest privilege\nuser_role = role {\n    role := input.context.oauth_role\n    role_permissions[role]\n}\n\nuser_role = \"user\" {\n    not input.context.oauth_role\n}\n\nnot_input.context.oauth_role {\n    not input.context.oauth_role\n}\n\n# Allow rule based on violations and risk score\nallow if {\n    count(violations) == 0\n    risk_score &lt; 0.8\n}\n\n# Calculate risk score\nrisk_score = total {\n    total := sum([violation.risk_score | violation = violations[_]])\n}\n\n# Validate transaction amounts based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"payments.transfer\"\n\n    amount := to_number(step.args.amount)\n    max_amount := role_permissions[user_role].max_transaction_amount\n\n    amount &gt; max_amount\n\n    violation := {\n        \"step\": i,\n        \"code\": \"EXCESSIVE_AMOUNT\",\n        \"msg\": sprintf(\"Amount %f exceeds maximum limit %f for role %s\", \n              [amount, max_amount, user_role]),\n        \"risk_score\": 0.7\n    }\n}\n\n# Validate data access based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Check for unrestricted queries\n    query := lower(step.args.query)\n    contains(query, \"select * from users\")\n\n    # Verify permission to query all records\n    not role_permissions[user_role].can_query_all_records\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_PERMISSION\",\n        \"msg\": sprintf(\"Role %s cannot query all user records\", [user_role]),\n        \"risk_score\": 0.6\n    }\n}\n\n# Validate data modification based on role\nviolations[violation] {\n    some i\n    step := input.steps[i]\n    step.tool == \"database.query\"\n\n    # Check for data modification operations\n    query := lower(step.args.query)\n    contains(query, \"update \") \n\n    # Verify permission to modify data\n    not role_permissions[user_role].can_modify_data\n\n    violation := {\n        \"step\": i,\n        \"code\": \"INSUFFICIENT_PERMISSION\",\n        \"msg\": sprintf(\"Role %s cannot modify data\", [user_role]),\n        \"risk_score\": 0.8\n    }\n}\n</code></pre>"},{"location":"documentation/mcp-integration/#benefits-of-the-integrated-approach","title":"Benefits of the Integrated Approach","text":"<ol> <li>Defense in Depth: Multiple security layers prevent a single point of failure</li> <li>Contextual Security: Access decisions informed by both identity and behavior</li> <li>Fine-grained Control: Different validation rules for different user roles</li> <li>Audit Trail: Complete record of who did what and whether it was allowed</li> <li>Enhanced Privacy: Sensitive operations can be blocked even for authenticated users</li> </ol>"},{"location":"documentation/mcp-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Always run plan-lint validation after MCP OAuth authentication</li> <li>Pass relevant OAuth context to the plan to inform validation decisions</li> <li>Create role-specific policies that align with your OAuth scope design</li> <li>Use consistent error handling between both systems</li> <li>Log both authentication and validation decisions for complete audit trails</li> <li>Implement comprehensive testing for both authentication and validation layers</li> </ol>"},{"location":"documentation/mcp-integration/#advanced-integration-topics","title":"Advanced Integration Topics","text":"<ul> <li>Setting up OPA Server for Validation</li> <li>CI/CD Pipeline Integration</li> <li>Custom Rule Development </li> </ul>"},{"location":"documentation/plan-structure/","title":"Plan Structure","text":"<p>This page explains the structure of plans that can be validated by Plan-Lint.</p>"},{"location":"documentation/plan-structure/#overview","title":"Overview","text":"<p>A plan in Plan-Lint represents a sequence of steps that an AI agent intends to execute. The plan is structured as a JSON object with specific fields that allow Plan-Lint to analyze it for potential security and operational issues.</p>"},{"location":"documentation/plan-structure/#plan-format","title":"Plan Format","text":"<p>Plans are represented as JSON objects with the following structure:</p> <pre><code>{\n  \"goal\": \"Human-readable description of what the plan aims to accomplish\",\n  \"steps\": [\n    {\n      \"id\": \"unique-step-identifier\",\n      \"tool\": \"tool_to_execute\",\n      \"parameters\": {\n        \"param1\": \"value1\",\n        \"param2\": \"value2\"\n      },\n      \"on_fail\": \"abort\",\n      \"depends_on\": [\"previous-step-id\"]\n    }\n  ],\n  \"context\": {\n    \"key1\": \"value1\",\n    \"key2\": \"value2\"\n  },\n  \"meta\": {\n    \"planner\": \"model-name\",\n    \"created_at\": \"timestamp\"\n  }\n}\n</code></pre>"},{"location":"documentation/plan-structure/#required-fields","title":"Required Fields","text":"<ul> <li>steps: An array of execution steps that make up the plan (required)</li> </ul>"},{"location":"documentation/plan-structure/#optional-fields","title":"Optional Fields","text":"<ul> <li>goal: A human-readable description of what the plan aims to accomplish</li> <li>context: Additional context information relevant to the plan</li> <li>meta: Metadata about the plan such as which model generated it</li> </ul>"},{"location":"documentation/plan-structure/#step-structure","title":"Step Structure","text":"<p>Each step in the plan represents an individual action to be executed. Steps have the following structure:</p> <pre><code>{\n  \"id\": \"step1\",\n  \"tool\": \"tool_name\",\n  \"parameters\": {\n    \"param1\": \"value1\",\n    \"param2\": \"value2\"\n  },\n  \"on_fail\": \"abort\",\n  \"depends_on\": [\"step0\"]\n}\n</code></pre>"},{"location":"documentation/plan-structure/#required-fields_1","title":"Required Fields","text":"<ul> <li>id: A unique identifier for the step (string)</li> <li>tool: The name of the tool or function to execute (string)</li> <li>parameters: An object containing the parameters for the tool execution (object)</li> </ul>"},{"location":"documentation/plan-structure/#optional-fields_1","title":"Optional Fields","text":"<ul> <li>on_fail: What to do if this step fails (options: \"abort\", \"continue\")</li> <li>depends_on: Array of step IDs that must complete before this step can execute</li> </ul>"},{"location":"documentation/plan-structure/#parameter-references","title":"Parameter References","text":"<p>Parameters can reference the outputs of previous steps using the syntax <code>{{step_id.result}}</code> or <code>${step_id.result}</code>. For example:</p> <pre><code>{\n  \"id\": \"step2\",\n  \"tool\": \"send_email\",\n  \"parameters\": {\n    \"body\": \"The account balance is {{step1.result.balance}}\",\n    \"to\": \"${step1.result.email}\"\n  },\n  \"depends_on\": [\"step1\"]\n}\n</code></pre> <p>This allows steps to use the outputs of previous steps as inputs, creating a workflow.</p>"},{"location":"documentation/plan-structure/#special-tool-patterns","title":"Special Tool Patterns","text":"<p>Plan-Lint recognizes special patterns in the tool names to apply specific validations:</p> <ul> <li>db.query: Database query operations</li> <li>db.query_ro: Read-only database queries</li> <li>db.write: Database write operations</li> <li>payments.: Payment operations (e.g., <code>payments.transfer</code>)</li> <li>notify.: Notification operations (e.g., <code>notify.email</code>)</li> <li>file.: File operations</li> </ul> <p>These patterns help Plan-Lint apply the appropriate security checks based on the type of operation.</p>"},{"location":"documentation/plan-structure/#example-plan","title":"Example Plan","text":"<p>Here's a complete example of a plan that queries a database and sends an email:</p> <pre><code>{\n  \"goal\": \"Send monthly account statement to user\",\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"db.query_ro\",\n      \"parameters\": {\n        \"query\": \"SELECT balance, email FROM accounts WHERE user_id = $1\",\n        \"args\": [\"user-123\"]\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"notify.email\",\n      \"parameters\": {\n        \"to\": \"{{step1.result.email}}\",\n        \"subject\": \"Your Monthly Statement\",\n        \"body\": \"Your current balance is ${{step1.result.balance}}\"\n      },\n      \"depends_on\": [\"step1\"]\n    }\n  ],\n  \"context\": {\n    \"user_id\": \"user-123\",\n    \"month\": \"January 2025\"\n  },\n  \"meta\": {\n    \"planner\": \"gpt-4o\",\n    \"created_at\": \"2025-01-01T00:00:00Z\"\n  }\n}\n</code></pre>"},{"location":"documentation/plan-structure/#best-practices","title":"Best Practices","text":"<p>When working with plans, follow these best practices:</p> <ol> <li>Use Unique IDs: Ensure each step has a unique ID.</li> <li>Explicit Dependencies: Always specify step dependencies using the <code>depends_on</code> field.</li> <li>Minimal Permissions: Use the most restrictive tool possible (e.g., <code>db.query_ro</code> instead of <code>db.query</code>).</li> <li>Parameter Sanitization: Ensure user inputs are properly sanitized before including them in step parameters.</li> <li>Clear Goal Description: Include a clear, human-readable goal to make the plan's purpose obvious.</li> </ol>"},{"location":"documentation/plan-structure/#api-usage","title":"API Usage","text":"<p>Here's how to create and validate a plan using the Plan-Lint API:</p> <pre><code>from plan_lint import validate_plan\nfrom plan_lint.types import Plan, PlanStep\n\n# Create a plan programmatically\nplan = Plan(\n    goal=\"Send notification to user\",\n    steps=[\n        PlanStep(\n            id=\"step1\",\n            tool=\"db.query_ro\",\n            parameters={\n                \"query\": \"SELECT email FROM users WHERE id = $1\",\n                \"args\": [\"user-456\"]\n            }\n        ),\n        PlanStep(\n            id=\"step2\",\n            tool=\"notify.email\",\n            parameters={\n                \"to\": \"{{step1.result.email}}\",\n                \"subject\": \"Notification\",\n                \"body\": \"This is a notification\"\n            },\n            depends_on=[\"step1\"]\n        )\n    ],\n    context={\"user_id\": \"user-456\"}\n)\n\n# Validate the plan\nresult = validate_plan(plan)\n\nif result.valid:\n    print(\"Plan is valid!\")\nelse:\n    print(\"Plan validation failed:\")\n    for violation in result.violations:\n        print(f\"- {violation.rule}: {violation.message}\")\n</code></pre>"},{"location":"documentation/policy-formats/","title":"Policy Formats","text":"<p>This page explains the different formats supported by Plan-Lint for defining policies.</p>"},{"location":"documentation/policy-formats/#overview","title":"Overview","text":"<p>Plan-Lint supports two main policy formats:</p> <ol> <li>YAML Policies: A simpler, declarative format for defining basic rules</li> <li>Rego Policies: A powerful policy language for expressing complex rules</li> </ol> <p>Each format has its own advantages, and you can choose the one that best fits your needs.</p>"},{"location":"documentation/policy-formats/#yaml-policies","title":"YAML Policies","text":"<p>YAML policies provide a simple, declarative way to define validation rules. They are easy to write and understand, making them a good choice for basic validation scenarios.</p>"},{"location":"documentation/policy-formats/#basic-structure","title":"Basic Structure","text":"<p>YAML policies are structured as key-value pairs defining rules:</p> <pre><code># List of allowed tools\nallow_tools:\n  - db.query_ro\n  - notify.email\n  - payments.transfer\n\n# Parameter boundaries\nbounds:\n  payments.transfer.amount: [0.01, 10000]  # Numeric boundaries\n  notify.email.to_list: [1, 100]           # List size boundaries\n\n# Patterns to detect\ndeny_tokens_regex:\n  - \"password\"\n  - \"secret\"\n  - \"apikey\"\n  - \"\\\\bsql\\\\b\"\n\n# Risk weights for violations\nrisk_weights:\n  excessive_amount: 0.4\n  sensitive_data: 0.5\n  sql_injection: 0.6\n\n# Threshold for failing validation\nfail_risk_threshold: 0.8\n\n# Maximum number of steps allowed in a plan\nmax_steps: 20\n</code></pre>"},{"location":"documentation/policy-formats/#available-rules","title":"Available Rules","text":"Rule Description Example <code>allow_tools</code> List of permitted tools <code>- db.query_ro</code> <code>bounds</code> Parameter boundaries <code>payments.amount: [0.01, 10000]</code> <code>deny_tokens_regex</code> Prohibited patterns <code>- \"password\"</code> <code>allow_tokens_regex</code> Permitted patterns <code>- \"safe_pattern\"</code> <code>risk_weights</code> Violation risk weights <code>sql_injection: 0.6</code> <code>fail_risk_threshold</code> Risk threshold <code>0.8</code> <code>max_steps</code> Maximum plan steps <code>20</code>"},{"location":"documentation/policy-formats/#example-yaml-policy","title":"Example YAML Policy","text":"<p>Here's a complete example of a YAML policy:</p> <pre><code># policy.yaml\nallow_tools:\n  - db.query_ro\n  - db.query\n  - payments.transfer\n  - analytics.summarize\n  - notify.customer\n\nbounds:\n  payments.transfer.amount: [0.01, 10000.00]\n  db.query.limit: [1, 1000]\n\ndeny_tokens_regex:\n  - \"1=1\"\n  - \"OR 1=1\"\n  - \"DROP TABLE\"\n  - \"--\"\n  - \"password\"\n  - \"secret\"\n  - \"apikey\"\n  - \"creditCard\"\n  - \"ssn\"\n\nrisk_weights:\n  tool_deny: 0.9\n  excessive_amount: 0.4\n  insufficient_amount: 0.1\n  sensitive_data: 0.5\n  sql_injection: 0.6\n\nfail_risk_threshold: 0.8\nmax_steps: 10\n</code></pre>"},{"location":"documentation/policy-formats/#loading-a-yaml-policy","title":"Loading a YAML Policy","text":"<pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n# Load the YAML policy\npolicy = load_policy(\"path/to/policy.yaml\")\n\n# Validate a plan against the policy\nresult = validate_plan(plan, policy=policy)\n</code></pre>"},{"location":"documentation/policy-formats/#rego-policies","title":"Rego Policies","text":"<p>For more advanced policy definitions, Plan-Lint supports Rego, the policy language of Open Policy Agent (OPA). Rego provides a powerful and flexible way to define complex validation rules.</p>"},{"location":"documentation/policy-formats/#basic-structure_1","title":"Basic Structure","text":"<p>A Rego policy for Plan-Lint typically includes:</p> <pre><code>package planlint\n\nimport future.keywords.in\n\n# Default deny policy - all plans are denied unless explicitly allowed\ndefault allow = false\n\n# Default empty violations\ndefault violations = []\n\n# Default risk score is 0\ndefault risk_score = 0.0\n\n# Define allowed tools and other policy components\nallowed_tools = {\n    \"db.query_ro\": {},\n    \"notify.email\": {},\n    \"payments.transfer\": {\"min_amount\": 0.01, \"max_amount\": 10000}\n}\n\n# Allow rule - defines when a plan should be allowed\nallow if {\n    # Add conditions for allowing a plan\n    all_tools_allowed\n    risk_score &lt; 0.8\n}\n\n# Helper rule - check if all tools in the plan are allowed\nall_tools_allowed if {\n    # Logic to check if all tools are allowed\n    tools_in_plan := [step.tool | step := input.plan.steps[_]]\n    not_allowed := [tool | tool := tools_in_plan[_]; not tool in object.keys(allowed_tools)]\n    count(not_allowed) == 0\n}\n\n# Define violations\nviolations[result] {\n    # Logic to detect violations\n    step := input.plan.steps[_]\n    step.tool == \"payments.transfer\"\n    amount := to_number(step.parameters.amount)\n\n    # Check if the amount exceeds the maximum allowed\n    max_amount := allowed_tools[\"payments.transfer\"].max_amount\n    amount &gt; max_amount\n\n    # Return a violation result\n    result := {\n        \"rule\": \"excessive_amount\",\n        \"message\": sprintf(\"Amount %f exceeds maximum allowed %f\", [amount, max_amount]),\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id\n    }\n}\n\n# Calculate risk score based on violations\nrisk_score = total {\n    violation_scores := [violation.risk_score | violation := violations[_]]\n    total := sum(violation_scores)\n}\n</code></pre>"},{"location":"documentation/policy-formats/#input-structure","title":"Input Structure","text":"<p>In your Rego policies, you have access to the plan via the <code>input</code> document:</p> <pre><code>input.plan.steps      # Array of plan steps\ninput.plan.goal       # Plan goal (if provided)\ninput.plan.context    # Plan context (if provided)\ninput.context         # Additional context provided during validation\n</code></pre>"},{"location":"documentation/policy-formats/#example-rego-policy","title":"Example Rego Policy","text":"<p>Here's a more complete example of a Rego policy for Plan-Lint:</p> <pre><code>package planlint\n\nimport future.keywords.in\n\n# Default deny policy\ndefault allow = false\ndefault violations = []\ndefault risk_score = 0.0\n\n# Set of allowed tools with constraints\nallowed_tools = {\n    \"db.query_ro\": {},\n    \"db.query\": {\"max_joins\": 3},\n    \"payments.transfer\": {\"min_amount\": 0.01, \"max_amount\": 10000},\n    \"notify.email\": {\"max_recipients\": 100},\n    \"analytics.summarize\": {}\n}\n\n# Allow rule - defines when a plan should be allowed\nallow if {\n    all_tools_allowed\n    risk_score &lt; 0.8\n}\n\n# Check if all tools in the plan are allowed\nall_tools_allowed if {\n    tools_in_plan := [step.tool | step := input.plan.steps[_]]\n    not_allowed := [tool | tool := tools_in_plan[_]; not tool in object.keys(allowed_tools)]\n    count(not_allowed) == 0\n}\n\n# Collect all violations\nviolations = all_violations {\n    all_violations := array.concat(\n        sql_injection_violations,\n        excessive_amount_violations,\n        sensitive_data_violations\n    )\n}\n\n# Detect SQL injection vulnerabilities\nsql_injection_violations[result] {\n    step := input.plan.steps[_]\n    step.tool in [\"db.query\", \"db.query_ro\"]\n\n    # SQL injection patterns\n    patterns := [\"'--\", \"1=1\", \"'; DROP\", \"OR 1=1\"]\n\n    # Check if query contains any dangerous patterns\n    query := lower(step.parameters.query)\n    some pattern in patterns\n    contains(query, pattern)\n\n    result := {\n        \"rule\": \"sql_injection\",\n        \"message\": sprintf(\"Potential SQL injection detected in query: %s\", [pattern]),\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"risk_score\": 0.8\n    }\n}\n\n# Detect excessive transaction amounts\nexcessive_amount_violations[result] {\n    step := input.plan.steps[_]\n    step.tool == \"payments.transfer\"\n\n    amount := to_number(step.parameters.amount)\n    max_amount := allowed_tools[\"payments.transfer\"].max_amount\n    amount &gt; max_amount\n\n    result := {\n        \"rule\": \"excessive_amount\",\n        \"message\": sprintf(\"Transaction amount %f exceeds maximum allowed %f\", [amount, max_amount]),\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"risk_score\": 0.6\n    }\n}\n\n# Detect sensitive data exposure\nsensitive_data_violations[result] {\n    step := input.plan.steps[_]\n\n    # Look for sensitive parameter names\n    sensitive_patterns := [\"password\", \"secret\", \"token\", \"key\", \"credential\"]\n    some param_name, param_value in step.parameters\n\n    some pattern in sensitive_patterns\n    contains(lower(param_name), pattern)\n\n    result := {\n        \"rule\": \"sensitive_data_exposure\",\n        \"message\": sprintf(\"Step contains sensitive parameter '%s'\", [param_name]),\n        \"severity\": \"medium\",\n        \"category\": \"privacy\",\n        \"step_id\": step.id,\n        \"risk_score\": 0.5\n    }\n}\n\n# Calculate risk score based on violations\nrisk_score = total {\n    violation_scores := [v.risk_score | v := violations[_]]\n    total := sum(violation_scores)\n}\n</code></pre>"},{"location":"documentation/policy-formats/#loading-a-rego-policy","title":"Loading a Rego Policy","text":"<pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n# Load the Rego policy\npolicy_path = \"path/to/policy.rego\"\n_, rego_policy = load_policy(policy_path)\n\n# Validate a plan against the Rego policy\nresult = validate_plan(plan, rego_policy=rego_policy, use_opa=True)\n</code></pre>"},{"location":"documentation/policy-formats/#choosing-a-policy-format","title":"Choosing a Policy Format","text":"<p>Here's a comparison to help you choose the right policy format:</p> Feature YAML Policies Rego Policies Ease of Use Simple to write and understand More complex but powerful Flexibility Limited to predefined rules Unlimited flexibility Logic Complexity Basic constraints Complex logical expressions Custom Rules Limited to existing rule types Custom rule definition Use Case Simple security rules Complex security policies"},{"location":"documentation/policy-formats/#best-practices","title":"Best Practices","text":"<ol> <li>Start Simple: Begin with YAML policies for basic validation needs.</li> <li>Modular Policies: Split complex Rego policies into logical modules.</li> <li>Test Thoroughly: Test policies against both valid and invalid plans.</li> <li>Clear Messages: Write clear violation messages to help users understand issues.</li> <li>Progressive Enhancement: Gradually add more sophisticated rules as needed.</li> <li>Severity Levels: Use consistent severity levels across policies.</li> </ol>"},{"location":"documentation/policy-formats/#converting-between-formats","title":"Converting Between Formats","text":"<p>Plan-Lint provides utilities to convert between YAML and Rego formats:</p> <pre><code>from plan_lint.converter import yaml_to_rego\n\n# Convert a YAML policy to Rego\nyaml_policy_path = \"path/to/policy.yaml\"\nrego_policy = yaml_to_rego(yaml_policy_path)\n\n# Save the Rego policy\nwith open(\"policy.rego\", \"w\") as f:\n    f.write(rego_policy)\n</code></pre> <p>This allows you to start with a simpler YAML policy and convert it to Rego when you need more complex validation logic.</p>"},{"location":"documentation/risk-scoring/","title":"Risk Scoring","text":"<p>This page explains how Plan-Lint calculates risk scores for plans.</p>"},{"location":"documentation/risk-scoring/#overview","title":"Overview","text":"<p>Plan-Lint uses a risk scoring system to quantify the potential security and operational risks in a plan. Rather than simply providing a binary pass/fail result, risk scoring allows for more nuanced evaluation and helps prioritize concerns.</p>"},{"location":"documentation/risk-scoring/#risk-score-calculation","title":"Risk Score Calculation","text":"<p>A risk score is a value between 0.0 and 1.0 that represents the overall risk level of a plan:</p> <ul> <li>0.0: No risk detected</li> <li>1.0: Maximum risk level</li> </ul> <p>The risk score is calculated by aggregating the individual risk scores of all detected violations in a plan.</p>"},{"location":"documentation/risk-scoring/#basic-algorithm","title":"Basic Algorithm","text":"<p>In its simplest form, the risk score calculation follows these steps:</p> <ol> <li>Assign a risk weight to each type of violation</li> <li>Detect all violations in the plan</li> <li>Sum the risk weights of all detected violations</li> <li>Cap the total at 1.0 (if it exceeds 1.0)</li> </ol>"},{"location":"documentation/risk-scoring/#example-calculation","title":"Example Calculation","text":"<p>Consider a plan with the following violations:</p> <ul> <li>SQL injection detected (risk weight: 0.6)</li> <li>Excessive transaction amount (risk weight: 0.4)</li> <li>Sensitive data exposure (risk weight: 0.5)</li> </ul> <p>The total risk score would be: 0.6 + 0.4 + 0.5 = 1.5, but since risk scores are capped at 1.0, the final risk score would be 1.0.</p>"},{"location":"documentation/risk-scoring/#risk-weights","title":"Risk Weights","text":"<p>Each type of violation is assigned a risk weight based on its potential security impact. Default risk weights include:</p> Violation Type Default Risk Weight SQL Injection 0.6 Sensitive Data Exposure 0.5 Excessive Transaction Amount 0.4 Unauthorized Tool Use 0.9 Parameter Bounds Violation 0.3 Too Many Steps 0.2"},{"location":"documentation/risk-scoring/#customizing-risk-weights","title":"Customizing Risk Weights","text":"<p>You can customize risk weights in your YAML policy:</p> <pre><code>risk_weights:\n  sql_injection: 0.7       # Increase SQL injection weight\n  sensitive_data: 0.6      # Increase sensitive data weight\n  excessive_amount: 0.3    # Decrease excessive amount weight\n  unauthorized_tool: 1.0   # Maximum weight for unauthorized tools\n</code></pre> <p>In Rego policies, risk weights are defined within the violation result:</p> <pre><code>violations[result] {\n    # Violation logic\n\n    result := {\n        \"rule\": \"sql_injection\",\n        \"message\": \"SQL injection detected\",\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id,\n        \"risk_score\": 0.7  # Custom risk weight\n    }\n}\n</code></pre>"},{"location":"documentation/risk-scoring/#risk-thresholds","title":"Risk Thresholds","text":"<p>Plans are considered valid if their risk score is below a configured threshold. The default threshold is 0.8, but you can customize it in your policy:</p>"},{"location":"documentation/risk-scoring/#in-yaml","title":"In YAML:","text":"<pre><code>fail_risk_threshold: 0.5  # More strict threshold\n</code></pre>"},{"location":"documentation/risk-scoring/#in-rego","title":"In Rego:","text":"<pre><code># Allow rule - only allow plans with risk score below threshold\nallow if {\n    risk_score &lt; 0.5  # Custom threshold\n}\n</code></pre>"},{"location":"documentation/risk-scoring/#severity-levels","title":"Severity Levels","text":"<p>Risk scores are related to severity levels, but they are different concepts:</p> <ul> <li>Risk Score: A numerical value representing the overall risk (0.0 to 1.0)</li> <li>Severity Level: A categorical label for individual violations (low, medium, high, critical)</li> </ul> <p>The mapping between severity levels and risk weights is approximate:</p> Severity Level Typical Risk Weight Range Low 0.1 - 0.3 Medium 0.3 - 0.5 High 0.5 - 0.7 Critical 0.7 - 1.0"},{"location":"documentation/risk-scoring/#risk-categories","title":"Risk Categories","text":"<p>Violations are also categorized by the type of risk they represent:</p> <ul> <li>Security: Risks related to security vulnerabilities (e.g., SQL injection)</li> <li>Privacy: Risks related to data privacy (e.g., sensitive data exposure)</li> <li>Authorization: Risks related to access control (e.g., unauthorized tool use)</li> <li>Operational: Risks related to system operations (e.g., excessive transaction amount)</li> <li>Compliance: Risks related to regulatory compliance</li> </ul> <p>These categories help organize and prioritize risks in complex systems.</p>"},{"location":"documentation/risk-scoring/#weighted-risk-aggregation","title":"Weighted Risk Aggregation","text":"<p>For more complex risk scoring, Plan-Lint can use weighted aggregation methods:</p>"},{"location":"documentation/risk-scoring/#maximum-risk","title":"Maximum Risk","text":"<p>Instead of summing all risks, take the maximum risk score:</p> <pre><code>risk_score = max_score {\n    violation_scores := [v.risk_score | v := violations[_]]\n    max_score := max(violation_scores)\n}\n</code></pre>"},{"location":"documentation/risk-scoring/#weighted-average","title":"Weighted Average","text":"<p>Calculate a weighted average based on severity:</p> <pre><code>risk_score = weighted_score {\n    # Get all violations with their severity weights\n    violation_data := [[v.risk_score, severity_weight(v.severity)] | v := violations[_]]\n\n    # Calculate weighted sum\n    weighted_sum := sum([score * weight | [score, weight] := violation_data])\n\n    # Calculate total weight\n    total_weight := sum([weight | [_, weight] := violation_data])\n\n    # Weighted average\n    weighted_score := weighted_sum / total_weight\n}\n\n# Helper function to convert severity to weight\nseverity_weight(severity) = weight {\n    severity == \"critical\"\n    weight := 4\n} else = weight {\n    severity == \"high\"\n    weight := 3\n} else = weight {\n    severity == \"medium\"\n    weight := 2\n} else = weight {\n    severity == \"low\"\n    weight := 1\n}\n</code></pre>"},{"location":"documentation/risk-scoring/#risk-score-in-validation-results","title":"Risk Score in Validation Results","text":"<p>When using the Plan-Lint API, the validation result includes the calculated risk score:</p> <pre><code>from plan_lint import validate_plan\n\nresult = validate_plan(plan, policy=policy)\n\nprint(f\"Risk score: {result.risk_score}\")\nprint(f\"Valid: {result.valid}\")\n\nif not result.valid:\n    for violation in result.violations:\n        print(f\"- {violation.rule}: {violation.message} ({violation.severity})\")\n</code></pre>"},{"location":"documentation/risk-scoring/#advanced-risk-scoring-with-context","title":"Advanced Risk Scoring with Context","text":"<p>Risk scoring can incorporate additional context to provide more accurate results:</p> <pre><code># Adjust risk based on environment\nrisk_score = adjusted_score {\n    # Base score calculation\n    violation_scores := [v.risk_score | v := violations[_]]\n    base_score := sum(violation_scores)\n\n    # Environment-based adjustment\n    environment := input.context.environment\n\n    # Higher risk in production\n    adjustment := environment == \"production\" ? 1.2 : 1.0\n\n    # Apply adjustment but cap at 1.0\n    adjusted_score := min(base_score * adjustment, 1.0)\n}\n</code></pre>"},{"location":"documentation/risk-scoring/#best-practices","title":"Best Practices","text":"<ol> <li>Align with Security Policy: Risk weights should reflect your organization's security priorities.</li> <li>Consistent Scoring: Use consistent risk weights across policies.</li> <li>Regular Review: Review and update risk weights as your security posture evolves.</li> <li>Contextualize Risks: Use context information to adjust risk scores for different environments or use cases.</li> <li>Test Thoroughly: Validate your risk scoring logic with a variety of plans to ensure it reflects actual risk levels.</li> <li>Document Thresholds: Document and explain your risk thresholds to users so they understand the validation criteria.</li> </ol>"},{"location":"documentation/risk-scoring/#example-risk-scoring-implementation","title":"Example Risk Scoring Implementation","text":"<p>Here's a complete example of a Rego policy with sophisticated risk scoring:</p> <pre><code>package planlint\n\nimport future.keywords.in\n\n# Default settings\ndefault allow = false\ndefault violations = []\ndefault risk_score = 0.0\n\n# Risk category weights \n# (security issues weighted higher than operational issues)\ncategory_weights = {\n    \"security\": 1.5,\n    \"privacy\": 1.3,\n    \"authorization\": 1.2,\n    \"operational\": 1.0,\n    \"compliance\": 1.4\n}\n\n# Allow rule with customizable threshold\nallow if {\n    # Get threshold from context or use default\n    threshold := object.get(input.context, \"risk_threshold\", 0.8)\n\n    # Plan is valid if risk score is below threshold\n    risk_score &lt; threshold\n}\n\n# Calculate risk score with category weighting\nrisk_score = final_score {\n    # Early return if no violations\n    count(violations) == 0\n    final_score := 0.0\n} else = final_score {\n    # Get scores with category weights applied\n    weighted_scores := [\n        v.risk_score * category_weights[v.category] |\n        v := violations[_]\n    ]\n\n    # Sum weighted scores and cap at 1.0\n    total := sum(weighted_scores)\n    final_score := min(total, 1.0)\n}\n\n# Detect violations (omitted for brevity)\n# ...\n</code></pre> <p>By using sophisticated risk scoring, Plan-Lint can provide more accurate and meaningful validation results, helping you make informed decisions about plan execution.</p>"},{"location":"documentation/rule-types/","title":"Rule Types","text":"<p>This page describes the different types of rules available in Plan-Lint.</p>"},{"location":"documentation/rule-types/#overview","title":"Overview","text":"<p>Plan-Lint offers a variety of rule types to validate different aspects of agent plans. These rules help ensure plans are secure, efficient, and compliant with your organization's policies before execution.</p> <p>Rules are implemented as either built-in checks in the Plan-Lint core or as policy rules in YAML or Rego formats.</p>"},{"location":"documentation/rule-types/#security-rules","title":"Security Rules","text":"<p>Security rules focus on identifying potential security vulnerabilities in plans.</p>"},{"location":"documentation/rule-types/#sql-injection-detection","title":"SQL Injection Detection","text":"<p>Detects potential SQL injection vulnerabilities in database queries.</p> <p>YAML Configuration: <pre><code>deny_tokens_regex:\n  - \"1=1\"\n  - \"OR 1=1\"\n  - \"DROP TABLE\"\n  - \"--\"\n  - \";\"\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    step := input.plan.steps[_]\n    step.tool in [\"db.query\", \"db.query_ro\"]\n\n    # SQL injection patterns\n    patterns := [\"'--\", \"1=1\", \"'; DROP\", \"OR 1=1\"]\n\n    # Check if query contains any dangerous patterns\n    query := lower(step.parameters.query)\n    some pattern in patterns\n    contains(query, pattern)\n\n    result := {\n        \"rule\": \"sql_injection\",\n        \"message\": sprintf(\"Potential SQL injection detected in query: %s\", [pattern]),\n        \"severity\": \"high\",\n        \"category\": \"security\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#sensitive-data-exposure","title":"Sensitive Data Exposure","text":"<p>Identifies exposure of sensitive information like passwords, API keys, and tokens.</p> <p>YAML Configuration: <pre><code>deny_tokens_regex:\n  - \"password\"\n  - \"apikey\"\n  - \"token\"\n  - \"secret\"\n  - \"credential\"\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    step := input.plan.steps[_]\n\n    # Sensitive parameter patterns\n    sensitive_patterns := [\"password\", \"secret\", \"token\", \"key\", \"credential\"]\n    some param_name, param_value in step.parameters\n\n    some pattern in sensitive_patterns\n    contains(lower(param_name), pattern)\n\n    result := {\n        \"rule\": \"sensitive_data_exposure\",\n        \"message\": sprintf(\"Step contains sensitive parameter '%s'\", [param_name]),\n        \"severity\": \"high\",\n        \"category\": \"privacy\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#command-injection","title":"Command Injection","text":"<p>Detects potential command injection vulnerabilities in shell commands.</p> <p>YAML Configuration: <pre><code>deny_tokens_regex:\n  - \"&amp;&amp;\"\n  - \"||\"\n  - \";\"\n  - \"`\"\n  - \"\\\\$\\\\(\"  # Escape for regex\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    step := input.plan.steps[_]\n    step.tool == \"execute_command\"\n\n    # Command injection patterns\n    patterns := [\"&amp;&amp;\", \"||\", \";\", \"`\", \"$(\"]\n\n    # Check if command contains any dangerous patterns\n    command := step.parameters.command\n    some pattern in patterns\n    contains(command, pattern)\n\n    result := {\n        \"rule\": \"command_injection\",\n        \"message\": sprintf(\"Potential command injection detected: %s\", [pattern]),\n        \"severity\": \"critical\",\n        \"category\": \"security\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#authorization-rules","title":"Authorization Rules","text":"<p>Authorization rules validate that plans only use tools and resources they are authorized to use.</p>"},{"location":"documentation/rule-types/#tool-authorization","title":"Tool Authorization","text":"<p>Verifies that a plan only uses allowed tools.</p> <p>YAML Configuration: <pre><code>allow_tools:\n  - db.query_ro\n  - payments.transfer\n  - notify.email\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    step := input.plan.steps[_]\n\n    # List of allowed tools\n    allowed_tools := {\n        \"db.query_ro\": true,\n        \"payments.transfer\": true,\n        \"notify.email\": true\n    }\n\n    # Check if tool is not in allowed list\n    not allowed_tools[step.tool]\n\n    result := {\n        \"rule\": \"unauthorized_tool\",\n        \"message\": sprintf(\"Tool '%s' is not authorized\", [step.tool]),\n        \"severity\": \"high\",\n        \"category\": \"authorization\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#role-based-access-control","title":"Role-Based Access Control","text":"<p>Validates that plans only use tools appropriate for the user's role.</p> <p>Rego Implementation: <pre><code>violations[result] {\n    # Get user role from context\n    role := input.context.user_role\n\n    # Role-specific allowed tools\n    allowed_tools_by_role := {\n        \"admin\": {\"db.query\", \"db.write\", \"payments.transfer\", \"system.configure\"},\n        \"editor\": {\"db.query\", \"payments.transfer\"},\n        \"viewer\": {\"db.query_ro\"}\n    }\n\n    # Get allowed tools for this role\n    role_tools := allowed_tools_by_role[role]\n\n    # Check each step\n    step := input.plan.steps[_]\n    not step.tool in role_tools\n\n    result := {\n        \"rule\": \"role_authorization\",\n        \"message\": sprintf(\"Role '%s' is not authorized to use tool '%s'\", [role, step.tool]),\n        \"severity\": \"high\",\n        \"category\": \"authorization\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#operational-rules","title":"Operational Rules","text":"<p>Operational rules ensure that plans follow operational best practices and constraints.</p>"},{"location":"documentation/rule-types/#parameter-boundaries","title":"Parameter Boundaries","text":"<p>Enforces limits on parameter values, such as transaction amounts or query limits.</p> <p>YAML Configuration: <pre><code>bounds:\n  payments.transfer.amount: [0.01, 10000.00]\n  db.query.limit: [1, 1000]\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    step := input.plan.steps[_]\n    step.tool == \"payments.transfer\"\n\n    # Check amount boundaries\n    amount := to_number(step.parameters.amount)\n    min_amount := 0.01\n    max_amount := 10000.00\n\n    # Check if amount is outside boundaries\n    amount &lt; min_amount or amount &gt; max_amount\n\n    result := {\n        \"rule\": \"parameter_bounds\",\n        \"message\": sprintf(\"Amount %f is outside allowed range [%f, %f]\", [amount, min_amount, max_amount]),\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#step-limit","title":"Step Limit","text":"<p>Ensures that plans don't have too many steps, which could indicate complexity issues.</p> <p>YAML Configuration: <pre><code>max_steps: 20\n</code></pre></p> <p>Rego Implementation: <pre><code>violations[result] {\n    # Count steps in plan\n    step_count := count(input.plan.steps)\n\n    # Maximum allowed steps\n    max_steps := 20\n\n    # Check if too many steps\n    step_count &gt; max_steps\n\n    result := {\n        \"rule\": \"too_many_steps\",\n        \"message\": sprintf(\"Plan has %d steps, exceeding maximum of %d\", [step_count, max_steps]),\n        \"severity\": \"low\",\n        \"category\": \"operational\",\n        \"step_id\": input.plan.steps[0].id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#dependency-validation","title":"Dependency Validation","text":"<p>Verifies that step dependencies are correctly configured.</p> <p>Rego Implementation: <pre><code>violations[result] {\n    # Check each step with dependencies\n    step := input.plan.steps[_]\n    step.depends_on\n\n    # Get all step IDs\n    step_ids := {s.id | s := input.plan.steps[_]}\n\n    # Check if any dependency is missing\n    some dep in step.depends_on\n    not dep in step_ids\n\n    result := {\n        \"rule\": \"invalid_dependency\",\n        \"message\": sprintf(\"Step '%s' depends on non-existent step '%s'\", [step.id, dep]),\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#compliance-rules","title":"Compliance Rules","text":"<p>Compliance rules ensure that plans adhere to regulatory and organizational compliance requirements.</p>"},{"location":"documentation/rule-types/#data-retention","title":"Data Retention","text":"<p>Ensures that plans don't retain sensitive data longer than necessary.</p> <p>Rego Implementation: <pre><code>violations[result] {\n    # Check for data storage steps\n    step := input.plan.steps[_]\n    step.tool in [\"db.write\", \"file.write\", \"storage.save\"]\n\n    # Check if retention period is specified\n    not step.parameters.retention_period\n\n    # Check if data is sensitive\n    some param_name, param_value in step.parameters\n    contains(lower(param_name), \"data\")\n\n    result := {\n        \"rule\": \"data_retention\",\n        \"message\": \"Data storage operation missing retention period\",\n        \"severity\": \"medium\",\n        \"category\": \"compliance\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#audit-logging","title":"Audit Logging","text":"<p>Verifies that sensitive operations include appropriate audit logging.</p> <p>Rego Implementation: <pre><code>violations[result] {\n    # Sensitive operations that require audit logging\n    sensitive_tools := {\"payments.transfer\", \"db.write\", \"user.create\", \"user.delete\"}\n\n    # Check each step\n    step := input.plan.steps[_]\n    step.tool in sensitive_tools\n\n    # Check if there's an audit logging step that depends on this step\n    audit_step_exists := some audit_step in input.plan.steps; \n        audit_step.tool == \"audit.log\" and \n        step.id in audit_step.depends_on\n\n    not audit_step_exists\n\n    result := {\n        \"rule\": \"missing_audit_logging\",\n        \"message\": sprintf(\"Sensitive operation '%s' is missing audit logging\", [step.tool]),\n        \"severity\": \"medium\",\n        \"category\": \"compliance\",\n        \"step_id\": step.id\n    }\n}\n</code></pre></p>"},{"location":"documentation/rule-types/#custom-rules","title":"Custom Rules","text":"<p>Plan-Lint allows you to define custom rules tailored to your specific needs.</p>"},{"location":"documentation/rule-types/#custom-rego-rules","title":"Custom Rego Rules","text":"<p>You can create custom rules by defining new violation detection logic in Rego:</p> <pre><code># Custom rule to detect excessive API calls to the same endpoint\nviolations[result] {\n    # Group steps by API endpoint\n    api_steps := [step | step := input.plan.steps[_]; step.tool == \"api.call\"]\n    endpoints := {endpoint | step := api_steps[_]; endpoint := step.parameters.endpoint}\n\n    # Check each endpoint\n    some endpoint in endpoints\n    endpoint_steps := [step | step := api_steps[_]; step.parameters.endpoint == endpoint]\n\n    # Check if too many calls to same endpoint\n    count(endpoint_steps) &gt; 5\n\n    result := {\n        \"rule\": \"excessive_api_calls\",\n        \"message\": sprintf(\"Too many API calls (%d) to endpoint '%s'\", [count(endpoint_steps), endpoint]),\n        \"severity\": \"medium\",\n        \"category\": \"operational\",\n        \"step_id\": endpoint_steps[0].id\n    }\n}\n</code></pre>"},{"location":"documentation/rule-types/#custom-python-rules","title":"Custom Python Rules","text":"<p>For more complex rules, you can implement custom Python rules by extending the Plan-Lint API:</p> <pre><code>from typing import List\nfrom plan_lint.types import Plan, PlanError, ErrorCode\n\ndef check_resource_throttling(plan: Plan) -&gt; List[PlanError]:\n    \"\"\"Custom rule to detect excessive resource usage.\"\"\"\n    errors = []\n\n    # Group steps by resource type\n    resource_usage = {}\n    for i, step in enumerate(plan.steps):\n        resource = step.tool.split('.')[0]\n        if resource not in resource_usage:\n            resource_usage[resource] = []\n        resource_usage[resource].append(i)\n\n    # Check for excessive usage of any resource\n    for resource, steps in resource_usage.items():\n        if len(steps) &gt; 10:\n            errors.append(\n                PlanError(\n                    step=steps[0],\n                    code=ErrorCode.CUSTOM,\n                    msg=f\"Excessive use of resource '{resource}' ({len(steps)} steps)\",\n                )\n            )\n\n    return errors\n</code></pre>"},{"location":"documentation/rule-types/#rule-severity-levels","title":"Rule Severity Levels","text":"<p>Plan-Lint uses several severity levels to indicate the importance of rule violations:</p> <ul> <li>Critical: Severe issues that must be addressed immediately (e.g., command injection)</li> <li>High: Significant security or operational concerns (e.g., SQL injection, sensitive data exposure)</li> <li>Medium: Important issues that should be addressed (e.g., parameter bounds violations)</li> <li>Low: Minor issues or best practice recommendations (e.g., too many steps)</li> </ul>"},{"location":"documentation/rule-types/#creating-effective-rules","title":"Creating Effective Rules","text":"<p>When creating rules for Plan-Lint, follow these best practices:</p> <ol> <li>Be Specific: Target your rules to address specific security or operational concerns.</li> <li>Provide Clear Messages: Ensure violation messages clearly explain the issue and how to fix it.</li> <li>Balance Security and Usability: Overly restrictive rules can lead to workarounds or reduced adoption.</li> <li>Test Thoroughly: Validate your rules against a variety of plans, both valid and invalid.</li> <li>Document: Document your rules, including their purpose, severity, and potential remediation actions.</li> </ol>"},{"location":"documentation/rule-types/#using-rules-effectively","title":"Using Rules Effectively","text":"<p>To get the most out of Plan-Lint rules:</p> <ol> <li>Start with Built-in Rules: Begin with Plan-Lint's built-in security and operational rules.</li> <li>Customize for Your Environment: Adjust rule parameters to match your specific requirements.</li> <li>Layer Rules: Combine different rule types to create comprehensive validation coverage.</li> <li>Regular Updates: Review and update your rules as your security requirements evolve.</li> <li>Integrate with CI/CD: Automate plan validation with your CI/CD pipeline to catch issues early.</li> </ol>"},{"location":"examples/","title":"Examples Overview","text":"<p>This section provides practical examples of using Plan-Lint to validate AI agent plans.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<p>Plan-Lint can be used in various scenarios to validate AI agent plans. We provide several examples to demonstrate its capabilities:</p>"},{"location":"examples/#finance-agent-system","title":"Finance Agent System","text":"<p>This example demonstrates how to use Plan-Lint to validate financial transaction plans, including:</p> <ul> <li>Detecting excessive transaction amounts</li> <li>Validating proper account access</li> <li>Ensuring proper audit logging</li> <li>Preventing sensitive data exposure</li> </ul>"},{"location":"examples/#sql-injection-prevention","title":"SQL Injection Prevention","text":"<p>Learn how Plan-Lint detects and prevents SQL injection vulnerabilities in database queries:</p> <ul> <li>Identifying vulnerable query patterns</li> <li>Using parameterized queries</li> <li>Creating custom SQL validation rules</li> <li>Integrating with data access layers</li> </ul>"},{"location":"examples/#custom-rules","title":"Custom Rules","text":"<p>Discover how to extend Plan-Lint with custom validation rules for your specific needs:</p> <ul> <li>Creating Python validation functions</li> <li>Developing Rego policies</li> <li>Defining YAML rule patterns</li> <li>Integrating custom rules with CI/CD pipelines</li> </ul>"},{"location":"examples/#using-the-examples","title":"Using the Examples","text":"<p>Each example provides:</p> <ol> <li>Problem Description: What security or operational issue is being addressed</li> <li>Vulnerable Plan: An example of a problematic plan</li> <li>Validation Policy: The Plan-Lint policy to detect the issue</li> <li>Fixed Plan: A corrected version that addresses the vulnerability</li> <li>Integration Code: How to integrate the validation into your systems</li> </ol> <p>You can use these examples as templates for your own implementations or as learning resources to understand common validation patterns.</p>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>To run any of the examples, make sure you have Plan-Lint installed:</p> <pre><code>pip install plan-lint\n</code></pre> <p>Then, follow the specific instructions in each example page. Typically, you'll:</p> <ol> <li>Save the example plan to a JSON file</li> <li>Save the policy to a YAML or Rego file</li> <li>Run the validation command</li> <li>Examine the results</li> </ol> <p>For example:</p> <pre><code>plan-lint validate --plan example_plan.json --policy example_policy.yaml\n</code></pre> <p>We encourage you to modify the examples to fit your specific use cases and experiment with different validation rules.</p>"},{"location":"examples/custom-rules/","title":"Custom Rules Examples","text":"<p>This page demonstrates how to create and use custom validation rules with Plan-Lint.</p>"},{"location":"examples/custom-rules/#overview-of-custom-rules","title":"Overview of Custom Rules","text":"<p>Plan-Lint allows you to extend its validation capabilities with custom rules, which can be created in three main ways:</p> <ol> <li>YAML Rules: Simple, declarative rules for common patterns</li> <li>Rego Policies: Advanced rules using Open Policy Agent's Rego language</li> <li>Python Functions: Programmatic rules with full access to the Plan-Lint API</li> </ol>"},{"location":"examples/custom-rules/#custom-yaml-rules","title":"Custom YAML Rules","text":"<p>YAML rules are the simplest way to define custom validation patterns.</p>"},{"location":"examples/custom-rules/#example-custom-transaction-limits","title":"Example: Custom Transaction Limits","text":"<pre><code># custom_transaction_policy.yaml\nallow_tools:\n  - db.query_ro\n  - payments.transfer.small\n  - payments.transfer.medium\n  - payments.transfer.large\n  - notify.email\n\n# Define custom tools with conditions\ntool_patterns:\n  payments.transfer.small:\n    pattern: \"payments.transfer\"\n    conditions:\n      - \"parameters.amount &lt;= 100.0\"\n\n  payments.transfer.medium:\n    pattern: \"payments.transfer\"\n    conditions:\n      - \"parameters.amount &gt; 100.0\"\n      - \"parameters.amount &lt;= 1000.0\"\n\n  payments.transfer.large:\n    pattern: \"payments.transfer\"\n    conditions:\n      - \"parameters.amount &gt; 1000.0\"\n      - \"parameters.amount &lt;= 10000.0\"\n\n# Define different bounds for each tool\nbounds:\n  payments.transfer.small.amount: [0.01, 100.00]\n  payments.transfer.medium.amount: [100.01, 1000.00]\n  payments.transfer.large.amount: [1000.01, 10000.00]\n\n# Additional security rules\ndeny_tokens_regex:\n  - \"DROP TABLE\"\n  - \"1=1\"\n  - \"password\"\n  - \"secret\"\n</code></pre> <p>This policy creates three different levels of payment transactions, each with its own validation rules.</p>"},{"location":"examples/custom-rules/#using-custom-yaml-rules","title":"Using Custom YAML Rules","text":"<pre><code>plan-lint validate --plan payment_plan.json --policy custom_transaction_policy.yaml\n</code></pre>"},{"location":"examples/custom-rules/#custom-rego-policies","title":"Custom Rego Policies","text":"<p>Rego provides a powerful language for expressing complex validation rules.</p>"},{"location":"examples/custom-rules/#example-role-based-access-control","title":"Example: Role-Based Access Control","text":"<pre><code># role_based_policy.rego\npackage planlint\n\nimport future.keywords.in\n\n# Default deny\ndefault allow = false\n\n# Allow if no violations found\nallow {\n    count(violations) == 0\n}\n\n# Define role-based tool access\nallowed_tools_by_role := {\n    \"admin\": {\n        \"db.query\": true,\n        \"db.write\": true,\n        \"payments.transfer\": true,\n        \"system.configure\": true\n    },\n    \"operator\": {\n        \"db.query\": true,\n        \"payments.transfer\": true\n    },\n    \"viewer\": {\n        \"db.query_ro\": true\n    }\n}\n\n# Check if tool is allowed for user role\nviolations[result] {\n    # Get user role from context\n    role := input.context.user_role\n\n    # Get current step\n    step := input.plan.steps[i]\n\n    # Get allowed tools for this role\n    role_tools := allowed_tools_by_role[role]\n\n    # Check if tool is allowed for this role\n    not step.tool in keys(role_tools)\n\n    # Create violation result\n    result := {\n        \"rule\": \"role_authorization\",\n        \"message\": sprintf(\"User with role '%s' is not authorized to use tool '%s'\", [role, step.tool]),\n        \"severity\": \"high\",\n        \"step_id\": step.id\n    }\n}\n\n# Check transaction limits by role\nviolations[result] {\n    # Get user role from context\n    role := input.context.user_role\n\n    # Get current step\n    step := input.plan.steps[i]\n\n    # Only check payment steps\n    step.tool == \"payments.transfer\"\n\n    # Define limits by role\n    limits := {\n        \"admin\": 10000.0,\n        \"operator\": 1000.0,\n        \"viewer\": 0.0\n    }\n\n    # Get amount\n    amount := to_number(step.parameters.amount)\n\n    # Check if amount exceeds limit for role\n    amount &gt; limits[role]\n\n    # Create violation result\n    result := {\n        \"rule\": \"transaction_limit\",\n        \"message\": sprintf(\"Transaction amount %f exceeds limit of %f for role '%s'\", [amount, limits[role], role]),\n        \"severity\": \"high\", \n        \"step_id\": step.id\n    }\n}\n</code></pre>"},{"location":"examples/custom-rules/#using-custom-rego-policies","title":"Using Custom Rego Policies","text":"<pre><code>plan-lint validate --plan payment_plan.json --policy role_based_policy.rego --context context.json\n</code></pre> <p>Where <code>context.json</code> might look like:</p> <pre><code>{\n  \"user_role\": \"operator\",\n  \"environment\": \"production\"\n}\n</code></pre>"},{"location":"examples/custom-rules/#custom-python-rules","title":"Custom Python Rules","text":"<p>For the most flexibility, you can define custom validation functions in Python.</p>"},{"location":"examples/custom-rules/#example-business-hours-validation","title":"Example: Business Hours Validation","text":"<pre><code>from typing import List, Dict, Any, Optional\nfrom datetime import datetime, time\nfrom plan_lint.types import Plan, PlanError, ErrorCode\n\ndef business_hours_validator(plan: Plan, context: Optional[Dict[str, Any]] = None) -&gt; List[PlanError]:\n    \"\"\"\n    Validate that certain operations only occur during business hours.\n\n    Args:\n        plan: The plan to validate\n        context: Optional context information\n\n    Returns:\n        List of validation errors\n    \"\"\"\n    errors = []\n\n    # Define business hours\n    business_start = time(9, 0)  # 9:00 AM\n    business_end = time(17, 0)   # 5:00 PM\n\n    # Get current time from context or use system time\n    current_time = datetime.now().time()\n    if context and \"current_time\" in context:\n        time_str = context[\"current_time\"]\n        try:\n            # Parse time string (assuming format like \"14:30\")\n            hour, minute = map(int, time_str.split(\":\"))\n            current_time = time(hour, minute)\n        except (ValueError, TypeError):\n            pass\n\n    # Check if we're in business hours\n    is_business_hours = (\n        current_time &gt;= business_start and \n        current_time &lt;= business_end\n    )\n\n    # High-risk operations to check\n    high_risk_operations = [\n        \"payments.transfer\",\n        \"user.create_admin\",\n        \"system.configure\",\n        \"db.write\"\n    ]\n\n    # Check each step\n    for i, step in enumerate(plan.steps):\n        if any(step.tool.startswith(op) for op in high_risk_operations):\n            # If outside business hours, add an error\n            if not is_business_hours:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=f\"Operation '{step.tool}' can only be performed during business hours (9:00 AM - 5:00 PM)\"\n                    )\n                )\n\n            # Check for large amounts in any payment\n            if step.tool == \"payments.transfer\":\n                amount = float(step.parameters.get(\"amount\", 0))\n                if amount &gt; 10000:\n                    errors.append(\n                        PlanError(\n                            step=i,\n                            code=ErrorCode.CUSTOM,\n                            msg=f\"Large transfers (${amount}) require additional approval\"\n                        )\n                    )\n\n    return errors\n</code></pre>"},{"location":"examples/custom-rules/#using-custom-python-rules","title":"Using Custom Python Rules","text":"<p>To use custom Python validators:</p> <ol> <li>Create a Python module with your validation functions</li> <li>Import and register your validators</li> </ol> <pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\nfrom my_custom_validators import business_hours_validator\n\n# Load plan and policy\nplan = load_plan(\"payment_plan.json\")\npolicy, rego_policy = load_policy(\"payment_policy.yaml\")\n\n# Set up context\ncontext = {\n    \"user_role\": \"operator\",\n    \"current_time\": \"14:30\"\n}\n\n# Validate with custom validator\nresult = validate_plan(\n    plan,\n    policy,\n    custom_validators=[business_hours_validator],\n    context=context\n)\n\n# Check results\nif result.valid:\n    print(\"Plan is valid!\")\nelse:\n    for error in result.errors:\n        print(f\"Step {error.step}: {error.msg}\")\n</code></pre>"},{"location":"examples/custom-rules/#combining-multiple-custom-rules","title":"Combining Multiple Custom Rules","text":"<p>For comprehensive validation, combine different rule types:</p> <pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_plan, load_policy\nfrom my_custom_validators import (\n    business_hours_validator,\n    data_sensitivity_validator,\n    audit_trail_validator\n)\n\n# Load a Python plan object\nplan = load_plan(\"complex_plan.json\")\n\n# Load multiple policies\nyaml_policy, _ = load_policy(\"security_basics.yaml\")\n_, rego_policy = load_policy(\"role_based_access.rego\")\n\n# Custom Python validators\ncustom_validators = [\n    business_hours_validator,\n    data_sensitivity_validator,\n    audit_trail_validator\n]\n\n# Validate with all rules\nresult = validate_plan(\n    plan,\n    yaml_policy,\n    rego_policy=rego_policy,\n    custom_validators=custom_validators,\n    context={\"user_role\": \"operator\", \"environment\": \"production\"}\n)\n</code></pre>"},{"location":"examples/custom-rules/#cicd-integration-example","title":"CI/CD Integration Example","text":"<p>You can integrate custom rules into your CI/CD pipeline:</p> <pre><code># .github/workflows/validate-plans.yml\nname: Validate Agent Plans\n\non:\n  pull_request:\n    paths:\n      - 'plans/**'\n\njobs:\n  validate:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install plan-lint\n          pip install -e ./custom_validators\n\n      - name: Validate plans\n        run: |\n          python -c \"\n          import glob\n          import json\n          import sys\n          from plan_lint import validate_plan\n          from plan_lint.loader import load_plan, load_policy\n          from custom_validators import register_validators\n\n          # Load all custom validators\n          custom_validators = register_validators()\n\n          # Load policies\n          policy, rego_policy = load_policy('policies/security.yaml')\n\n          failed = False\n\n          for plan_file in glob.glob('plans/**/*.json'):\n              print(f'Validating {plan_file}...')\n              with open(plan_file, 'r') as f:\n                  plan_data = json.load(f)\n\n              plan = load_plan(plan_file)\n\n              # Set context based on environment\n              context = {\n                  'environment': 'ci',\n                  'user_role': 'automation'\n              }\n\n              # Validate plan\n              result = validate_plan(\n                  plan,\n                  policy,\n                  rego_policy=rego_policy,\n                  custom_validators=custom_validators,\n                  context=context\n              )\n\n              if not result.valid:\n                  print(f'\u274c {plan_file} failed validation:')\n                  for error in result.errors:\n                      print(f'  - Step {error.step}: {error.msg}')\n                  failed = True\n              else:\n                  print(f'\u2705 {plan_file} passed validation')\n\n          if failed:\n              sys.exit(1)\n          \"\n</code></pre> <p>By creating custom validation rules, you can extend Plan-Lint to address your organization's specific security and operational requirements. </p>"},{"location":"examples/finance-agent-system/","title":"Finance Agent System","text":"<p>This example demonstrates using Plan-Lint to validate financial transaction plans.</p>"},{"location":"examples/finance-agent-system/#system-overview","title":"System Overview","text":"<p>The Finance Agent System is a multi-agent system designed for secure transaction processing. It consists of:</p> <ol> <li>Orchestrator Agent: Coordinates the overall workflow</li> <li>Transaction Agent: Processes financial transactions</li> <li>Analysis Agent: Analyzes transaction patterns</li> <li>Plan Validator: Validates operational plans before execution</li> </ol>"},{"location":"examples/finance-agent-system/#security-concerns","title":"Security Concerns","text":"<p>Financial systems require rigorous security measures. Common vulnerabilities include:</p> <ul> <li>SQL injection in transaction queries</li> <li>Excessive transaction amounts</li> <li>Unauthorized access to accounts</li> <li>Sensitive data exposure in logs</li> </ul>"},{"location":"examples/finance-agent-system/#sample-plan","title":"Sample Plan","text":"<p>Here's a sample financial transaction plan:</p> <pre><code>{\n  \"goal\": \"Process customer refund\",\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"db.query_ro\",\n      \"parameters\": {\n        \"query\": \"SELECT account_balance FROM accounts WHERE id = ?\",\n        \"params\": [\"ACC-123\"]\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"payments.transfer\",\n      \"parameters\": {\n        \"from_account\": \"COMPANY-MAIN\",\n        \"to_account\": \"ACC-123\",\n        \"amount\": 500.00,\n        \"reason\": \"Customer refund\"\n      },\n      \"depends_on\": [\"step1\"]\n    },\n    {\n      \"id\": \"step3\",\n      \"tool\": \"notify.email\",\n      \"parameters\": {\n        \"to\": \"customer@example.com\",\n        \"subject\": \"Refund Processed\",\n        \"body\": \"Your refund of $500.00 has been processed.\"\n      },\n      \"depends_on\": [\"step2\"]\n    },\n    {\n      \"id\": \"step4\",\n      \"tool\": \"db.write\",\n      \"parameters\": {\n        \"query\": \"UPDATE refund_requests SET status = ? WHERE id = ?\",\n        \"params\": [\"COMPLETED\", \"REQ-456\"]\n      },\n      \"depends_on\": [\"step2\"]\n    }\n  ],\n  \"context\": {\n    \"customer_id\": \"CUST-789\",\n    \"request_id\": \"REQ-456\",\n    \"refund_amount\": 500.00\n  }\n}\n</code></pre>"},{"location":"examples/finance-agent-system/#validation-policy","title":"Validation Policy","text":"<p>Here's a YAML policy specifically designed for financial transactions:</p> <pre><code># finance_policy.yaml\nallow_tools:\n  - db.query_ro\n  - db.write\n  - payments.transfer.small\n  - notify.email\n  - audit.log\n\nbounds:\n  payments.transfer.small.amount: [0.01, 1000.00]\n\ndeny_tokens_regex:\n  - \"DROP TABLE\"\n  - \"1=1\"\n  - \"password\"\n  - \"secret\"\n  - \"apikey\"\n\ntool_patterns:\n  payments.transfer.small:\n    pattern: \"payments.transfer\"\n    conditions:\n      - \"parameters.amount &lt;= 1000.0\"\n\nrisk_weights:\n  sql_injection: 0.8\n  sensitive_data_exposure: 0.7\n  excessive_amount: 0.6\n  unauthorized_tool: 0.9\n\nfail_risk_threshold: 0.5\nmax_steps: 10\n</code></pre>"},{"location":"examples/finance-agent-system/#running-validation","title":"Running Validation","text":"<p>To validate the finance plan against this policy:</p> <pre><code>plan-lint validate --plan finance_plan.json --policy finance_policy.yaml\n</code></pre>"},{"location":"examples/finance-agent-system/#handling-violations","title":"Handling Violations","text":"<p>Here are some common violations and how to address them:</p>"},{"location":"examples/finance-agent-system/#excessive-transaction-amount","title":"Excessive Transaction Amount","text":"<pre><code>Violation: Parameter 'amount' value 5000.00 is outside bounds [0.01, 1000.00]\n</code></pre> <p>Solution: Break large transactions into smaller amounts or require additional authorization steps.</p>"},{"location":"examples/finance-agent-system/#sql-injection-risk","title":"SQL Injection Risk","text":"<pre><code>Violation: Potential SQL injection detected in query\n</code></pre> <p>Solution: Always use parameterized queries with placeholders.</p>"},{"location":"examples/finance-agent-system/#missing-audit-trail","title":"Missing Audit Trail","text":"<pre><code>Violation: Financial transaction missing corresponding audit logging step\n</code></pre> <p>Solution: Add an audit.log step after each financial transaction:</p> <pre><code>{\n  \"id\": \"audit_step\",\n  \"tool\": \"audit.log\",\n  \"parameters\": {\n    \"event\": \"REFUND_PROCESSED\",\n    \"details\": {\n      \"amount\": 500.00,\n      \"accounts\": {\n        \"from\": \"COMPANY-MAIN\",\n        \"to\": \"ACC-123\"\n      }\n    }\n  },\n  \"depends_on\": [\"step2\"]\n}\n</code></pre>"},{"location":"examples/finance-agent-system/#integration-with-agent-system","title":"Integration with Agent System","text":"<p>In a production environment, the Plan Validator would be integrated directly into the agent workflow:</p> <pre><code>from plan_lint import validate_plan\nfrom plan_lint.loader import load_policy\n\n# Load the finance policy\nfinance_policy, rego_policy = load_policy(\"finance_policy.yaml\")\n\ndef validate_finance_plan(plan, context=None):\n    \"\"\"\n    Validate a financial transaction plan before execution.\n\n    Args:\n        plan: The plan to validate\n        context: Optional context information\n\n    Returns:\n        (is_valid, violations): Tuple of validation result and any violations\n    \"\"\"\n    # Add additional context for validation\n    if context is None:\n        context = {}\n\n    context[\"environment\"] = \"production\"\n    context[\"transaction_limits\"] = {\n        \"standard\": 1000.00,\n        \"premium\": 5000.00\n    }\n\n    # Validate the plan\n    result = validate_plan(plan, finance_policy, context=context)\n\n    return result.valid, result.errors\n</code></pre> <p>By integrating Plan-Lint into your financial agent system, you can ensure that all plans are validated against security policies before execution, reducing the risk of financial fraud, data breaches, and operational errors.</p>"},{"location":"examples/sql-injection/","title":"SQL Injection Prevention","text":"<p>This example shows how Plan-Lint can detect and prevent SQL injection vulnerabilities.</p>"},{"location":"examples/sql-injection/#understanding-sql-injection","title":"Understanding SQL Injection","text":"<p>SQL injection is a code injection technique that exploits vulnerabilities in applications that interact with databases. Attackers can insert malicious SQL code that can:</p> <ul> <li>Bypass authentication</li> <li>Access sensitive data</li> <li>Modify database content</li> <li>Delete database data</li> <li>Execute administrative operations</li> </ul>"},{"location":"examples/sql-injection/#vulnerable-plan-example","title":"Vulnerable Plan Example","text":"<p>Consider a plan with a potential SQL injection vulnerability:</p> <pre><code>{\n  \"goal\": \"Retrieve user information\",\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"db.query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = '\" + user_input + \"'\"\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"notify.email\",\n      \"parameters\": {\n        \"to\": \"admin@example.com\",\n        \"subject\": \"User Query Results\",\n        \"body\": \"Query results: {{step1.result}}\"\n      },\n      \"depends_on\": [\"step1\"]\n    }\n  ]\n}\n</code></pre> <p>In this example, the user input is directly concatenated into the SQL query, creating a vulnerability. If a malicious user provides input like <code>admin' OR '1'='1</code>, the query becomes:</p> <pre><code>SELECT * FROM users WHERE username = 'admin' OR '1'='1'\n</code></pre> <p>This would return all users in the database, potentially exposing sensitive information.</p>"},{"location":"examples/sql-injection/#detection-with-plan-lint","title":"Detection with Plan-Lint","text":"<p>Plan-Lint can detect potential SQL injection vulnerabilities in plans. To validate the plan:</p> <pre><code>plan-lint validate --plan vulnerable_query_plan.json\n</code></pre> <p>Plan-Lint would produce output similar to:</p> <pre><code>Validation Results:\n\u2718 Plan validation failed with 1 violation\n\nViolations:\n- [HIGH] sql_injection: Potential SQL injection detected in query (step: step1)\n  SQL query contains string concatenation patterns which is a common indicator of SQL injection vulnerability\n</code></pre>"},{"location":"examples/sql-injection/#sql-injection-policy","title":"SQL Injection Policy","text":"<p>A policy to detect SQL injection might look like this:</p> <pre><code># sql_security_policy.yaml\nallow_tools:\n  - db.query\n  - db.query_ro\n  - notify.email\n\ndeny_tokens_regex:\n  - \"'.*--\"\n  - \"1=1\"\n  - \"'; DROP\"\n  - \"'.*OR.*'.*=.*'\"\n  - \"'.*AND.*'.*=.*'\"\n\nrisk_weights:\n  sql_injection: 0.9\n\nfail_risk_threshold: 0.3\n</code></pre>"},{"location":"examples/sql-injection/#fixed-plan-example","title":"Fixed Plan Example","text":"<p>A safer version of the plan would use parameterized queries:</p> <pre><code>{\n  \"goal\": \"Retrieve user information\",\n  \"steps\": [\n    {\n      \"id\": \"step1\",\n      \"tool\": \"db.query\",\n      \"parameters\": {\n        \"query\": \"SELECT * FROM users WHERE username = ?\",\n        \"params\": [user_input]\n      }\n    },\n    {\n      \"id\": \"step2\",\n      \"tool\": \"notify.email\",\n      \"parameters\": {\n        \"to\": \"admin@example.com\",\n        \"subject\": \"User Query Results\",\n        \"body\": \"Query results: {{step1.result}}\"\n      },\n      \"depends_on\": [\"step1\"]\n    }\n  ]\n}\n</code></pre> <p>In this fixed example:</p> <ol> <li>User input is provided as a parameter rather than being concatenated into the query</li> <li>The database driver handles proper escaping of the input</li> <li>The query structure remains constant regardless of input values</li> </ol>"},{"location":"examples/sql-injection/#advanced-sql-injection-prevention","title":"Advanced SQL Injection Prevention","text":""},{"location":"examples/sql-injection/#using-prepared-statements","title":"Using Prepared Statements","text":"<p>For more complex queries, use prepared statements with named parameters:</p> <pre><code>{\n  \"id\": \"step1\",\n  \"tool\": \"db.query\",\n  \"parameters\": {\n    \"query\": \"SELECT * FROM users WHERE username = :username AND status = :status\",\n    \"params\": {\n      \"username\": user_input,\n      \"status\": \"active\"\n    }\n  }\n}\n</code></pre>"},{"location":"examples/sql-injection/#custom-validation-rules","title":"Custom Validation Rules","text":"<p>You can create custom SQL validation rules for specific database systems:</p> <pre><code>from typing import List\nfrom plan_lint.types import Plan, PlanError, ErrorCode\n\ndef check_sql_patterns(plan: Plan) -&gt; List[PlanError]:\n    \"\"\"Check for problematic SQL patterns specific to your database.\"\"\"\n    errors = []\n\n    for i, step in enumerate(plan.steps):\n        if step.tool.startswith(\"db.\"):\n            query = step.parameters.get(\"query\", \"\")\n\n            # Check for database-specific issues\n            if \"INFORMATION_SCHEMA\" in query:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=\"Query attempts to access system tables\"\n                    )\n                )\n\n            # Check for unparameterized LIKE queries\n            if \"LIKE '%\" in query:\n                errors.append(\n                    PlanError(\n                        step=i,\n                        code=ErrorCode.CUSTOM,\n                        msg=\"LIKE statements should use parameters for pattern values\"\n                    )\n                )\n\n    return errors\n</code></pre>"},{"location":"examples/sql-injection/#integration-with-data-access-layer","title":"Integration with Data Access Layer","text":"<p>For production systems, consider implementing a data access layer that enforces parameterized queries:</p> <pre><code>from plan_lint import validate_plan\nfrom plan_lint.types import Plan, PlanStep\n\ndef create_db_query_step(query: str, params: list) -&gt; PlanStep:\n    \"\"\"\n    Create a safe database query step that enforces parameterization.\n\n    Args:\n        query: SQL query with parameter placeholders\n        params: List of parameter values\n\n    Returns:\n        A safe PlanStep for database queries\n    \"\"\"\n    # Validate that the query uses parameters\n    if \"?\" not in query and \":\" not in query:\n        raise ValueError(\"Query must use parameterized format\")\n\n    return PlanStep(\n        id=\"db_query\",\n        tool=\"db.query_ro\",\n        parameters={\n            \"query\": query,\n            \"params\": params\n        }\n    )\n</code></pre> <p>By using Plan-Lint to validate database operations in your agent plans, you can significantly reduce the risk of SQL injection vulnerabilities and maintain a more secure system.</p>"}]}